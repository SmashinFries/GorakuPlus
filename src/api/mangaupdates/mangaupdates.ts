/**
 * Generated by orval v6.31.0 üç∫
 * Do not edit manually.
 * MangaUpdates API
 * This API powers our website.
Most API functions are public and do not require an account. For user-based functions, you must register an account.
Currently, user registration must be done through our main website and is disabled via this API.

Download OpenAPI Specification: [openapi.yaml](openapi.yaml)

Please contact us at the following emails if you have questions:

* lambchopsil@mangaupdates.com
* manick@mangaupdates.com

## Warranties

MangaUpdates makes no warranties about service availability, correctness of the data, or anything else. The service is provided as is, and may change at any time.

## Acceptable Use Policy

* You will credit MangaUpdates when using data provided by this API.
* You will use reasonable spacing between requests so as not to overwhelm the MangaUpdates servers, and employ caching mechanisms when accessing data.
* You will NOT use MangaUpdates data or API in a way that will:
    * Deceive or defraud users
    * Assist or perform an illegal action
    * Create spam
    * Damage the database

We reserve the right to change this policy at any time.
 * OpenAPI spec version: 1.0.0
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  InfiniteData,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import axios from 'axios'
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios'
import type {
  AboutusCategoryModelUpdateV1,
  AboutusCategoryModelV1,
  AboutusCategoryReorderModelV1,
  AboutusDescriptionModelV1,
  AboutusUserModelUpdateV1,
  AccountForgotPassModelV1,
  AccountLoginModelV1,
  AddMemberAvatarBody,
  AddTemporaryPollImageBody,
  ApiResponseV1,
  AuthorsLockModelUpdateV1,
  AuthorsLockModelV1,
  AuthorsModelUpdateV1,
  AuthorsModelV1,
  AuthorsSearchRequestV1,
  AuthorsSearchResponseV1,
  AuthorsSeriesListRequestV1,
  AuthorsSeriesListResponseV1,
  AvatarModelV1,
  CategoriesModelUpdateV1,
  CategoriesModelV1,
  CategoriesSearchRequestV1,
  CategoriesSearchResponseV1,
  ConvoBulkModelV1,
  ConvoMessageListRequestV1,
  ConvoMessageModelUpdateV1,
  ConvoMessageModelV1,
  ConvoMessageSearchRequestV1,
  ConvoMessageSearchResponseV1,
  ConvoModelAddV1,
  ConvoModelUpdateV1,
  ConvoModelV1,
  ConvoParticipantModelAddV1,
  ConvoParticipantModelV1,
  ConvoSearchRequestV1,
  ConvoSearchResponseV1,
  ConvoUserIgnoreModelV1,
  FaqCategoryModelUpdateV1,
  FaqCategoryModelV1,
  FaqCategoryQuestionsModelV1,
  FaqCategoryReorderModelV1,
  FaqQuestionModelUpdateV1,
  FaqQuestionModelV1,
  ForumAdminHistorySearchRequestV1,
  ForumAdminHistorySearchResponseV1,
  ForumCategoryModelListV1,
  ForumForumModelListV1,
  ForumForumModelV1,
  ForumLookupResponseV1,
  ForumPollModelUpdateV1,
  ForumPollTempImageModelV1,
  ForumPollVoteModelV1,
  ForumPostByUserResponseV1,
  ForumPostListResponseV1,
  ForumPostModelUpdateV1,
  ForumPostModelV1,
  ForumPostReportModelUpdateV1,
  ForumPostReportModelV1,
  ForumSearchRequestV1,
  ForumSearchResponseV1,
  ForumTopicListRequestV1,
  ForumTopicListResponseV1,
  ForumTopicModelAddV1,
  ForumTopicModelUpdateV1,
  ForumTopicModelV1,
  ForumWarnModelUpdateV1,
  ForumWarnModelV1,
  GenreModelStatsV1,
  GenreModelUpdateV1,
  GroupsModelUpdateV1,
  GroupsModelV1,
  GroupsSearchRequestV1,
  GroupsSearchResponseV1,
  GroupsSeriesListResponseV1,
  ListReleasesByDayParams,
  ListTopicsParams,
  ListsBulkAddModelV1,
  ListsModelUpdateV1,
  ListsModelV1,
  ListsPublicSearchResponseV1,
  ListsPublicStatsModelV1,
  ListsSearchRequestV1,
  ListsSearchResponseV1,
  ListsSeriesModelUpdateV1,
  ListsSeriesModelV1,
  ListsSimilarUsersResponseV1,
  MiscOnlineUsersModelV1,
  MiscSlowTransactionStatusResponseV1,
  MiscStatsModelV1,
  PerPageSearchRequestV1,
  PollModelUpdateV1,
  PollModelV1,
  PollVoteStatusModelV1,
  PublishersModelUpdateV1,
  PublishersModelV1,
  PublishersPublicationResponseV1,
  PublishersSearchRequestV1,
  PublishersSearchResponseV1,
  PublishersSeriesListResponseV1,
  ReleaseModelUpdateV1,
  ReleaseModelV1,
  ReleaseModerateRequestV1,
  ReleaseModerateResponseV1,
  ReleaseSearchRequestV1,
  ReleaseSearchResponseV1,
  RetrieveAboutusCategoryParams,
  RetrieveAboutusDescriptionParams,
  RetrieveAuthorParams,
  RetrieveConvoMessageParams,
  RetrieveConvoParams,
  RetrieveFaqCategoryParams,
  RetrieveFaqQuestionParams,
  RetrieveForumParams,
  RetrieveGenreByIdParams,
  RetrieveGroupParams,
  RetrieveListByIdParams,
  RetrieveListSeriesParams,
  RetrieveMemberParams,
  RetrieveMySeriesCommentParams,
  RetrievePostParams,
  RetrievePublicationSeriesParams,
  RetrievePublisherParams,
  RetrieveReleaseParams,
  RetrieveReviewCommentParams,
  RetrieveReviewParams,
  RetrieveSeriesCommentParams,
  RetrieveSeriesParams,
  RetrieveTopicParams,
  RetrieveUserGroupByIdParams,
  ReviewCommentModelUpdateV1,
  ReviewCommentModelV1,
  ReviewCommentSearchRequestV1,
  ReviewCommentSearchResponseV1,
  ReviewModelUpdateV1,
  ReviewModelV1,
  ReviewSearchRequestV1,
  ReviewSearchResponseV1,
  SearchMemberChangeRequestsParams,
  SeriesCategoryUpdateModelV1,
  SeriesCategoryVoteDeleteModelV1,
  SeriesCategoryVoteModelV1,
  SeriesCommentModelUpdateV1,
  SeriesCommentModelV1,
  SeriesCommentModerationResponseV1,
  SeriesCommentReportModelV1,
  SeriesCommentSearchRequestV1,
  SeriesCommentSearchResponseV1,
  SeriesCommentUsefulModelV1,
  SeriesGroupListResponseV1,
  SeriesHistorySearchResponseV1,
  SeriesLockModelUpdateV1,
  SeriesLockModelV1,
  SeriesModelUpdateV1,
  SeriesModelV1,
  SeriesRatingModelV1,
  SeriesRatingRainbowModelV1,
  SeriesSearchRequestV1,
  SeriesSearchResponseV1,
  TimeV1,
  UpdateImageBody,
  UpdateSeriesImageBody,
  UserChangeRequestModelUpdateV1,
  UserChangeRequestModelV1,
  UserChangeRequestSearchResponseV1,
  UserGenreFilterModelV1,
  UserGenreHighlightModelUpdateV1,
  UserGenreHighlightModelV1,
  UserGroupFilterModelV1,
  UserGroupModelUpdateV1,
  UserGroupModelV1,
  UserModelRegisterV1,
  UserModelUpdatePasswordV1,
  UserModelUpdateV1,
  UserModelV1,
  UserSearchRequestV1,
  UserSearchResponseV1,
  UserSubscribedTopicModelV1
} from './models'




/**
 * @summary add a category
 */
export const addAboutusCategory = (
    aboutusCategoryModelUpdateV1: AboutusCategoryModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/aboutus/category`,
      aboutusCategoryModelUpdateV1,options
    );
  }



export const getAddAboutusCategoryMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addAboutusCategory>>, TError,{data: AboutusCategoryModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addAboutusCategory>>, TError,{data: AboutusCategoryModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addAboutusCategory>>, {data: AboutusCategoryModelUpdateV1}> = (props) => {
          const {data} = props ?? {};

          return  addAboutusCategory(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddAboutusCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof addAboutusCategory>>>
    export type AddAboutusCategoryMutationBody = AboutusCategoryModelUpdateV1
    export type AddAboutusCategoryMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary add a category
 */
export const useAddAboutusCategory = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addAboutusCategory>>, TError,{data: AboutusCategoryModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof addAboutusCategory>>,
        TError,
        {data: AboutusCategoryModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getAddAboutusCategoryMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary returns a single category
 */
export const retrieveAboutusCategory = (
    categoryId: number,
    params?: RetrieveAboutusCategoryParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AboutusCategoryModelV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/aboutus/category/${categoryId}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getRetrieveAboutusCategoryQueryKey = (categoryId: number,
    params?: RetrieveAboutusCategoryParams,) => {
    return [`https://api.mangaupdates.com/v1/aboutus/category/${categoryId}`, ...(params ? [params]: [])] as const;
    }

    
export const getRetrieveAboutusCategoryInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveAboutusCategory>>>, TError = AxiosError<void>>(categoryId: number,
    params?: RetrieveAboutusCategoryParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveAboutusCategory>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveAboutusCategoryQueryKey(categoryId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveAboutusCategory>>> = ({ signal }) => retrieveAboutusCategory(categoryId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveAboutusCategory>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveAboutusCategoryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveAboutusCategory>>>
export type RetrieveAboutusCategoryInfiniteQueryError = AxiosError<void>

/**
 * @summary returns a single category
 */
export const useRetrieveAboutusCategoryInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveAboutusCategory>>>, TError = AxiosError<void>>(
 categoryId: number,
    params?: RetrieveAboutusCategoryParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveAboutusCategory>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveAboutusCategoryInfiniteQueryOptions(categoryId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveAboutusCategoryQueryOptions = <TData = Awaited<ReturnType<typeof retrieveAboutusCategory>>, TError = AxiosError<void>>(categoryId: number,
    params?: RetrieveAboutusCategoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveAboutusCategory>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveAboutusCategoryQueryKey(categoryId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveAboutusCategory>>> = ({ signal }) => retrieveAboutusCategory(categoryId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveAboutusCategory>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveAboutusCategoryQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveAboutusCategory>>>
export type RetrieveAboutusCategoryQueryError = AxiosError<void>

/**
 * @summary returns a single category
 */
export const useRetrieveAboutusCategory = <TData = Awaited<ReturnType<typeof retrieveAboutusCategory>>, TError = AxiosError<void>>(
 categoryId: number,
    params?: RetrieveAboutusCategoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveAboutusCategory>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveAboutusCategoryQueryOptions(categoryId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary remove a category
 */
export const deleteAboutusCategory = (
    categoryId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.delete(
      `https://api.mangaupdates.com/v1/aboutus/category/${categoryId}`,options
    );
  }



export const getDeleteAboutusCategoryMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAboutusCategory>>, TError,{categoryId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteAboutusCategory>>, TError,{categoryId: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAboutusCategory>>, {categoryId: number}> = (props) => {
          const {categoryId} = props ?? {};

          return  deleteAboutusCategory(categoryId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAboutusCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAboutusCategory>>>
    
    export type DeleteAboutusCategoryMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary remove a category
 */
export const useDeleteAboutusCategory = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAboutusCategory>>, TError,{categoryId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteAboutusCategory>>,
        TError,
        {categoryId: number},
        TContext
      > => {

      const mutationOptions = getDeleteAboutusCategoryMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary update a category
 */
export const updateAboutusCategory = (
    categoryId: number,
    aboutusCategoryModelUpdateV1: AboutusCategoryModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.patch(
      `https://api.mangaupdates.com/v1/aboutus/category/${categoryId}`,
      aboutusCategoryModelUpdateV1,options
    );
  }



export const getUpdateAboutusCategoryMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAboutusCategory>>, TError,{categoryId: number;data: AboutusCategoryModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateAboutusCategory>>, TError,{categoryId: number;data: AboutusCategoryModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAboutusCategory>>, {categoryId: number;data: AboutusCategoryModelUpdateV1}> = (props) => {
          const {categoryId,data} = props ?? {};

          return  updateAboutusCategory(categoryId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAboutusCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof updateAboutusCategory>>>
    export type UpdateAboutusCategoryMutationBody = AboutusCategoryModelUpdateV1
    export type UpdateAboutusCategoryMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary update a category
 */
export const useUpdateAboutusCategory = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAboutusCategory>>, TError,{categoryId: number;data: AboutusCategoryModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof updateAboutusCategory>>,
        TError,
        {categoryId: number;data: AboutusCategoryModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getUpdateAboutusCategoryMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary returns categories and users
 */
export const retrieveAboutusCategoriesAndUsers = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AboutusCategoryModelV1[]>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/aboutus/users`,options
    );
  }


export const getRetrieveAboutusCategoriesAndUsersQueryKey = () => {
    return [`https://api.mangaupdates.com/v1/aboutus/users`] as const;
    }

    
export const getRetrieveAboutusCategoriesAndUsersInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveAboutusCategoriesAndUsers>>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveAboutusCategoriesAndUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveAboutusCategoriesAndUsersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveAboutusCategoriesAndUsers>>> = ({ signal }) => retrieveAboutusCategoriesAndUsers({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveAboutusCategoriesAndUsers>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveAboutusCategoriesAndUsersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveAboutusCategoriesAndUsers>>>
export type RetrieveAboutusCategoriesAndUsersInfiniteQueryError = AxiosError<unknown>

/**
 * @summary returns categories and users
 */
export const useRetrieveAboutusCategoriesAndUsersInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveAboutusCategoriesAndUsers>>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveAboutusCategoriesAndUsers>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveAboutusCategoriesAndUsersInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveAboutusCategoriesAndUsersQueryOptions = <TData = Awaited<ReturnType<typeof retrieveAboutusCategoriesAndUsers>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveAboutusCategoriesAndUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveAboutusCategoriesAndUsersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveAboutusCategoriesAndUsers>>> = ({ signal }) => retrieveAboutusCategoriesAndUsers({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveAboutusCategoriesAndUsers>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveAboutusCategoriesAndUsersQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveAboutusCategoriesAndUsers>>>
export type RetrieveAboutusCategoriesAndUsersQueryError = AxiosError<unknown>

/**
 * @summary returns categories and users
 */
export const useRetrieveAboutusCategoriesAndUsers = <TData = Awaited<ReturnType<typeof retrieveAboutusCategoriesAndUsers>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveAboutusCategoriesAndUsers>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveAboutusCategoriesAndUsersQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary returns description of site
 */
export const retrieveAboutusDescription = (
    params?: RetrieveAboutusDescriptionParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AboutusDescriptionModelV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/aboutus`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getRetrieveAboutusDescriptionQueryKey = (params?: RetrieveAboutusDescriptionParams,) => {
    return [`https://api.mangaupdates.com/v1/aboutus`, ...(params ? [params]: [])] as const;
    }

    
export const getRetrieveAboutusDescriptionInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveAboutusDescription>>>, TError = AxiosError<unknown>>(params?: RetrieveAboutusDescriptionParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveAboutusDescription>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveAboutusDescriptionQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveAboutusDescription>>> = ({ signal }) => retrieveAboutusDescription(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveAboutusDescription>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveAboutusDescriptionInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveAboutusDescription>>>
export type RetrieveAboutusDescriptionInfiniteQueryError = AxiosError<unknown>

/**
 * @summary returns description of site
 */
export const useRetrieveAboutusDescriptionInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveAboutusDescription>>>, TError = AxiosError<unknown>>(
 params?: RetrieveAboutusDescriptionParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveAboutusDescription>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveAboutusDescriptionInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveAboutusDescriptionQueryOptions = <TData = Awaited<ReturnType<typeof retrieveAboutusDescription>>, TError = AxiosError<unknown>>(params?: RetrieveAboutusDescriptionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveAboutusDescription>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveAboutusDescriptionQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveAboutusDescription>>> = ({ signal }) => retrieveAboutusDescription(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveAboutusDescription>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveAboutusDescriptionQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveAboutusDescription>>>
export type RetrieveAboutusDescriptionQueryError = AxiosError<unknown>

/**
 * @summary returns description of site
 */
export const useRetrieveAboutusDescription = <TData = Awaited<ReturnType<typeof retrieveAboutusDescription>>, TError = AxiosError<unknown>>(
 params?: RetrieveAboutusDescriptionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveAboutusDescription>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveAboutusDescriptionQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary update description of site
 */
export const updateAboutusDescription = (
    aboutusDescriptionModelV1: AboutusDescriptionModelV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/aboutus`,
      aboutusDescriptionModelV1,options
    );
  }



export const getUpdateAboutusDescriptionMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAboutusDescription>>, TError,{data: AboutusDescriptionModelV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateAboutusDescription>>, TError,{data: AboutusDescriptionModelV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAboutusDescription>>, {data: AboutusDescriptionModelV1}> = (props) => {
          const {data} = props ?? {};

          return  updateAboutusDescription(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAboutusDescriptionMutationResult = NonNullable<Awaited<ReturnType<typeof updateAboutusDescription>>>
    export type UpdateAboutusDescriptionMutationBody = AboutusDescriptionModelV1
    export type UpdateAboutusDescriptionMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary update description of site
 */
export const useUpdateAboutusDescription = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAboutusDescription>>, TError,{data: AboutusDescriptionModelV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof updateAboutusDescription>>,
        TError,
        {data: AboutusDescriptionModelV1},
        TContext
      > => {

      const mutationOptions = getUpdateAboutusDescriptionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary reorder aboutus
 */
export const reorderAboutus = (
    aboutusCategoryReorderModelV1: AboutusCategoryReorderModelV1[], options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/aboutus/reorder`,
      aboutusCategoryReorderModelV1,options
    );
  }



export const getReorderAboutusMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof reorderAboutus>>, TError,{data: AboutusCategoryReorderModelV1[]}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof reorderAboutus>>, TError,{data: AboutusCategoryReorderModelV1[]}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof reorderAboutus>>, {data: AboutusCategoryReorderModelV1[]}> = (props) => {
          const {data} = props ?? {};

          return  reorderAboutus(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ReorderAboutusMutationResult = NonNullable<Awaited<ReturnType<typeof reorderAboutus>>>
    export type ReorderAboutusMutationBody = AboutusCategoryReorderModelV1[]
    export type ReorderAboutusMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary reorder aboutus
 */
export const useReorderAboutus = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof reorderAboutus>>, TError,{data: AboutusCategoryReorderModelV1[]}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof reorderAboutus>>,
        TError,
        {data: AboutusCategoryReorderModelV1[]},
        TContext
      > => {

      const mutationOptions = getReorderAboutusMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary add a user to a category
 */
export const addAboutusCategoryUser = (
    categoryId: number,
    aboutusUserModelUpdateV1: AboutusUserModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/aboutus/category/${categoryId}/users`,
      aboutusUserModelUpdateV1,options
    );
  }



export const getAddAboutusCategoryUserMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addAboutusCategoryUser>>, TError,{categoryId: number;data: AboutusUserModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addAboutusCategoryUser>>, TError,{categoryId: number;data: AboutusUserModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addAboutusCategoryUser>>, {categoryId: number;data: AboutusUserModelUpdateV1}> = (props) => {
          const {categoryId,data} = props ?? {};

          return  addAboutusCategoryUser(categoryId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddAboutusCategoryUserMutationResult = NonNullable<Awaited<ReturnType<typeof addAboutusCategoryUser>>>
    export type AddAboutusCategoryUserMutationBody = AboutusUserModelUpdateV1
    export type AddAboutusCategoryUserMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary add a user to a category
 */
export const useAddAboutusCategoryUser = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addAboutusCategoryUser>>, TError,{categoryId: number;data: AboutusUserModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof addAboutusCategoryUser>>,
        TError,
        {categoryId: number;data: AboutusUserModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getAddAboutusCategoryUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary remove a user from a category
 */
export const deleteAboutusCategoryUser = (
    categoryId: number,
    entryId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.delete(
      `https://api.mangaupdates.com/v1/aboutus/category/${categoryId}/users/${entryId}`,options
    );
  }



export const getDeleteAboutusCategoryUserMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAboutusCategoryUser>>, TError,{categoryId: number;entryId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteAboutusCategoryUser>>, TError,{categoryId: number;entryId: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAboutusCategoryUser>>, {categoryId: number;entryId: number}> = (props) => {
          const {categoryId,entryId} = props ?? {};

          return  deleteAboutusCategoryUser(categoryId,entryId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAboutusCategoryUserMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAboutusCategoryUser>>>
    
    export type DeleteAboutusCategoryUserMutationError = AxiosError<void>

    /**
 * @summary remove a user from a category
 */
export const useDeleteAboutusCategoryUser = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAboutusCategoryUser>>, TError,{categoryId: number;entryId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteAboutusCategoryUser>>,
        TError,
        {categoryId: number;entryId: number},
        TContext
      > => {

      const mutationOptions = getDeleteAboutusCategoryUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary retrieve the public captcha key
 */
export const captcha = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/account/captcha`,options
    );
  }


export const getCaptchaQueryKey = () => {
    return [`https://api.mangaupdates.com/v1/account/captcha`] as const;
    }

    
export const getCaptchaInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof captcha>>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof captcha>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCaptchaQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof captcha>>> = ({ signal }) => captcha({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof captcha>>, TError, TData> & { queryKey: QueryKey }
}

export type CaptchaInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof captcha>>>
export type CaptchaInfiniteQueryError = AxiosError<unknown>

/**
 * @summary retrieve the public captcha key
 */
export const useCaptchaInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof captcha>>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof captcha>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getCaptchaInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getCaptchaQueryOptions = <TData = Awaited<ReturnType<typeof captcha>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof captcha>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCaptchaQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof captcha>>> = ({ signal }) => captcha({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof captcha>>, TError, TData> & { queryKey: QueryKey }
}

export type CaptchaQueryResult = NonNullable<Awaited<ReturnType<typeof captcha>>>
export type CaptchaQueryError = AxiosError<unknown>

/**
 * @summary retrieve the public captcha key
 */
export const useCaptcha = <TData = Awaited<ReturnType<typeof captcha>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof captcha>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getCaptchaQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary confirm deletion of your account
 */
export const confirmDeleteAccount = (
    authHash: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/account/delete/confirm/${authHash}`,undefined,options
    );
  }



export const getConfirmDeleteAccountMutationOptions = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof confirmDeleteAccount>>, TError,{authHash: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof confirmDeleteAccount>>, TError,{authHash: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof confirmDeleteAccount>>, {authHash: string}> = (props) => {
          const {authHash} = props ?? {};

          return  confirmDeleteAccount(authHash,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ConfirmDeleteAccountMutationResult = NonNullable<Awaited<ReturnType<typeof confirmDeleteAccount>>>
    
    export type ConfirmDeleteAccountMutationError = AxiosError<ApiResponseV1>

    /**
 * @summary confirm deletion of your account
 */
export const useConfirmDeleteAccount = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof confirmDeleteAccount>>, TError,{authHash: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof confirmDeleteAccount>>,
        TError,
        {authHash: string},
        TContext
      > => {

      const mutationOptions = getConfirmDeleteAccountMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary delete your account
 */
export const deleteAccount = (
    captchaResponse: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/account/delete/${captchaResponse}`,undefined,options
    );
  }



export const getDeleteAccountMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAccount>>, TError,{captchaResponse: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteAccount>>, TError,{captchaResponse: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAccount>>, {captchaResponse: string}> = (props) => {
          const {captchaResponse} = props ?? {};

          return  deleteAccount(captchaResponse,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAccountMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAccount>>>
    
    export type DeleteAccountMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary delete your account
 */
export const useDeleteAccount = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAccount>>, TError,{captchaResponse: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteAccount>>,
        TError,
        {captchaResponse: string},
        TContext
      > => {

      const mutationOptions = getDeleteAccountMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary update a password change using an auth hash
 */
export const confirmAndChangePassword = (
    authHash: string,
    userModelUpdatePasswordV1: UserModelUpdatePasswordV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/account/forgotpass/confirm/${authHash}`,
      userModelUpdatePasswordV1,options
    );
  }



export const getConfirmAndChangePasswordMutationOptions = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof confirmAndChangePassword>>, TError,{authHash: string;data: UserModelUpdatePasswordV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof confirmAndChangePassword>>, TError,{authHash: string;data: UserModelUpdatePasswordV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof confirmAndChangePassword>>, {authHash: string;data: UserModelUpdatePasswordV1}> = (props) => {
          const {authHash,data} = props ?? {};

          return  confirmAndChangePassword(authHash,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ConfirmAndChangePasswordMutationResult = NonNullable<Awaited<ReturnType<typeof confirmAndChangePassword>>>
    export type ConfirmAndChangePasswordMutationBody = UserModelUpdatePasswordV1
    export type ConfirmAndChangePasswordMutationError = AxiosError<ApiResponseV1>

    /**
 * @summary update a password change using an auth hash
 */
export const useConfirmAndChangePassword = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof confirmAndChangePassword>>, TError,{authHash: string;data: UserModelUpdatePasswordV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof confirmAndChangePassword>>,
        TError,
        {authHash: string;data: UserModelUpdatePasswordV1},
        TContext
      > => {

      const mutationOptions = getConfirmAndChangePasswordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary send a forgotten password email
 */
export const forgotPassword = (
    captchaResponse: string,
    accountForgotPassModelV1: AccountForgotPassModelV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/account/forgotpass/${captchaResponse}`,
      accountForgotPassModelV1,options
    );
  }



export const getForgotPasswordMutationOptions = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof forgotPassword>>, TError,{captchaResponse: string;data: AccountForgotPassModelV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof forgotPassword>>, TError,{captchaResponse: string;data: AccountForgotPassModelV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof forgotPassword>>, {captchaResponse: string;data: AccountForgotPassModelV1}> = (props) => {
          const {captchaResponse,data} = props ?? {};

          return  forgotPassword(captchaResponse,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ForgotPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof forgotPassword>>>
    export type ForgotPasswordMutationBody = AccountForgotPassModelV1
    export type ForgotPasswordMutationError = AxiosError<ApiResponseV1>

    /**
 * @summary send a forgotten password email
 */
export const useForgotPassword = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof forgotPassword>>, TError,{captchaResponse: string;data: AccountForgotPassModelV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof forgotPassword>>,
        TError,
        {captchaResponse: string;data: AccountForgotPassModelV1},
        TContext
      > => {

      const mutationOptions = getForgotPasswordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary create a session token
 */
export const login = (
    accountLoginModelV1: AccountLoginModelV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.put(
      `https://api.mangaupdates.com/v1/account/login`,
      accountLoginModelV1,options
    );
  }



export const getLoginMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: AccountLoginModelV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: AccountLoginModelV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof login>>, {data: AccountLoginModelV1}> = (props) => {
          const {data} = props ?? {};

          return  login(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>
    export type LoginMutationBody = AccountLoginModelV1
    export type LoginMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary create a session token
 */
export const useLogin = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: AccountLoginModelV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof login>>,
        TError,
        {data: AccountLoginModelV1},
        TContext
      > => {

      const mutationOptions = getLoginMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary remove a session token
 */
export const logout = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/account/logout`,undefined,options
    );
  }



export const getLogoutMutationOptions = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof logout>>, void> = () => {
          

          return  logout(axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LogoutMutationResult = NonNullable<Awaited<ReturnType<typeof logout>>>
    
    export type LogoutMutationError = AxiosError<ApiResponseV1>

    /**
 * @summary remove a session token
 */
export const useLogout = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof logout>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getLogoutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary get the profile for the current user
 */
export const profile = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserModelV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/account/profile`,options
    );
  }


export const getProfileQueryKey = () => {
    return [`https://api.mangaupdates.com/v1/account/profile`] as const;
    }

    
export const getProfileInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof profile>>>, TError = AxiosError<ApiResponseV1 | void>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof profile>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getProfileQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof profile>>> = ({ signal }) => profile({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof profile>>, TError, TData> & { queryKey: QueryKey }
}

export type ProfileInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof profile>>>
export type ProfileInfiniteQueryError = AxiosError<ApiResponseV1 | void>

/**
 * @summary get the profile for the current user
 */
export const useProfileInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof profile>>>, TError = AxiosError<ApiResponseV1 | void>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof profile>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getProfileInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getProfileQueryOptions = <TData = Awaited<ReturnType<typeof profile>>, TError = AxiosError<ApiResponseV1 | void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof profile>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getProfileQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof profile>>> = ({ signal }) => profile({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof profile>>, TError, TData> & { queryKey: QueryKey }
}

export type ProfileQueryResult = NonNullable<Awaited<ReturnType<typeof profile>>>
export type ProfileQueryError = AxiosError<ApiResponseV1 | void>

/**
 * @summary get the profile for the current user
 */
export const useProfile = <TData = Awaited<ReturnType<typeof profile>>, TError = AxiosError<ApiResponseV1 | void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof profile>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getProfileQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary confirm a new member registration
 */
export const confirmRegistration = (
    authHash: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/account/register/confirm/${authHash}`,undefined,options
    );
  }



export const getConfirmRegistrationMutationOptions = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof confirmRegistration>>, TError,{authHash: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof confirmRegistration>>, TError,{authHash: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof confirmRegistration>>, {authHash: string}> = (props) => {
          const {authHash} = props ?? {};

          return  confirmRegistration(authHash,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ConfirmRegistrationMutationResult = NonNullable<Awaited<ReturnType<typeof confirmRegistration>>>
    
    export type ConfirmRegistrationMutationError = AxiosError<ApiResponseV1>

    /**
 * @summary confirm a new member registration
 */
export const useConfirmRegistration = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof confirmRegistration>>, TError,{authHash: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof confirmRegistration>>,
        TError,
        {authHash: string},
        TContext
      > => {

      const mutationOptions = getConfirmRegistrationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary register a new member
 */
export const registerMember = (
    captchaResponse: string,
    userModelRegisterV1: UserModelRegisterV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/account/register/${captchaResponse}`,
      userModelRegisterV1,options
    );
  }



export const getRegisterMemberMutationOptions = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerMember>>, TError,{captchaResponse: string;data: UserModelRegisterV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof registerMember>>, TError,{captchaResponse: string;data: UserModelRegisterV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof registerMember>>, {captchaResponse: string;data: UserModelRegisterV1}> = (props) => {
          const {captchaResponse,data} = props ?? {};

          return  registerMember(captchaResponse,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RegisterMemberMutationResult = NonNullable<Awaited<ReturnType<typeof registerMember>>>
    export type RegisterMemberMutationBody = UserModelRegisterV1
    export type RegisterMemberMutationError = AxiosError<ApiResponseV1>

    /**
 * @summary register a new member
 */
export const useRegisterMember = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerMember>>, TError,{captchaResponse: string;data: UserModelRegisterV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof registerMember>>,
        TError,
        {captchaResponse: string;data: UserModelRegisterV1},
        TContext
      > => {

      const mutationOptions = getRegisterMemberMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary send an auth email to a user
 */
export const resendAuthEmail = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/account/resendauth/${id}`,undefined,options
    );
  }



export const getResendAuthEmailMutationOptions = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resendAuthEmail>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof resendAuthEmail>>, TError,{id: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof resendAuthEmail>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  resendAuthEmail(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ResendAuthEmailMutationResult = NonNullable<Awaited<ReturnType<typeof resendAuthEmail>>>
    
    export type ResendAuthEmailMutationError = AxiosError<ApiResponseV1>

    /**
 * @summary send an auth email to a user
 */
export const useResendAuthEmail = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resendAuthEmail>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof resendAuthEmail>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getResendAuthEmailMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary send a forgotten password email to a user
 */
export const sendForgotEmail = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/account/sendforgot/${id}`,undefined,options
    );
  }



export const getSendForgotEmailMutationOptions = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendForgotEmail>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof sendForgotEmail>>, TError,{id: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sendForgotEmail>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  sendForgotEmail(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SendForgotEmailMutationResult = NonNullable<Awaited<ReturnType<typeof sendForgotEmail>>>
    
    export type SendForgotEmailMutationError = AxiosError<ApiResponseV1>

    /**
 * @summary send a forgotten password email to a user
 */
export const useSendForgotEmail = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendForgotEmail>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof sendForgotEmail>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getSendForgotEmailMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary add an author
 */
export const addAuthor = (
    authorsModelUpdateV1: AuthorsModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/authors`,
      authorsModelUpdateV1,options
    );
  }



export const getAddAuthorMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addAuthor>>, TError,{data: AuthorsModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addAuthor>>, TError,{data: AuthorsModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addAuthor>>, {data: AuthorsModelUpdateV1}> = (props) => {
          const {data} = props ?? {};

          return  addAuthor(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddAuthorMutationResult = NonNullable<Awaited<ReturnType<typeof addAuthor>>>
    export type AddAuthorMutationBody = AuthorsModelUpdateV1
    export type AddAuthorMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary add an author
 */
export const useAddAuthor = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addAuthor>>, TError,{data: AuthorsModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof addAuthor>>,
        TError,
        {data: AuthorsModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getAddAuthorMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary get a specific author
 */
export const retrieveAuthor = (
    id: number,
    params?: RetrieveAuthorParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AuthorsModelV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/authors/${id}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getRetrieveAuthorQueryKey = (id: number,
    params?: RetrieveAuthorParams,) => {
    return [`https://api.mangaupdates.com/v1/authors/${id}`, ...(params ? [params]: [])] as const;
    }

    
export const getRetrieveAuthorInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveAuthor>>>, TError = AxiosError<void>>(id: number,
    params?: RetrieveAuthorParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveAuthor>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveAuthorQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveAuthor>>> = ({ signal }) => retrieveAuthor(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveAuthor>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveAuthorInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveAuthor>>>
export type RetrieveAuthorInfiniteQueryError = AxiosError<void>

/**
 * @summary get a specific author
 */
export const useRetrieveAuthorInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveAuthor>>>, TError = AxiosError<void>>(
 id: number,
    params?: RetrieveAuthorParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveAuthor>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveAuthorInfiniteQueryOptions(id,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveAuthorQueryOptions = <TData = Awaited<ReturnType<typeof retrieveAuthor>>, TError = AxiosError<void>>(id: number,
    params?: RetrieveAuthorParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveAuthor>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveAuthorQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveAuthor>>> = ({ signal }) => retrieveAuthor(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveAuthor>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveAuthorQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveAuthor>>>
export type RetrieveAuthorQueryError = AxiosError<void>

/**
 * @summary get a specific author
 */
export const useRetrieveAuthor = <TData = Awaited<ReturnType<typeof retrieveAuthor>>, TError = AxiosError<void>>(
 id: number,
    params?: RetrieveAuthorParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveAuthor>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveAuthorQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary delete an author
 */
export const deleteAuthor = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.delete(
      `https://api.mangaupdates.com/v1/authors/${id}`,options
    );
  }



export const getDeleteAuthorMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAuthor>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteAuthor>>, TError,{id: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAuthor>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteAuthor(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAuthorMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAuthor>>>
    
    export type DeleteAuthorMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary delete an author
 */
export const useDeleteAuthor = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAuthor>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteAuthor>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteAuthorMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary update an author
 */
export const updateAuthor = (
    id: number,
    authorsModelUpdateV1: AuthorsModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.patch(
      `https://api.mangaupdates.com/v1/authors/${id}`,
      authorsModelUpdateV1,options
    );
  }



export const getUpdateAuthorMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAuthor>>, TError,{id: number;data: AuthorsModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateAuthor>>, TError,{id: number;data: AuthorsModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAuthor>>, {id: number;data: AuthorsModelUpdateV1}> = (props) => {
          const {id,data} = props ?? {};

          return  updateAuthor(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAuthorMutationResult = NonNullable<Awaited<ReturnType<typeof updateAuthor>>>
    export type UpdateAuthorMutationBody = AuthorsModelUpdateV1
    export type UpdateAuthorMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary update an author
 */
export const useUpdateAuthor = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAuthor>>, TError,{id: number;data: AuthorsModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof updateAuthor>>,
        TError,
        {id: number;data: AuthorsModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getUpdateAuthorMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary get locks for a specific author
 */
export const retrieveAuthorLocks = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AuthorsLockModelV1[]>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/authors/${id}/locks`,options
    );
  }


export const getRetrieveAuthorLocksQueryKey = (id: number,) => {
    return [`https://api.mangaupdates.com/v1/authors/${id}/locks`] as const;
    }

    
export const getRetrieveAuthorLocksInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveAuthorLocks>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveAuthorLocks>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveAuthorLocksQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveAuthorLocks>>> = ({ signal }) => retrieveAuthorLocks(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveAuthorLocks>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveAuthorLocksInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveAuthorLocks>>>
export type RetrieveAuthorLocksInfiniteQueryError = AxiosError<void>

/**
 * @summary get locks for a specific author
 */
export const useRetrieveAuthorLocksInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveAuthorLocks>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveAuthorLocks>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveAuthorLocksInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveAuthorLocksQueryOptions = <TData = Awaited<ReturnType<typeof retrieveAuthorLocks>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveAuthorLocks>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveAuthorLocksQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveAuthorLocks>>> = ({ signal }) => retrieveAuthorLocks(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveAuthorLocks>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveAuthorLocksQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveAuthorLocks>>>
export type RetrieveAuthorLocksQueryError = AxiosError<void>

/**
 * @summary get locks for a specific author
 */
export const useRetrieveAuthorLocks = <TData = Awaited<ReturnType<typeof retrieveAuthorLocks>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveAuthorLocks>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveAuthorLocksQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary lock a field of an author
 */
export const lockAuthorField = (
    id: number,
    item: string,
    authorsLockModelUpdateV1: AuthorsLockModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/authors/${id}/locks/${item}/lock`,
      authorsLockModelUpdateV1,options
    );
  }



export const getLockAuthorFieldMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lockAuthorField>>, TError,{id: number;item: string;data: AuthorsLockModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof lockAuthorField>>, TError,{id: number;item: string;data: AuthorsLockModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof lockAuthorField>>, {id: number;item: string;data: AuthorsLockModelUpdateV1}> = (props) => {
          const {id,item,data} = props ?? {};

          return  lockAuthorField(id,item,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LockAuthorFieldMutationResult = NonNullable<Awaited<ReturnType<typeof lockAuthorField>>>
    export type LockAuthorFieldMutationBody = AuthorsLockModelUpdateV1
    export type LockAuthorFieldMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary lock a field of an author
 */
export const useLockAuthorField = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lockAuthorField>>, TError,{id: number;item: string;data: AuthorsLockModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof lockAuthorField>>,
        TError,
        {id: number;item: string;data: AuthorsLockModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getLockAuthorFieldMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary unlock a field of an author
 */
export const unlockAuthorField = (
    id: number,
    item: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/authors/${id}/locks/${item}/unlock`,undefined,options
    );
  }



export const getUnlockAuthorFieldMutationOptions = <TError = AxiosError<void | ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unlockAuthorField>>, TError,{id: number;item: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof unlockAuthorField>>, TError,{id: number;item: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof unlockAuthorField>>, {id: number;item: string}> = (props) => {
          const {id,item} = props ?? {};

          return  unlockAuthorField(id,item,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UnlockAuthorFieldMutationResult = NonNullable<Awaited<ReturnType<typeof unlockAuthorField>>>
    
    export type UnlockAuthorFieldMutationError = AxiosError<void | ApiResponseV1>

    /**
 * @summary unlock a field of an author
 */
export const useUnlockAuthorField = <TError = AxiosError<void | ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unlockAuthorField>>, TError,{id: number;item: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof unlockAuthorField>>,
        TError,
        {id: number;item: string},
        TContext
      > => {

      const mutationOptions = getUnlockAuthorFieldMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary search authors
 */
export const searchAuthorsPost = (
    authorsSearchRequestV1: AuthorsSearchRequestV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AuthorsSearchResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/authors/search`,
      authorsSearchRequestV1,options
    );
  }



export const getSearchAuthorsPostMutationOptions = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchAuthorsPost>>, TError,{data: AuthorsSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof searchAuthorsPost>>, TError,{data: AuthorsSearchRequestV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchAuthorsPost>>, {data: AuthorsSearchRequestV1}> = (props) => {
          const {data} = props ?? {};

          return  searchAuthorsPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchAuthorsPostMutationResult = NonNullable<Awaited<ReturnType<typeof searchAuthorsPost>>>
    export type SearchAuthorsPostMutationBody = AuthorsSearchRequestV1
    export type SearchAuthorsPostMutationError = AxiosError<ApiResponseV1>

    /**
 * @summary search authors
 */
export const useSearchAuthorsPost = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchAuthorsPost>>, TError,{data: AuthorsSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof searchAuthorsPost>>,
        TError,
        {data: AuthorsSearchRequestV1},
        TContext
      > => {

      const mutationOptions = getSearchAuthorsPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary get the list of series for a specific author
 */
export const retrieveAuthorSeries = (
    id: number,
    authorsSeriesListRequestV1: AuthorsSeriesListRequestV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AuthorsSeriesListResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/authors/${id}/series`,
      authorsSeriesListRequestV1,options
    );
  }



export const getRetrieveAuthorSeriesMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof retrieveAuthorSeries>>, TError,{id: number;data: AuthorsSeriesListRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof retrieveAuthorSeries>>, TError,{id: number;data: AuthorsSeriesListRequestV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof retrieveAuthorSeries>>, {id: number;data: AuthorsSeriesListRequestV1}> = (props) => {
          const {id,data} = props ?? {};

          return  retrieveAuthorSeries(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RetrieveAuthorSeriesMutationResult = NonNullable<Awaited<ReturnType<typeof retrieveAuthorSeries>>>
    export type RetrieveAuthorSeriesMutationBody = AuthorsSeriesListRequestV1
    export type RetrieveAuthorSeriesMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary get the list of series for a specific author
 */
export const useRetrieveAuthorSeries = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof retrieveAuthorSeries>>, TError,{id: number;data: AuthorsSeriesListRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof retrieveAuthorSeries>>,
        TError,
        {id: number;data: AuthorsSeriesListRequestV1},
        TContext
      > => {

      const mutationOptions = getRetrieveAuthorSeriesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary update the image of an author
 */
export const updateImage = (
    id: number,
    updateImageBody: UpdateImageBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {const formData = new FormData();
if(updateImageBody.image !== undefined) {
 formData.append('image', updateImageBody.image)
 }

    
    return axios.post(
      `https://api.mangaupdates.com/v1/authors/${id}/image`,
      formData,options
    );
  }



export const getUpdateImageMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateImage>>, TError,{id: number;data: UpdateImageBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateImage>>, TError,{id: number;data: UpdateImageBody}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateImage>>, {id: number;data: UpdateImageBody}> = (props) => {
          const {id,data} = props ?? {};

          return  updateImage(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateImageMutationResult = NonNullable<Awaited<ReturnType<typeof updateImage>>>
    export type UpdateImageMutationBody = UpdateImageBody
    export type UpdateImageMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary update the image of an author
 */
export const useUpdateImage = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateImage>>, TError,{id: number;data: UpdateImageBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof updateImage>>,
        TError,
        {id: number;data: UpdateImageBody},
        TContext
      > => {

      const mutationOptions = getUpdateImageMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary delete the image of an author
 */
export const deleteImage = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.delete(
      `https://api.mangaupdates.com/v1/authors/${id}/image`,options
    );
  }



export const getDeleteImageMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteImage>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteImage>>, TError,{id: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteImage>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteImage(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteImageMutationResult = NonNullable<Awaited<ReturnType<typeof deleteImage>>>
    
    export type DeleteImageMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary delete the image of an author
 */
export const useDeleteImage = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteImage>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteImage>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteImageMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary combine two categories across the database
 */
export const bulkCombineSeriesCategories = (
    seriesCategoryUpdateModelV1: SeriesCategoryUpdateModelV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/categories/bulk/combine`,
      seriesCategoryUpdateModelV1,options
    );
  }



export const getBulkCombineSeriesCategoriesMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bulkCombineSeriesCategories>>, TError,{data: SeriesCategoryUpdateModelV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof bulkCombineSeriesCategories>>, TError,{data: SeriesCategoryUpdateModelV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bulkCombineSeriesCategories>>, {data: SeriesCategoryUpdateModelV1}> = (props) => {
          const {data} = props ?? {};

          return  bulkCombineSeriesCategories(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BulkCombineSeriesCategoriesMutationResult = NonNullable<Awaited<ReturnType<typeof bulkCombineSeriesCategories>>>
    export type BulkCombineSeriesCategoriesMutationBody = SeriesCategoryUpdateModelV1
    export type BulkCombineSeriesCategoriesMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary combine two categories across the database
 */
export const useBulkCombineSeriesCategories = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bulkCombineSeriesCategories>>, TError,{data: SeriesCategoryUpdateModelV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof bulkCombineSeriesCategories>>,
        TError,
        {data: SeriesCategoryUpdateModelV1},
        TContext
      > => {

      const mutationOptions = getBulkCombineSeriesCategoriesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary delete a category across the database
 */
export const bulkDeleteSeriesCategories = (
    categoriesModelUpdateV1: CategoriesModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/categories/bulk/delete`,
      categoriesModelUpdateV1,options
    );
  }



export const getBulkDeleteSeriesCategoriesMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bulkDeleteSeriesCategories>>, TError,{data: CategoriesModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof bulkDeleteSeriesCategories>>, TError,{data: CategoriesModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bulkDeleteSeriesCategories>>, {data: CategoriesModelUpdateV1}> = (props) => {
          const {data} = props ?? {};

          return  bulkDeleteSeriesCategories(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BulkDeleteSeriesCategoriesMutationResult = NonNullable<Awaited<ReturnType<typeof bulkDeleteSeriesCategories>>>
    export type BulkDeleteSeriesCategoriesMutationBody = CategoriesModelUpdateV1
    export type BulkDeleteSeriesCategoriesMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary delete a category across the database
 */
export const useBulkDeleteSeriesCategories = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bulkDeleteSeriesCategories>>, TError,{data: CategoriesModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof bulkDeleteSeriesCategories>>,
        TError,
        {data: CategoriesModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getBulkDeleteSeriesCategoriesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary find a category by prefix
 */
export const findCategoryByPrefix = (
    categoriesModelUpdateV1: CategoriesModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CategoriesModelV1[]>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/categories/findByPrefix`,
      categoriesModelUpdateV1,options
    );
  }



export const getFindCategoryByPrefixMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof findCategoryByPrefix>>, TError,{data: CategoriesModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof findCategoryByPrefix>>, TError,{data: CategoriesModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof findCategoryByPrefix>>, {data: CategoriesModelUpdateV1}> = (props) => {
          const {data} = props ?? {};

          return  findCategoryByPrefix(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type FindCategoryByPrefixMutationResult = NonNullable<Awaited<ReturnType<typeof findCategoryByPrefix>>>
    export type FindCategoryByPrefixMutationBody = CategoriesModelUpdateV1
    export type FindCategoryByPrefixMutationError = AxiosError<unknown>

    /**
 * @summary find a category by prefix
 */
export const useFindCategoryByPrefix = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof findCategoryByPrefix>>, TError,{data: CategoriesModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof findCategoryByPrefix>>,
        TError,
        {data: CategoriesModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getFindCategoryByPrefixMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary find a category by name
 */
export const findCategoryByExact = (
    categoriesModelUpdateV1: CategoriesModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CategoriesModelV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/categories/findByExact`,
      categoriesModelUpdateV1,options
    );
  }



export const getFindCategoryByExactMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof findCategoryByExact>>, TError,{data: CategoriesModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof findCategoryByExact>>, TError,{data: CategoriesModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof findCategoryByExact>>, {data: CategoriesModelUpdateV1}> = (props) => {
          const {data} = props ?? {};

          return  findCategoryByExact(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type FindCategoryByExactMutationResult = NonNullable<Awaited<ReturnType<typeof findCategoryByExact>>>
    export type FindCategoryByExactMutationBody = CategoriesModelUpdateV1
    export type FindCategoryByExactMutationError = AxiosError<void>

    /**
 * @summary find a category by name
 */
export const useFindCategoryByExact = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof findCategoryByExact>>, TError,{data: CategoriesModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof findCategoryByExact>>,
        TError,
        {data: CategoriesModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getFindCategoryByExactMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary search categories
 */
export const searchCategoriesPost = (
    categoriesSearchRequestV1: CategoriesSearchRequestV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CategoriesSearchResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/categories/search`,
      categoriesSearchRequestV1,options
    );
  }



export const getSearchCategoriesPostMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchCategoriesPost>>, TError,{data: CategoriesSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof searchCategoriesPost>>, TError,{data: CategoriesSearchRequestV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchCategoriesPost>>, {data: CategoriesSearchRequestV1}> = (props) => {
          const {data} = props ?? {};

          return  searchCategoriesPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchCategoriesPostMutationResult = NonNullable<Awaited<ReturnType<typeof searchCategoriesPost>>>
    export type SearchCategoriesPostMutationBody = CategoriesSearchRequestV1
    export type SearchCategoriesPostMutationError = AxiosError<unknown>

    /**
 * @summary search categories
 */
export const useSearchCategoriesPost = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchCategoriesPost>>, TError,{data: CategoriesSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof searchCategoriesPost>>,
        TError,
        {data: CategoriesSearchRequestV1},
        TContext
      > => {

      const mutationOptions = getSearchCategoriesPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary add an convo
 */
export const addConvo = (
    convoModelAddV1: ConvoModelAddV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/convo`,
      convoModelAddV1,options
    );
  }



export const getAddConvoMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addConvo>>, TError,{data: ConvoModelAddV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addConvo>>, TError,{data: ConvoModelAddV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addConvo>>, {data: ConvoModelAddV1}> = (props) => {
          const {data} = props ?? {};

          return  addConvo(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddConvoMutationResult = NonNullable<Awaited<ReturnType<typeof addConvo>>>
    export type AddConvoMutationBody = ConvoModelAddV1
    export type AddConvoMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary add an convo
 */
export const useAddConvo = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addConvo>>, TError,{data: ConvoModelAddV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof addConvo>>,
        TError,
        {data: ConvoModelAddV1},
        TContext
      > => {

      const mutationOptions = getAddConvoMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary abandon convos in bulk
 */
export const abandonConvoBulk = (
    convoBulkModelV1: ConvoBulkModelV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/convo/bulk/abandon`,
      convoBulkModelV1,options
    );
  }



export const getAbandonConvoBulkMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof abandonConvoBulk>>, TError,{data: ConvoBulkModelV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof abandonConvoBulk>>, TError,{data: ConvoBulkModelV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof abandonConvoBulk>>, {data: ConvoBulkModelV1}> = (props) => {
          const {data} = props ?? {};

          return  abandonConvoBulk(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AbandonConvoBulkMutationResult = NonNullable<Awaited<ReturnType<typeof abandonConvoBulk>>>
    export type AbandonConvoBulkMutationBody = ConvoBulkModelV1
    export type AbandonConvoBulkMutationError = AxiosError<unknown>

    /**
 * @summary abandon convos in bulk
 */
export const useAbandonConvoBulk = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof abandonConvoBulk>>, TError,{data: ConvoBulkModelV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof abandonConvoBulk>>,
        TError,
        {data: ConvoBulkModelV1},
        TContext
      > => {

      const mutationOptions = getAbandonConvoBulkMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary delete convos in bulk
 */
export const deleteConvoBulk = (
    convoBulkModelV1: ConvoBulkModelV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/convo/bulk/delete`,
      convoBulkModelV1,options
    );
  }



export const getDeleteConvoBulkMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteConvoBulk>>, TError,{data: ConvoBulkModelV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteConvoBulk>>, TError,{data: ConvoBulkModelV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteConvoBulk>>, {data: ConvoBulkModelV1}> = (props) => {
          const {data} = props ?? {};

          return  deleteConvoBulk(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteConvoBulkMutationResult = NonNullable<Awaited<ReturnType<typeof deleteConvoBulk>>>
    export type DeleteConvoBulkMutationBody = ConvoBulkModelV1
    export type DeleteConvoBulkMutationError = AxiosError<unknown>

    /**
 * @summary delete convos in bulk
 */
export const useDeleteConvoBulk = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteConvoBulk>>, TError,{data: ConvoBulkModelV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteConvoBulk>>,
        TError,
        {data: ConvoBulkModelV1},
        TContext
      > => {

      const mutationOptions = getDeleteConvoBulkMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary get a specific convo
 */
export const retrieveConvo = (
    id: number,
    params?: RetrieveConvoParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ConvoModelV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/convo/${id}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getRetrieveConvoQueryKey = (id: number,
    params?: RetrieveConvoParams,) => {
    return [`https://api.mangaupdates.com/v1/convo/${id}`, ...(params ? [params]: [])] as const;
    }

    
export const getRetrieveConvoInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveConvo>>>, TError = AxiosError<void>>(id: number,
    params?: RetrieveConvoParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveConvo>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveConvoQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveConvo>>> = ({ signal }) => retrieveConvo(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveConvo>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveConvoInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveConvo>>>
export type RetrieveConvoInfiniteQueryError = AxiosError<void>

/**
 * @summary get a specific convo
 */
export const useRetrieveConvoInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveConvo>>>, TError = AxiosError<void>>(
 id: number,
    params?: RetrieveConvoParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveConvo>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveConvoInfiniteQueryOptions(id,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveConvoQueryOptions = <TData = Awaited<ReturnType<typeof retrieveConvo>>, TError = AxiosError<void>>(id: number,
    params?: RetrieveConvoParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveConvo>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveConvoQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveConvo>>> = ({ signal }) => retrieveConvo(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveConvo>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveConvoQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveConvo>>>
export type RetrieveConvoQueryError = AxiosError<void>

/**
 * @summary get a specific convo
 */
export const useRetrieveConvo = <TData = Awaited<ReturnType<typeof retrieveConvo>>, TError = AxiosError<void>>(
 id: number,
    params?: RetrieveConvoParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveConvo>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveConvoQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary delete a convo
 */
export const deleteConvo = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.delete(
      `https://api.mangaupdates.com/v1/convo/${id}`,options
    );
  }



export const getDeleteConvoMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteConvo>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteConvo>>, TError,{id: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteConvo>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteConvo(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteConvoMutationResult = NonNullable<Awaited<ReturnType<typeof deleteConvo>>>
    
    export type DeleteConvoMutationError = AxiosError<void>

    /**
 * @summary delete a convo
 */
export const useDeleteConvo = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteConvo>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteConvo>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteConvoMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary update a convo
 */
export const updateConvo = (
    id: number,
    convoModelUpdateV1: ConvoModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.patch(
      `https://api.mangaupdates.com/v1/convo/${id}`,
      convoModelUpdateV1,options
    );
  }



export const getUpdateConvoMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateConvo>>, TError,{id: number;data: ConvoModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateConvo>>, TError,{id: number;data: ConvoModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateConvo>>, {id: number;data: ConvoModelUpdateV1}> = (props) => {
          const {id,data} = props ?? {};

          return  updateConvo(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateConvoMutationResult = NonNullable<Awaited<ReturnType<typeof updateConvo>>>
    export type UpdateConvoMutationBody = ConvoModelUpdateV1
    export type UpdateConvoMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary update a convo
 */
export const useUpdateConvo = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateConvo>>, TError,{id: number;data: ConvoModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof updateConvo>>,
        TError,
        {id: number;data: ConvoModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getUpdateConvoMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary return whether the user is ignored
 */
export const isUserIgnored = (
    userId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ConvoUserIgnoreModelV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/convo/ignore/${userId}`,options
    );
  }


export const getIsUserIgnoredQueryKey = (userId: number,) => {
    return [`https://api.mangaupdates.com/v1/convo/ignore/${userId}`] as const;
    }

    
export const getIsUserIgnoredInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof isUserIgnored>>>, TError = AxiosError<ApiResponseV1 | void>>(userId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isUserIgnored>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getIsUserIgnoredQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof isUserIgnored>>> = ({ signal }) => isUserIgnored(userId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof isUserIgnored>>, TError, TData> & { queryKey: QueryKey }
}

export type IsUserIgnoredInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof isUserIgnored>>>
export type IsUserIgnoredInfiniteQueryError = AxiosError<ApiResponseV1 | void>

/**
 * @summary return whether the user is ignored
 */
export const useIsUserIgnoredInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof isUserIgnored>>>, TError = AxiosError<ApiResponseV1 | void>>(
 userId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isUserIgnored>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getIsUserIgnoredInfiniteQueryOptions(userId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getIsUserIgnoredQueryOptions = <TData = Awaited<ReturnType<typeof isUserIgnored>>, TError = AxiosError<ApiResponseV1 | void>>(userId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isUserIgnored>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getIsUserIgnoredQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof isUserIgnored>>> = ({ signal }) => isUserIgnored(userId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof isUserIgnored>>, TError, TData> & { queryKey: QueryKey }
}

export type IsUserIgnoredQueryResult = NonNullable<Awaited<ReturnType<typeof isUserIgnored>>>
export type IsUserIgnoredQueryError = AxiosError<ApiResponseV1 | void>

/**
 * @summary return whether the user is ignored
 */
export const useIsUserIgnored = <TData = Awaited<ReturnType<typeof isUserIgnored>>, TError = AxiosError<ApiResponseV1 | void>>(
 userId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isUserIgnored>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getIsUserIgnoredQueryOptions(userId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary ignore a user
 */
export const ignoreUser = (
    userId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/convo/ignore/${userId}`,undefined,options
    );
  }



export const getIgnoreUserMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ignoreUser>>, TError,{userId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ignoreUser>>, TError,{userId: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ignoreUser>>, {userId: number}> = (props) => {
          const {userId} = props ?? {};

          return  ignoreUser(userId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type IgnoreUserMutationResult = NonNullable<Awaited<ReturnType<typeof ignoreUser>>>
    
    export type IgnoreUserMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary ignore a user
 */
export const useIgnoreUser = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ignoreUser>>, TError,{userId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof ignoreUser>>,
        TError,
        {userId: number},
        TContext
      > => {

      const mutationOptions = getIgnoreUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary remove ignore for a user
 */
export const unIgnoreUser = (
    userId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.delete(
      `https://api.mangaupdates.com/v1/convo/ignore/${userId}`,options
    );
  }



export const getUnIgnoreUserMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unIgnoreUser>>, TError,{userId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof unIgnoreUser>>, TError,{userId: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof unIgnoreUser>>, {userId: number}> = (props) => {
          const {userId} = props ?? {};

          return  unIgnoreUser(userId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UnIgnoreUserMutationResult = NonNullable<Awaited<ReturnType<typeof unIgnoreUser>>>
    
    export type UnIgnoreUserMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary remove ignore for a user
 */
export const useUnIgnoreUser = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unIgnoreUser>>, TError,{userId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof unIgnoreUser>>,
        TError,
        {userId: number},
        TContext
      > => {

      const mutationOptions = getUnIgnoreUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary display unread messages
 */
export const convoInbox = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ConvoSearchResponseV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/convo/inbox`,options
    );
  }


export const getConvoInboxQueryKey = () => {
    return [`https://api.mangaupdates.com/v1/convo/inbox`] as const;
    }

    
export const getConvoInboxInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof convoInbox>>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof convoInbox>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getConvoInboxQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof convoInbox>>> = ({ signal }) => convoInbox({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof convoInbox>>, TError, TData> & { queryKey: QueryKey }
}

export type ConvoInboxInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof convoInbox>>>
export type ConvoInboxInfiniteQueryError = AxiosError<unknown>

/**
 * @summary display unread messages
 */
export const useConvoInboxInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof convoInbox>>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof convoInbox>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getConvoInboxInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getConvoInboxQueryOptions = <TData = Awaited<ReturnType<typeof convoInbox>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof convoInbox>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getConvoInboxQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof convoInbox>>> = ({ signal }) => convoInbox({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof convoInbox>>, TError, TData> & { queryKey: QueryKey }
}

export type ConvoInboxQueryResult = NonNullable<Awaited<ReturnType<typeof convoInbox>>>
export type ConvoInboxQueryError = AxiosError<unknown>

/**
 * @summary display unread messages
 */
export const useConvoInbox = <TData = Awaited<ReturnType<typeof convoInbox>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof convoInbox>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getConvoInboxQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary retrieve number of unread messages
 */
export const convoInboxCount = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ConvoSearchResponseV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/convo/inbox/count`,options
    );
  }


export const getConvoInboxCountQueryKey = () => {
    return [`https://api.mangaupdates.com/v1/convo/inbox/count`] as const;
    }

    
export const getConvoInboxCountInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof convoInboxCount>>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof convoInboxCount>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getConvoInboxCountQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof convoInboxCount>>> = ({ signal }) => convoInboxCount({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof convoInboxCount>>, TError, TData> & { queryKey: QueryKey }
}

export type ConvoInboxCountInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof convoInboxCount>>>
export type ConvoInboxCountInfiniteQueryError = AxiosError<unknown>

/**
 * @summary retrieve number of unread messages
 */
export const useConvoInboxCountInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof convoInboxCount>>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof convoInboxCount>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getConvoInboxCountInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getConvoInboxCountQueryOptions = <TData = Awaited<ReturnType<typeof convoInboxCount>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof convoInboxCount>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getConvoInboxCountQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof convoInboxCount>>> = ({ signal }) => convoInboxCount({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof convoInboxCount>>, TError, TData> & { queryKey: QueryKey }
}

export type ConvoInboxCountQueryResult = NonNullable<Awaited<ReturnType<typeof convoInboxCount>>>
export type ConvoInboxCountQueryError = AxiosError<unknown>

/**
 * @summary retrieve number of unread messages
 */
export const useConvoInboxCount = <TData = Awaited<ReturnType<typeof convoInboxCount>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof convoInboxCount>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getConvoInboxCountQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary display sent messages
 */
export const convoSent = (
    perPageSearchRequestV1: PerPageSearchRequestV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ConvoSearchResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/convo/sent`,
      perPageSearchRequestV1,options
    );
  }



export const getConvoSentMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof convoSent>>, TError,{data: PerPageSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof convoSent>>, TError,{data: PerPageSearchRequestV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof convoSent>>, {data: PerPageSearchRequestV1}> = (props) => {
          const {data} = props ?? {};

          return  convoSent(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ConvoSentMutationResult = NonNullable<Awaited<ReturnType<typeof convoSent>>>
    export type ConvoSentMutationBody = PerPageSearchRequestV1
    export type ConvoSentMutationError = AxiosError<unknown>

    /**
 * @summary display sent messages
 */
export const useConvoSent = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof convoSent>>, TError,{data: PerPageSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof convoSent>>,
        TError,
        {data: PerPageSearchRequestV1},
        TContext
      > => {

      const mutationOptions = getConvoSentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary display received (and read) messages
 */
export const convoReceived = (
    perPageSearchRequestV1: PerPageSearchRequestV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ConvoSearchResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/convo/received`,
      perPageSearchRequestV1,options
    );
  }



export const getConvoReceivedMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof convoReceived>>, TError,{data: PerPageSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof convoReceived>>, TError,{data: PerPageSearchRequestV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof convoReceived>>, {data: PerPageSearchRequestV1}> = (props) => {
          const {data} = props ?? {};

          return  convoReceived(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ConvoReceivedMutationResult = NonNullable<Awaited<ReturnType<typeof convoReceived>>>
    export type ConvoReceivedMutationBody = PerPageSearchRequestV1
    export type ConvoReceivedMutationError = AxiosError<unknown>

    /**
 * @summary display received (and read) messages
 */
export const useConvoReceived = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof convoReceived>>, TError,{data: PerPageSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof convoReceived>>,
        TError,
        {data: PerPageSearchRequestV1},
        TContext
      > => {

      const mutationOptions = getConvoReceivedMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary add a message to a convo
 */
export const addConvoMessage = (
    id: number,
    convoMessageModelUpdateV1: ConvoMessageModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/convo/${id}/messages`,
      convoMessageModelUpdateV1,options
    );
  }



export const getAddConvoMessageMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addConvoMessage>>, TError,{id: number;data: ConvoMessageModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addConvoMessage>>, TError,{id: number;data: ConvoMessageModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addConvoMessage>>, {id: number;data: ConvoMessageModelUpdateV1}> = (props) => {
          const {id,data} = props ?? {};

          return  addConvoMessage(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddConvoMessageMutationResult = NonNullable<Awaited<ReturnType<typeof addConvoMessage>>>
    export type AddConvoMessageMutationBody = ConvoMessageModelUpdateV1
    export type AddConvoMessageMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary add a message to a convo
 */
export const useAddConvoMessage = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addConvoMessage>>, TError,{id: number;data: ConvoMessageModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof addConvoMessage>>,
        TError,
        {id: number;data: ConvoMessageModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getAddConvoMessageMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary list convo messages
 */
export const listConvoMessages = (
    id: number,
    convoMessageListRequestV1: ConvoMessageListRequestV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ConvoMessageSearchResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/convo/${id}/messages/list`,
      convoMessageListRequestV1,options
    );
  }



export const getListConvoMessagesMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof listConvoMessages>>, TError,{id: number;data: ConvoMessageListRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof listConvoMessages>>, TError,{id: number;data: ConvoMessageListRequestV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof listConvoMessages>>, {id: number;data: ConvoMessageListRequestV1}> = (props) => {
          const {id,data} = props ?? {};

          return  listConvoMessages(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ListConvoMessagesMutationResult = NonNullable<Awaited<ReturnType<typeof listConvoMessages>>>
    export type ListConvoMessagesMutationBody = ConvoMessageListRequestV1
    export type ListConvoMessagesMutationError = AxiosError<void>

    /**
 * @summary list convo messages
 */
export const useListConvoMessages = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof listConvoMessages>>, TError,{id: number;data: ConvoMessageListRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof listConvoMessages>>,
        TError,
        {id: number;data: ConvoMessageListRequestV1},
        TContext
      > => {

      const mutationOptions = getListConvoMessagesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary get a specific convo message
 */
export const retrieveConvoMessage = (
    id: number,
    messageId: number,
    params?: RetrieveConvoMessageParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ConvoMessageModelV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/convo/${id}/messages/${messageId}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getRetrieveConvoMessageQueryKey = (id: number,
    messageId: number,
    params?: RetrieveConvoMessageParams,) => {
    return [`https://api.mangaupdates.com/v1/convo/${id}/messages/${messageId}`, ...(params ? [params]: [])] as const;
    }

    
export const getRetrieveConvoMessageInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveConvoMessage>>>, TError = AxiosError<void>>(id: number,
    messageId: number,
    params?: RetrieveConvoMessageParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveConvoMessage>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveConvoMessageQueryKey(id,messageId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveConvoMessage>>> = ({ signal }) => retrieveConvoMessage(id,messageId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id && messageId),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveConvoMessage>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveConvoMessageInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveConvoMessage>>>
export type RetrieveConvoMessageInfiniteQueryError = AxiosError<void>

/**
 * @summary get a specific convo message
 */
export const useRetrieveConvoMessageInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveConvoMessage>>>, TError = AxiosError<void>>(
 id: number,
    messageId: number,
    params?: RetrieveConvoMessageParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveConvoMessage>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveConvoMessageInfiniteQueryOptions(id,messageId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveConvoMessageQueryOptions = <TData = Awaited<ReturnType<typeof retrieveConvoMessage>>, TError = AxiosError<void>>(id: number,
    messageId: number,
    params?: RetrieveConvoMessageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveConvoMessage>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveConvoMessageQueryKey(id,messageId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveConvoMessage>>> = ({ signal }) => retrieveConvoMessage(id,messageId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id && messageId),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveConvoMessage>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveConvoMessageQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveConvoMessage>>>
export type RetrieveConvoMessageQueryError = AxiosError<void>

/**
 * @summary get a specific convo message
 */
export const useRetrieveConvoMessage = <TData = Awaited<ReturnType<typeof retrieveConvoMessage>>, TError = AxiosError<void>>(
 id: number,
    messageId: number,
    params?: RetrieveConvoMessageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveConvoMessage>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveConvoMessageQueryOptions(id,messageId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary update a convo message
 */
export const updateConvoMessage = (
    id: number,
    messageId: number,
    convoMessageModelUpdateV1: ConvoMessageModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.patch(
      `https://api.mangaupdates.com/v1/convo/${id}/messages/${messageId}`,
      convoMessageModelUpdateV1,options
    );
  }



export const getUpdateConvoMessageMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateConvoMessage>>, TError,{id: number;messageId: number;data: ConvoMessageModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateConvoMessage>>, TError,{id: number;messageId: number;data: ConvoMessageModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateConvoMessage>>, {id: number;messageId: number;data: ConvoMessageModelUpdateV1}> = (props) => {
          const {id,messageId,data} = props ?? {};

          return  updateConvoMessage(id,messageId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateConvoMessageMutationResult = NonNullable<Awaited<ReturnType<typeof updateConvoMessage>>>
    export type UpdateConvoMessageMutationBody = ConvoMessageModelUpdateV1
    export type UpdateConvoMessageMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary update a convo message
 */
export const useUpdateConvoMessage = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateConvoMessage>>, TError,{id: number;messageId: number;data: ConvoMessageModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof updateConvoMessage>>,
        TError,
        {id: number;messageId: number;data: ConvoMessageModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getUpdateConvoMessageMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary get a specific convo message location
 */
export const retrieveConvoMessageLocation = (
    id: number,
    messageId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/convo/${id}/messages/${messageId}/location`,options
    );
  }


export const getRetrieveConvoMessageLocationQueryKey = (id: number,
    messageId: number,) => {
    return [`https://api.mangaupdates.com/v1/convo/${id}/messages/${messageId}/location`] as const;
    }

    
export const getRetrieveConvoMessageLocationInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveConvoMessageLocation>>>, TError = AxiosError<unknown>>(id: number,
    messageId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveConvoMessageLocation>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveConvoMessageLocationQueryKey(id,messageId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveConvoMessageLocation>>> = ({ signal }) => retrieveConvoMessageLocation(id,messageId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id && messageId),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveConvoMessageLocation>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveConvoMessageLocationInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveConvoMessageLocation>>>
export type RetrieveConvoMessageLocationInfiniteQueryError = AxiosError<unknown>

/**
 * @summary get a specific convo message location
 */
export const useRetrieveConvoMessageLocationInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveConvoMessageLocation>>>, TError = AxiosError<unknown>>(
 id: number,
    messageId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveConvoMessageLocation>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveConvoMessageLocationInfiniteQueryOptions(id,messageId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveConvoMessageLocationQueryOptions = <TData = Awaited<ReturnType<typeof retrieveConvoMessageLocation>>, TError = AxiosError<unknown>>(id: number,
    messageId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveConvoMessageLocation>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveConvoMessageLocationQueryKey(id,messageId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveConvoMessageLocation>>> = ({ signal }) => retrieveConvoMessageLocation(id,messageId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id && messageId),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveConvoMessageLocation>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveConvoMessageLocationQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveConvoMessageLocation>>>
export type RetrieveConvoMessageLocationQueryError = AxiosError<unknown>

/**
 * @summary get a specific convo message location
 */
export const useRetrieveConvoMessageLocation = <TData = Awaited<ReturnType<typeof retrieveConvoMessageLocation>>, TError = AxiosError<unknown>>(
 id: number,
    messageId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveConvoMessageLocation>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveConvoMessageLocationQueryOptions(id,messageId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary search convo
 */
export const searchConvoMessagesPost = (
    id: number,
    convoMessageSearchRequestV1: ConvoMessageSearchRequestV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ConvoMessageSearchResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/convo/${id}/messages/search`,
      convoMessageSearchRequestV1,options
    );
  }



export const getSearchConvoMessagesPostMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchConvoMessagesPost>>, TError,{id: number;data: ConvoMessageSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof searchConvoMessagesPost>>, TError,{id: number;data: ConvoMessageSearchRequestV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchConvoMessagesPost>>, {id: number;data: ConvoMessageSearchRequestV1}> = (props) => {
          const {id,data} = props ?? {};

          return  searchConvoMessagesPost(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchConvoMessagesPostMutationResult = NonNullable<Awaited<ReturnType<typeof searchConvoMessagesPost>>>
    export type SearchConvoMessagesPostMutationBody = ConvoMessageSearchRequestV1
    export type SearchConvoMessagesPostMutationError = AxiosError<void>

    /**
 * @summary search convo
 */
export const useSearchConvoMessagesPost = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchConvoMessagesPost>>, TError,{id: number;data: ConvoMessageSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof searchConvoMessagesPost>>,
        TError,
        {id: number;data: ConvoMessageSearchRequestV1},
        TContext
      > => {

      const mutationOptions = getSearchConvoMessagesPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary abandon a convo
 */
export const abandonConvo = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/convo/${id}/abandon`,undefined,options
    );
  }



export const getAbandonConvoMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof abandonConvo>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof abandonConvo>>, TError,{id: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof abandonConvo>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  abandonConvo(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AbandonConvoMutationResult = NonNullable<Awaited<ReturnType<typeof abandonConvo>>>
    
    export type AbandonConvoMutationError = AxiosError<void>

    /**
 * @summary abandon a convo
 */
export const useAbandonConvo = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof abandonConvo>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof abandonConvo>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getAbandonConvoMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary invite a user to a convo
 */
export const inviteUserToConvo = (
    id: number,
    convoParticipantModelAddV1: ConvoParticipantModelAddV1[], options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/convo/${id}/invite`,
      convoParticipantModelAddV1,options
    );
  }



export const getInviteUserToConvoMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inviteUserToConvo>>, TError,{id: number;data: ConvoParticipantModelAddV1[]}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof inviteUserToConvo>>, TError,{id: number;data: ConvoParticipantModelAddV1[]}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof inviteUserToConvo>>, {id: number;data: ConvoParticipantModelAddV1[]}> = (props) => {
          const {id,data} = props ?? {};

          return  inviteUserToConvo(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InviteUserToConvoMutationResult = NonNullable<Awaited<ReturnType<typeof inviteUserToConvo>>>
    export type InviteUserToConvoMutationBody = ConvoParticipantModelAddV1[]
    export type InviteUserToConvoMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary invite a user to a convo
 */
export const useInviteUserToConvo = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inviteUserToConvo>>, TError,{id: number;data: ConvoParticipantModelAddV1[]}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof inviteUserToConvo>>,
        TError,
        {id: number;data: ConvoParticipantModelAddV1[]},
        TContext
      > => {

      const mutationOptions = getInviteUserToConvoMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary join a convo
 */
export const joinConvo = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/convo/${id}/join`,undefined,options
    );
  }



export const getJoinConvoMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof joinConvo>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof joinConvo>>, TError,{id: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof joinConvo>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  joinConvo(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type JoinConvoMutationResult = NonNullable<Awaited<ReturnType<typeof joinConvo>>>
    
    export type JoinConvoMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary join a convo
 */
export const useJoinConvo = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof joinConvo>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof joinConvo>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getJoinConvoMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary kick a user from a convo
 */
export const kickUserFromConvo = (
    id: number,
    userId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/convo/${id}/kick/${userId}`,undefined,options
    );
  }



export const getKickUserFromConvoMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof kickUserFromConvo>>, TError,{id: number;userId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof kickUserFromConvo>>, TError,{id: number;userId: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof kickUserFromConvo>>, {id: number;userId: number}> = (props) => {
          const {id,userId} = props ?? {};

          return  kickUserFromConvo(id,userId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type KickUserFromConvoMutationResult = NonNullable<Awaited<ReturnType<typeof kickUserFromConvo>>>
    
    export type KickUserFromConvoMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary kick a user from a convo
 */
export const useKickUserFromConvo = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof kickUserFromConvo>>, TError,{id: number;userId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof kickUserFromConvo>>,
        TError,
        {id: number;userId: number},
        TContext
      > => {

      const mutationOptions = getKickUserFromConvoMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary get list of convo participants
 */
export const retrieveConvoParticipants = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ConvoParticipantModelV1[]>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/convo/${id}/participants`,options
    );
  }


export const getRetrieveConvoParticipantsQueryKey = (id: number,) => {
    return [`https://api.mangaupdates.com/v1/convo/${id}/participants`] as const;
    }

    
export const getRetrieveConvoParticipantsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveConvoParticipants>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveConvoParticipants>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveConvoParticipantsQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveConvoParticipants>>> = ({ signal }) => retrieveConvoParticipants(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveConvoParticipants>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveConvoParticipantsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveConvoParticipants>>>
export type RetrieveConvoParticipantsInfiniteQueryError = AxiosError<void>

/**
 * @summary get list of convo participants
 */
export const useRetrieveConvoParticipantsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveConvoParticipants>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveConvoParticipants>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveConvoParticipantsInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveConvoParticipantsQueryOptions = <TData = Awaited<ReturnType<typeof retrieveConvoParticipants>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveConvoParticipants>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveConvoParticipantsQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveConvoParticipants>>> = ({ signal }) => retrieveConvoParticipants(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveConvoParticipants>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveConvoParticipantsQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveConvoParticipants>>>
export type RetrieveConvoParticipantsQueryError = AxiosError<void>

/**
 * @summary get list of convo participants
 */
export const useRetrieveConvoParticipants = <TData = Awaited<ReturnType<typeof retrieveConvoParticipants>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveConvoParticipants>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveConvoParticipantsQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary search convo
 */
export const searchConvoPost = (
    convoSearchRequestV1: ConvoSearchRequestV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ConvoSearchResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/convo/search`,
      convoSearchRequestV1,options
    );
  }



export const getSearchConvoPostMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchConvoPost>>, TError,{data: ConvoSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof searchConvoPost>>, TError,{data: ConvoSearchRequestV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchConvoPost>>, {data: ConvoSearchRequestV1}> = (props) => {
          const {data} = props ?? {};

          return  searchConvoPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchConvoPostMutationResult = NonNullable<Awaited<ReturnType<typeof searchConvoPost>>>
    export type SearchConvoPostMutationBody = ConvoSearchRequestV1
    export type SearchConvoPostMutationError = AxiosError<unknown>

    /**
 * @summary search convo
 */
export const useSearchConvoPost = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchConvoPost>>, TError,{data: ConvoSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof searchConvoPost>>,
        TError,
        {data: ConvoSearchRequestV1},
        TContext
      > => {

      const mutationOptions = getSearchConvoPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary retrieve all categories and questions
 */
export const retrieveAllFaqCategoriesAndQuestions = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<FaqCategoryQuestionsModelV1[]>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/faq`,options
    );
  }


export const getRetrieveAllFaqCategoriesAndQuestionsQueryKey = () => {
    return [`https://api.mangaupdates.com/v1/faq`] as const;
    }

    
export const getRetrieveAllFaqCategoriesAndQuestionsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveAllFaqCategoriesAndQuestions>>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveAllFaqCategoriesAndQuestions>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveAllFaqCategoriesAndQuestionsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveAllFaqCategoriesAndQuestions>>> = ({ signal }) => retrieveAllFaqCategoriesAndQuestions({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveAllFaqCategoriesAndQuestions>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveAllFaqCategoriesAndQuestionsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveAllFaqCategoriesAndQuestions>>>
export type RetrieveAllFaqCategoriesAndQuestionsInfiniteQueryError = AxiosError<unknown>

/**
 * @summary retrieve all categories and questions
 */
export const useRetrieveAllFaqCategoriesAndQuestionsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveAllFaqCategoriesAndQuestions>>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveAllFaqCategoriesAndQuestions>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveAllFaqCategoriesAndQuestionsInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveAllFaqCategoriesAndQuestionsQueryOptions = <TData = Awaited<ReturnType<typeof retrieveAllFaqCategoriesAndQuestions>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveAllFaqCategoriesAndQuestions>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveAllFaqCategoriesAndQuestionsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveAllFaqCategoriesAndQuestions>>> = ({ signal }) => retrieveAllFaqCategoriesAndQuestions({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveAllFaqCategoriesAndQuestions>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveAllFaqCategoriesAndQuestionsQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveAllFaqCategoriesAndQuestions>>>
export type RetrieveAllFaqCategoriesAndQuestionsQueryError = AxiosError<unknown>

/**
 * @summary retrieve all categories and questions
 */
export const useRetrieveAllFaqCategoriesAndQuestions = <TData = Awaited<ReturnType<typeof retrieveAllFaqCategoriesAndQuestions>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveAllFaqCategoriesAndQuestions>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveAllFaqCategoriesAndQuestionsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary add a faq category
 */
export const addFaqCategory = (
    faqCategoryModelUpdateV1: FaqCategoryModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/faq`,
      faqCategoryModelUpdateV1,options
    );
  }



export const getAddFaqCategoryMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addFaqCategory>>, TError,{data: FaqCategoryModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addFaqCategory>>, TError,{data: FaqCategoryModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addFaqCategory>>, {data: FaqCategoryModelUpdateV1}> = (props) => {
          const {data} = props ?? {};

          return  addFaqCategory(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddFaqCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof addFaqCategory>>>
    export type AddFaqCategoryMutationBody = FaqCategoryModelUpdateV1
    export type AddFaqCategoryMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary add a faq category
 */
export const useAddFaqCategory = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addFaqCategory>>, TError,{data: FaqCategoryModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof addFaqCategory>>,
        TError,
        {data: FaqCategoryModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getAddFaqCategoryMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary get a specific category
 */
export const retrieveFaqCategory = (
    categoryId: number,
    params?: RetrieveFaqCategoryParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<FaqCategoryModelV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/faq/${categoryId}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getRetrieveFaqCategoryQueryKey = (categoryId: number,
    params?: RetrieveFaqCategoryParams,) => {
    return [`https://api.mangaupdates.com/v1/faq/${categoryId}`, ...(params ? [params]: [])] as const;
    }

    
export const getRetrieveFaqCategoryInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveFaqCategory>>>, TError = AxiosError<void>>(categoryId: number,
    params?: RetrieveFaqCategoryParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveFaqCategory>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveFaqCategoryQueryKey(categoryId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveFaqCategory>>> = ({ signal }) => retrieveFaqCategory(categoryId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveFaqCategory>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveFaqCategoryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveFaqCategory>>>
export type RetrieveFaqCategoryInfiniteQueryError = AxiosError<void>

/**
 * @summary get a specific category
 */
export const useRetrieveFaqCategoryInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveFaqCategory>>>, TError = AxiosError<void>>(
 categoryId: number,
    params?: RetrieveFaqCategoryParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveFaqCategory>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveFaqCategoryInfiniteQueryOptions(categoryId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveFaqCategoryQueryOptions = <TData = Awaited<ReturnType<typeof retrieveFaqCategory>>, TError = AxiosError<void>>(categoryId: number,
    params?: RetrieveFaqCategoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveFaqCategory>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveFaqCategoryQueryKey(categoryId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveFaqCategory>>> = ({ signal }) => retrieveFaqCategory(categoryId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveFaqCategory>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveFaqCategoryQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveFaqCategory>>>
export type RetrieveFaqCategoryQueryError = AxiosError<void>

/**
 * @summary get a specific category
 */
export const useRetrieveFaqCategory = <TData = Awaited<ReturnType<typeof retrieveFaqCategory>>, TError = AxiosError<void>>(
 categoryId: number,
    params?: RetrieveFaqCategoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveFaqCategory>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveFaqCategoryQueryOptions(categoryId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary delete a faq category
 */
export const deleteFaqCategory = (
    categoryId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.delete(
      `https://api.mangaupdates.com/v1/faq/${categoryId}`,options
    );
  }



export const getDeleteFaqCategoryMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteFaqCategory>>, TError,{categoryId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteFaqCategory>>, TError,{categoryId: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteFaqCategory>>, {categoryId: number}> = (props) => {
          const {categoryId} = props ?? {};

          return  deleteFaqCategory(categoryId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteFaqCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof deleteFaqCategory>>>
    
    export type DeleteFaqCategoryMutationError = AxiosError<void>

    /**
 * @summary delete a faq category
 */
export const useDeleteFaqCategory = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteFaqCategory>>, TError,{categoryId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteFaqCategory>>,
        TError,
        {categoryId: number},
        TContext
      > => {

      const mutationOptions = getDeleteFaqCategoryMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary update a faq category
 */
export const updateFaqCategory = (
    categoryId: number,
    faqCategoryModelUpdateV1: FaqCategoryModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.patch(
      `https://api.mangaupdates.com/v1/faq/${categoryId}`,
      faqCategoryModelUpdateV1,options
    );
  }



export const getUpdateFaqCategoryMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateFaqCategory>>, TError,{categoryId: number;data: FaqCategoryModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateFaqCategory>>, TError,{categoryId: number;data: FaqCategoryModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateFaqCategory>>, {categoryId: number;data: FaqCategoryModelUpdateV1}> = (props) => {
          const {categoryId,data} = props ?? {};

          return  updateFaqCategory(categoryId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateFaqCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof updateFaqCategory>>>
    export type UpdateFaqCategoryMutationBody = FaqCategoryModelUpdateV1
    export type UpdateFaqCategoryMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary update a faq category
 */
export const useUpdateFaqCategory = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateFaqCategory>>, TError,{categoryId: number;data: FaqCategoryModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof updateFaqCategory>>,
        TError,
        {categoryId: number;data: FaqCategoryModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getUpdateFaqCategoryMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary retrieve all quesitons for a category
 */
export const retrieveAllFaqCategoryQuestions = (
    categoryId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<FaqQuestionModelV1[]>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/faq/${categoryId}/questions`,options
    );
  }


export const getRetrieveAllFaqCategoryQuestionsQueryKey = (categoryId: number,) => {
    return [`https://api.mangaupdates.com/v1/faq/${categoryId}/questions`] as const;
    }

    
export const getRetrieveAllFaqCategoryQuestionsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveAllFaqCategoryQuestions>>>, TError = AxiosError<void>>(categoryId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveAllFaqCategoryQuestions>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveAllFaqCategoryQuestionsQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveAllFaqCategoryQuestions>>> = ({ signal }) => retrieveAllFaqCategoryQuestions(categoryId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveAllFaqCategoryQuestions>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveAllFaqCategoryQuestionsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveAllFaqCategoryQuestions>>>
export type RetrieveAllFaqCategoryQuestionsInfiniteQueryError = AxiosError<void>

/**
 * @summary retrieve all quesitons for a category
 */
export const useRetrieveAllFaqCategoryQuestionsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveAllFaqCategoryQuestions>>>, TError = AxiosError<void>>(
 categoryId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveAllFaqCategoryQuestions>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveAllFaqCategoryQuestionsInfiniteQueryOptions(categoryId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveAllFaqCategoryQuestionsQueryOptions = <TData = Awaited<ReturnType<typeof retrieveAllFaqCategoryQuestions>>, TError = AxiosError<void>>(categoryId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveAllFaqCategoryQuestions>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveAllFaqCategoryQuestionsQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveAllFaqCategoryQuestions>>> = ({ signal }) => retrieveAllFaqCategoryQuestions(categoryId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveAllFaqCategoryQuestions>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveAllFaqCategoryQuestionsQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveAllFaqCategoryQuestions>>>
export type RetrieveAllFaqCategoryQuestionsQueryError = AxiosError<void>

/**
 * @summary retrieve all quesitons for a category
 */
export const useRetrieveAllFaqCategoryQuestions = <TData = Awaited<ReturnType<typeof retrieveAllFaqCategoryQuestions>>, TError = AxiosError<void>>(
 categoryId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveAllFaqCategoryQuestions>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveAllFaqCategoryQuestionsQueryOptions(categoryId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary add a faq question
 */
export const addFaqQuestion = (
    categoryId: number,
    faqQuestionModelUpdateV1: FaqQuestionModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/faq/${categoryId}/questions`,
      faqQuestionModelUpdateV1,options
    );
  }



export const getAddFaqQuestionMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addFaqQuestion>>, TError,{categoryId: number;data: FaqQuestionModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addFaqQuestion>>, TError,{categoryId: number;data: FaqQuestionModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addFaqQuestion>>, {categoryId: number;data: FaqQuestionModelUpdateV1}> = (props) => {
          const {categoryId,data} = props ?? {};

          return  addFaqQuestion(categoryId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddFaqQuestionMutationResult = NonNullable<Awaited<ReturnType<typeof addFaqQuestion>>>
    export type AddFaqQuestionMutationBody = FaqQuestionModelUpdateV1
    export type AddFaqQuestionMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary add a faq question
 */
export const useAddFaqQuestion = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addFaqQuestion>>, TError,{categoryId: number;data: FaqQuestionModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof addFaqQuestion>>,
        TError,
        {categoryId: number;data: FaqQuestionModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getAddFaqQuestionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary get a specific question for a category
 */
export const retrieveFaqQuestion = (
    categoryId: number,
    questionId: number,
    params?: RetrieveFaqQuestionParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<FaqQuestionModelV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/faq/${categoryId}/questions/${questionId}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getRetrieveFaqQuestionQueryKey = (categoryId: number,
    questionId: number,
    params?: RetrieveFaqQuestionParams,) => {
    return [`https://api.mangaupdates.com/v1/faq/${categoryId}/questions/${questionId}`, ...(params ? [params]: [])] as const;
    }

    
export const getRetrieveFaqQuestionInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveFaqQuestion>>>, TError = AxiosError<void>>(categoryId: number,
    questionId: number,
    params?: RetrieveFaqQuestionParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveFaqQuestion>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveFaqQuestionQueryKey(categoryId,questionId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveFaqQuestion>>> = ({ signal }) => retrieveFaqQuestion(categoryId,questionId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId && questionId),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveFaqQuestion>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveFaqQuestionInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveFaqQuestion>>>
export type RetrieveFaqQuestionInfiniteQueryError = AxiosError<void>

/**
 * @summary get a specific question for a category
 */
export const useRetrieveFaqQuestionInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveFaqQuestion>>>, TError = AxiosError<void>>(
 categoryId: number,
    questionId: number,
    params?: RetrieveFaqQuestionParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveFaqQuestion>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveFaqQuestionInfiniteQueryOptions(categoryId,questionId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveFaqQuestionQueryOptions = <TData = Awaited<ReturnType<typeof retrieveFaqQuestion>>, TError = AxiosError<void>>(categoryId: number,
    questionId: number,
    params?: RetrieveFaqQuestionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveFaqQuestion>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveFaqQuestionQueryKey(categoryId,questionId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveFaqQuestion>>> = ({ signal }) => retrieveFaqQuestion(categoryId,questionId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId && questionId),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveFaqQuestion>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveFaqQuestionQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveFaqQuestion>>>
export type RetrieveFaqQuestionQueryError = AxiosError<void>

/**
 * @summary get a specific question for a category
 */
export const useRetrieveFaqQuestion = <TData = Awaited<ReturnType<typeof retrieveFaqQuestion>>, TError = AxiosError<void>>(
 categoryId: number,
    questionId: number,
    params?: RetrieveFaqQuestionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveFaqQuestion>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveFaqQuestionQueryOptions(categoryId,questionId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary delete an faq
 */
export const deleteFaqQuestion = (
    categoryId: number,
    questionId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.delete(
      `https://api.mangaupdates.com/v1/faq/${categoryId}/questions/${questionId}`,options
    );
  }



export const getDeleteFaqQuestionMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteFaqQuestion>>, TError,{categoryId: number;questionId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteFaqQuestion>>, TError,{categoryId: number;questionId: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteFaqQuestion>>, {categoryId: number;questionId: number}> = (props) => {
          const {categoryId,questionId} = props ?? {};

          return  deleteFaqQuestion(categoryId,questionId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteFaqQuestionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteFaqQuestion>>>
    
    export type DeleteFaqQuestionMutationError = AxiosError<void>

    /**
 * @summary delete an faq
 */
export const useDeleteFaqQuestion = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteFaqQuestion>>, TError,{categoryId: number;questionId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteFaqQuestion>>,
        TError,
        {categoryId: number;questionId: number},
        TContext
      > => {

      const mutationOptions = getDeleteFaqQuestionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary update a faq question
 */
export const updateFaqQuestion = (
    categoryId: number,
    questionId: number,
    faqQuestionModelUpdateV1: FaqQuestionModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.patch(
      `https://api.mangaupdates.com/v1/faq/${categoryId}/questions/${questionId}`,
      faqQuestionModelUpdateV1,options
    );
  }



export const getUpdateFaqQuestionMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateFaqQuestion>>, TError,{categoryId: number;questionId: number;data: FaqQuestionModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateFaqQuestion>>, TError,{categoryId: number;questionId: number;data: FaqQuestionModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateFaqQuestion>>, {categoryId: number;questionId: number;data: FaqQuestionModelUpdateV1}> = (props) => {
          const {categoryId,questionId,data} = props ?? {};

          return  updateFaqQuestion(categoryId,questionId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateFaqQuestionMutationResult = NonNullable<Awaited<ReturnType<typeof updateFaqQuestion>>>
    export type UpdateFaqQuestionMutationBody = FaqQuestionModelUpdateV1
    export type UpdateFaqQuestionMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary update a faq question
 */
export const useUpdateFaqQuestion = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateFaqQuestion>>, TError,{categoryId: number;questionId: number;data: FaqQuestionModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof updateFaqQuestion>>,
        TError,
        {categoryId: number;questionId: number;data: FaqQuestionModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getUpdateFaqQuestionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary reorder faq
 */
export const reorderFaq = (
    faqCategoryReorderModelV1: FaqCategoryReorderModelV1[], options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/faq/reorder`,
      faqCategoryReorderModelV1,options
    );
  }



export const getReorderFaqMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof reorderFaq>>, TError,{data: FaqCategoryReorderModelV1[]}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof reorderFaq>>, TError,{data: FaqCategoryReorderModelV1[]}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof reorderFaq>>, {data: FaqCategoryReorderModelV1[]}> = (props) => {
          const {data} = props ?? {};

          return  reorderFaq(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ReorderFaqMutationResult = NonNullable<Awaited<ReturnType<typeof reorderFaq>>>
    export type ReorderFaqMutationBody = FaqCategoryReorderModelV1[]
    export type ReorderFaqMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary reorder faq
 */
export const useReorderFaq = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof reorderFaq>>, TError,{data: FaqCategoryReorderModelV1[]}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof reorderFaq>>,
        TError,
        {data: FaqCategoryReorderModelV1[]},
        TContext
      > => {

      const mutationOptions = getReorderFaqMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary add a forum admin
 */
export const addForumAdmin = (
    forumId: number,
    userId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.put(
      `https://api.mangaupdates.com/v1/forums/${forumId}/admins/${userId}`,undefined,options
    );
  }



export const getAddForumAdminMutationOptions = <TError = AxiosError<void | ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addForumAdmin>>, TError,{forumId: number;userId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addForumAdmin>>, TError,{forumId: number;userId: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addForumAdmin>>, {forumId: number;userId: number}> = (props) => {
          const {forumId,userId} = props ?? {};

          return  addForumAdmin(forumId,userId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddForumAdminMutationResult = NonNullable<Awaited<ReturnType<typeof addForumAdmin>>>
    
    export type AddForumAdminMutationError = AxiosError<void | ApiResponseV1>

    /**
 * @summary add a forum admin
 */
export const useAddForumAdmin = <TError = AxiosError<void | ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addForumAdmin>>, TError,{forumId: number;userId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof addForumAdmin>>,
        TError,
        {forumId: number;userId: number},
        TContext
      > => {

      const mutationOptions = getAddForumAdminMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary remove a forum admin
 */
export const removeForumAdmin = (
    forumId: number,
    userId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.delete(
      `https://api.mangaupdates.com/v1/forums/${forumId}/admins/${userId}`,options
    );
  }



export const getRemoveForumAdminMutationOptions = <TError = AxiosError<void | ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeForumAdmin>>, TError,{forumId: number;userId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof removeForumAdmin>>, TError,{forumId: number;userId: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeForumAdmin>>, {forumId: number;userId: number}> = (props) => {
          const {forumId,userId} = props ?? {};

          return  removeForumAdmin(forumId,userId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveForumAdminMutationResult = NonNullable<Awaited<ReturnType<typeof removeForumAdmin>>>
    
    export type RemoveForumAdminMutationError = AxiosError<void | ApiResponseV1>

    /**
 * @summary remove a forum admin
 */
export const useRemoveForumAdmin = <TError = AxiosError<void | ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeForumAdmin>>, TError,{forumId: number;userId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof removeForumAdmin>>,
        TError,
        {forumId: number;userId: number},
        TContext
      > => {

      const mutationOptions = getRemoveForumAdminMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary retrieve a forum
 */
export const retrieveForum = (
    forumId: number,
    params?: RetrieveForumParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ForumForumModelV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/forums/${forumId}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getRetrieveForumQueryKey = (forumId: number,
    params?: RetrieveForumParams,) => {
    return [`https://api.mangaupdates.com/v1/forums/${forumId}`, ...(params ? [params]: [])] as const;
    }

    
export const getRetrieveForumInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveForum>>>, TError = AxiosError<void>>(forumId: number,
    params?: RetrieveForumParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveForum>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveForumQueryKey(forumId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveForum>>> = ({ signal }) => retrieveForum(forumId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(forumId),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveForum>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveForumInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveForum>>>
export type RetrieveForumInfiniteQueryError = AxiosError<void>

/**
 * @summary retrieve a forum
 */
export const useRetrieveForumInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveForum>>>, TError = AxiosError<void>>(
 forumId: number,
    params?: RetrieveForumParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveForum>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveForumInfiniteQueryOptions(forumId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveForumQueryOptions = <TData = Awaited<ReturnType<typeof retrieveForum>>, TError = AxiosError<void>>(forumId: number,
    params?: RetrieveForumParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveForum>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveForumQueryKey(forumId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveForum>>> = ({ signal }) => retrieveForum(forumId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(forumId),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveForum>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveForumQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveForum>>>
export type RetrieveForumQueryError = AxiosError<void>

/**
 * @summary retrieve a forum
 */
export const useRetrieveForum = <TData = Awaited<ReturnType<typeof retrieveForum>>, TError = AxiosError<void>>(
 forumId: number,
    params?: RetrieveForumParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveForum>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveForumQueryOptions(forumId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary add a forum topic
 */
export const addTopic = (
    forumId: number,
    forumTopicModelAddV1: ForumTopicModelAddV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/forums/${forumId}`,
      forumTopicModelAddV1,options
    );
  }



export const getAddTopicMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addTopic>>, TError,{forumId: number;data: ForumTopicModelAddV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addTopic>>, TError,{forumId: number;data: ForumTopicModelAddV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addTopic>>, {forumId: number;data: ForumTopicModelAddV1}> = (props) => {
          const {forumId,data} = props ?? {};

          return  addTopic(forumId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddTopicMutationResult = NonNullable<Awaited<ReturnType<typeof addTopic>>>
    export type AddTopicMutationBody = ForumTopicModelAddV1
    export type AddTopicMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary add a forum topic
 */
export const useAddTopic = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addTopic>>, TError,{forumId: number;data: ForumTopicModelAddV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof addTopic>>,
        TError,
        {forumId: number;data: ForumTopicModelAddV1},
        TContext
      > => {

      const mutationOptions = getAddTopicMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary show forum admin log
 */
export const showLogPost = (
    forumAdminHistorySearchRequestV1: ForumAdminHistorySearchRequestV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ForumAdminHistorySearchResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/forums/log`,
      forumAdminHistorySearchRequestV1,options
    );
  }



export const getShowLogPostMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof showLogPost>>, TError,{data: ForumAdminHistorySearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof showLogPost>>, TError,{data: ForumAdminHistorySearchRequestV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof showLogPost>>, {data: ForumAdminHistorySearchRequestV1}> = (props) => {
          const {data} = props ?? {};

          return  showLogPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ShowLogPostMutationResult = NonNullable<Awaited<ReturnType<typeof showLogPost>>>
    export type ShowLogPostMutationBody = ForumAdminHistorySearchRequestV1
    export type ShowLogPostMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary show forum admin log
 */
export const useShowLogPost = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof showLogPost>>, TError,{data: ForumAdminHistorySearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof showLogPost>>,
        TError,
        {data: ForumAdminHistorySearchRequestV1},
        TContext
      > => {

      const mutationOptions = getShowLogPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary show forum categories and forums
 */
export const listCategories = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ForumCategoryModelListV1[]>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/forums`,options
    );
  }


export const getListCategoriesQueryKey = () => {
    return [`https://api.mangaupdates.com/v1/forums`] as const;
    }

    
export const getListCategoriesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof listCategories>>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof listCategories>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListCategoriesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listCategories>>> = ({ signal }) => listCategories({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof listCategories>>, TError, TData> & { queryKey: QueryKey }
}

export type ListCategoriesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof listCategories>>>
export type ListCategoriesInfiniteQueryError = AxiosError<unknown>

/**
 * @summary show forum categories and forums
 */
export const useListCategoriesInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof listCategories>>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof listCategories>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getListCategoriesInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getListCategoriesQueryOptions = <TData = Awaited<ReturnType<typeof listCategories>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listCategories>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListCategoriesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listCategories>>> = ({ signal }) => listCategories({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listCategories>>, TError, TData> & { queryKey: QueryKey }
}

export type ListCategoriesQueryResult = NonNullable<Awaited<ReturnType<typeof listCategories>>>
export type ListCategoriesQueryError = AxiosError<unknown>

/**
 * @summary show forum categories and forums
 */
export const useListCategories = <TData = Awaited<ReturnType<typeof listCategories>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listCategories>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getListCategoriesQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary show popular forums
 */
export const listPopularForums = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ForumForumModelListV1[]>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/forums/popular`,options
    );
  }


export const getListPopularForumsQueryKey = () => {
    return [`https://api.mangaupdates.com/v1/forums/popular`] as const;
    }

    
export const getListPopularForumsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof listPopularForums>>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof listPopularForums>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPopularForumsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPopularForums>>> = ({ signal }) => listPopularForums({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof listPopularForums>>, TError, TData> & { queryKey: QueryKey }
}

export type ListPopularForumsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof listPopularForums>>>
export type ListPopularForumsInfiniteQueryError = AxiosError<unknown>

/**
 * @summary show popular forums
 */
export const useListPopularForumsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof listPopularForums>>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof listPopularForums>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getListPopularForumsInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getListPopularForumsQueryOptions = <TData = Awaited<ReturnType<typeof listPopularForums>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPopularForums>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPopularForumsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPopularForums>>> = ({ signal }) => listPopularForums({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPopularForums>>, TError, TData> & { queryKey: QueryKey }
}

export type ListPopularForumsQueryResult = NonNullable<Awaited<ReturnType<typeof listPopularForums>>>
export type ListPopularForumsQueryError = AxiosError<unknown>

/**
 * @summary show popular forums
 */
export const useListPopularForums = <TData = Awaited<ReturnType<typeof listPopularForums>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPopularForums>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getListPopularForumsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary list posts in topic that I made
 */
export const listPostsByMe = (
    forumId: number,
    topicId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ForumPostByUserResponseV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/forums/${forumId}/topics/${topicId}/my_posts`,options
    );
  }


export const getListPostsByMeQueryKey = (forumId: number,
    topicId: number,) => {
    return [`https://api.mangaupdates.com/v1/forums/${forumId}/topics/${topicId}/my_posts`] as const;
    }

    
export const getListPostsByMeInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof listPostsByMe>>>, TError = AxiosError<void>>(forumId: number,
    topicId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof listPostsByMe>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPostsByMeQueryKey(forumId,topicId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPostsByMe>>> = ({ signal }) => listPostsByMe(forumId,topicId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(forumId && topicId),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof listPostsByMe>>, TError, TData> & { queryKey: QueryKey }
}

export type ListPostsByMeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof listPostsByMe>>>
export type ListPostsByMeInfiniteQueryError = AxiosError<void>

/**
 * @summary list posts in topic that I made
 */
export const useListPostsByMeInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof listPostsByMe>>>, TError = AxiosError<void>>(
 forumId: number,
    topicId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof listPostsByMe>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getListPostsByMeInfiniteQueryOptions(forumId,topicId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getListPostsByMeQueryOptions = <TData = Awaited<ReturnType<typeof listPostsByMe>>, TError = AxiosError<void>>(forumId: number,
    topicId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPostsByMe>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPostsByMeQueryKey(forumId,topicId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPostsByMe>>> = ({ signal }) => listPostsByMe(forumId,topicId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(forumId && topicId),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPostsByMe>>, TError, TData> & { queryKey: QueryKey }
}

export type ListPostsByMeQueryResult = NonNullable<Awaited<ReturnType<typeof listPostsByMe>>>
export type ListPostsByMeQueryError = AxiosError<void>

/**
 * @summary list posts in topic that I made
 */
export const useListPostsByMe = <TData = Awaited<ReturnType<typeof listPostsByMe>>, TError = AxiosError<void>>(
 forumId: number,
    topicId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPostsByMe>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getListPostsByMeQueryOptions(forumId,topicId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary list posts in topic
 */
export const listPosts = (
    forumId: number,
    topicId: number,
    perPageSearchRequestV1: PerPageSearchRequestV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ForumPostListResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/forums/${forumId}/topics/${topicId}/list`,
      perPageSearchRequestV1,options
    );
  }



export const getListPostsMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof listPosts>>, TError,{forumId: number;topicId: number;data: PerPageSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof listPosts>>, TError,{forumId: number;topicId: number;data: PerPageSearchRequestV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof listPosts>>, {forumId: number;topicId: number;data: PerPageSearchRequestV1}> = (props) => {
          const {forumId,topicId,data} = props ?? {};

          return  listPosts(forumId,topicId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ListPostsMutationResult = NonNullable<Awaited<ReturnType<typeof listPosts>>>
    export type ListPostsMutationBody = PerPageSearchRequestV1
    export type ListPostsMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary list posts in topic
 */
export const useListPosts = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof listPosts>>, TError,{forumId: number;topicId: number;data: PerPageSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof listPosts>>,
        TError,
        {forumId: number;topicId: number;data: PerPageSearchRequestV1},
        TContext
      > => {

      const mutationOptions = getListPostsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary list topics
 */
export const listTopics = (
    forumId: number,
    forumTopicListRequestV1: ForumTopicListRequestV1,
    params?: ListTopicsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ForumTopicListResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/forums/${forumId}/list`,
      forumTopicListRequestV1,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getListTopicsMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof listTopics>>, TError,{forumId: number;data: ForumTopicListRequestV1;params?: ListTopicsParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof listTopics>>, TError,{forumId: number;data: ForumTopicListRequestV1;params?: ListTopicsParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof listTopics>>, {forumId: number;data: ForumTopicListRequestV1;params?: ListTopicsParams}> = (props) => {
          const {forumId,data,params} = props ?? {};

          return  listTopics(forumId,data,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ListTopicsMutationResult = NonNullable<Awaited<ReturnType<typeof listTopics>>>
    export type ListTopicsMutationBody = ForumTopicListRequestV1
    export type ListTopicsMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary list topics
 */
export const useListTopics = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof listTopics>>, TError,{forumId: number;data: ForumTopicListRequestV1;params?: ListTopicsParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof listTopics>>,
        TError,
        {forumId: number;data: ForumTopicListRequestV1;params?: ListTopicsParams},
        TContext
      > => {

      const mutationOptions = getListTopicsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary list global topics
 */
export const listGlobalTopics = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ForumTopicListResponseV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/forums/global`,options
    );
  }


export const getListGlobalTopicsQueryKey = () => {
    return [`https://api.mangaupdates.com/v1/forums/global`] as const;
    }

    
export const getListGlobalTopicsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof listGlobalTopics>>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof listGlobalTopics>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListGlobalTopicsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listGlobalTopics>>> = ({ signal }) => listGlobalTopics({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof listGlobalTopics>>, TError, TData> & { queryKey: QueryKey }
}

export type ListGlobalTopicsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof listGlobalTopics>>>
export type ListGlobalTopicsInfiniteQueryError = AxiosError<unknown>

/**
 * @summary list global topics
 */
export const useListGlobalTopicsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof listGlobalTopics>>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof listGlobalTopics>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getListGlobalTopicsInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getListGlobalTopicsQueryOptions = <TData = Awaited<ReturnType<typeof listGlobalTopics>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listGlobalTopics>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListGlobalTopicsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listGlobalTopics>>> = ({ signal }) => listGlobalTopics({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listGlobalTopics>>, TError, TData> & { queryKey: QueryKey }
}

export type ListGlobalTopicsQueryResult = NonNullable<Awaited<ReturnType<typeof listGlobalTopics>>>
export type ListGlobalTopicsQueryError = AxiosError<unknown>

/**
 * @summary list global topics
 */
export const useListGlobalTopics = <TData = Awaited<ReturnType<typeof listGlobalTopics>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listGlobalTopics>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getListGlobalTopicsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary lookup a series to find the forum id
 */
export const lookupSeries = (
    seriesId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ForumLookupResponseV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/forums/lookup/series/${seriesId}`,options
    );
  }


export const getLookupSeriesQueryKey = (seriesId: number,) => {
    return [`https://api.mangaupdates.com/v1/forums/lookup/series/${seriesId}`] as const;
    }

    
export const getLookupSeriesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof lookupSeries>>>, TError = AxiosError<void>>(seriesId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof lookupSeries>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getLookupSeriesQueryKey(seriesId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof lookupSeries>>> = ({ signal }) => lookupSeries(seriesId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(seriesId),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof lookupSeries>>, TError, TData> & { queryKey: QueryKey }
}

export type LookupSeriesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof lookupSeries>>>
export type LookupSeriesInfiniteQueryError = AxiosError<void>

/**
 * @summary lookup a series to find the forum id
 */
export const useLookupSeriesInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof lookupSeries>>>, TError = AxiosError<void>>(
 seriesId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof lookupSeries>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getLookupSeriesInfiniteQueryOptions(seriesId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getLookupSeriesQueryOptions = <TData = Awaited<ReturnType<typeof lookupSeries>>, TError = AxiosError<void>>(seriesId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lookupSeries>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getLookupSeriesQueryKey(seriesId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof lookupSeries>>> = ({ signal }) => lookupSeries(seriesId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(seriesId),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof lookupSeries>>, TError, TData> & { queryKey: QueryKey }
}

export type LookupSeriesQueryResult = NonNullable<Awaited<ReturnType<typeof lookupSeries>>>
export type LookupSeriesQueryError = AxiosError<void>

/**
 * @summary lookup a series to find the forum id
 */
export const useLookupSeries = <TData = Awaited<ReturnType<typeof lookupSeries>>, TError = AxiosError<void>>(
 seriesId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lookupSeries>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getLookupSeriesQueryOptions(seriesId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary lookup a topic to find the forum id
 */
export const lookupTopic = (
    topicId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ForumLookupResponseV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/forums/lookup/topic/${topicId}`,options
    );
  }


export const getLookupTopicQueryKey = (topicId: number,) => {
    return [`https://api.mangaupdates.com/v1/forums/lookup/topic/${topicId}`] as const;
    }

    
export const getLookupTopicInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof lookupTopic>>>, TError = AxiosError<void>>(topicId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof lookupTopic>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getLookupTopicQueryKey(topicId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof lookupTopic>>> = ({ signal }) => lookupTopic(topicId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(topicId),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof lookupTopic>>, TError, TData> & { queryKey: QueryKey }
}

export type LookupTopicInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof lookupTopic>>>
export type LookupTopicInfiniteQueryError = AxiosError<void>

/**
 * @summary lookup a topic to find the forum id
 */
export const useLookupTopicInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof lookupTopic>>>, TError = AxiosError<void>>(
 topicId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof lookupTopic>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getLookupTopicInfiniteQueryOptions(topicId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getLookupTopicQueryOptions = <TData = Awaited<ReturnType<typeof lookupTopic>>, TError = AxiosError<void>>(topicId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lookupTopic>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getLookupTopicQueryKey(topicId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof lookupTopic>>> = ({ signal }) => lookupTopic(topicId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(topicId),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof lookupTopic>>, TError, TData> & { queryKey: QueryKey }
}

export type LookupTopicQueryResult = NonNullable<Awaited<ReturnType<typeof lookupTopic>>>
export type LookupTopicQueryError = AxiosError<void>

/**
 * @summary lookup a topic to find the forum id
 */
export const useLookupTopic = <TData = Awaited<ReturnType<typeof lookupTopic>>, TError = AxiosError<void>>(
 topicId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lookupTopic>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getLookupTopicQueryOptions(topicId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary lookup a post to find the forum and topic id
 */
export const lookupPost = (
    postId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ForumLookupResponseV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/forums/lookup/post/${postId}`,options
    );
  }


export const getLookupPostQueryKey = (postId: number,) => {
    return [`https://api.mangaupdates.com/v1/forums/lookup/post/${postId}`] as const;
    }

    
export const getLookupPostInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof lookupPost>>>, TError = AxiosError<void>>(postId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof lookupPost>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getLookupPostQueryKey(postId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof lookupPost>>> = ({ signal }) => lookupPost(postId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(postId),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof lookupPost>>, TError, TData> & { queryKey: QueryKey }
}

export type LookupPostInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof lookupPost>>>
export type LookupPostInfiniteQueryError = AxiosError<void>

/**
 * @summary lookup a post to find the forum and topic id
 */
export const useLookupPostInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof lookupPost>>>, TError = AxiosError<void>>(
 postId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof lookupPost>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getLookupPostInfiniteQueryOptions(postId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getLookupPostQueryOptions = <TData = Awaited<ReturnType<typeof lookupPost>>, TError = AxiosError<void>>(postId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lookupPost>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getLookupPostQueryKey(postId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof lookupPost>>> = ({ signal }) => lookupPost(postId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(postId),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof lookupPost>>, TError, TData> & { queryKey: QueryKey }
}

export type LookupPostQueryResult = NonNullable<Awaited<ReturnType<typeof lookupPost>>>
export type LookupPostQueryError = AxiosError<void>

/**
 * @summary lookup a post to find the forum and topic id
 */
export const useLookupPost = <TData = Awaited<ReturnType<typeof lookupPost>>, TError = AxiosError<void>>(
 postId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lookupPost>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getLookupPostQueryOptions(postId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary retrieve temporary poll images
 */
export const retrieveTemporaryPollImages = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ForumPollTempImageModelV1[]>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/forums/temp_poll_images`,options
    );
  }


export const getRetrieveTemporaryPollImagesQueryKey = () => {
    return [`https://api.mangaupdates.com/v1/forums/temp_poll_images`] as const;
    }

    
export const getRetrieveTemporaryPollImagesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveTemporaryPollImages>>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveTemporaryPollImages>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveTemporaryPollImagesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveTemporaryPollImages>>> = ({ signal }) => retrieveTemporaryPollImages({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveTemporaryPollImages>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveTemporaryPollImagesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveTemporaryPollImages>>>
export type RetrieveTemporaryPollImagesInfiniteQueryError = AxiosError<unknown>

/**
 * @summary retrieve temporary poll images
 */
export const useRetrieveTemporaryPollImagesInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveTemporaryPollImages>>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveTemporaryPollImages>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveTemporaryPollImagesInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveTemporaryPollImagesQueryOptions = <TData = Awaited<ReturnType<typeof retrieveTemporaryPollImages>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveTemporaryPollImages>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveTemporaryPollImagesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveTemporaryPollImages>>> = ({ signal }) => retrieveTemporaryPollImages({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveTemporaryPollImages>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveTemporaryPollImagesQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveTemporaryPollImages>>>
export type RetrieveTemporaryPollImagesQueryError = AxiosError<unknown>

/**
 * @summary retrieve temporary poll images
 */
export const useRetrieveTemporaryPollImages = <TData = Awaited<ReturnType<typeof retrieveTemporaryPollImages>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveTemporaryPollImages>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveTemporaryPollImagesQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary add a temporary poll image
 */
export const addTemporaryPollImage = (
    addTemporaryPollImageBody: AddTemporaryPollImageBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {const formData = new FormData();
if(addTemporaryPollImageBody.image !== undefined) {
 formData.append('image', addTemporaryPollImageBody.image)
 }
if(addTemporaryPollImageBody.caption !== undefined) {
 formData.append('caption', addTemporaryPollImageBody.caption)
 }

    
    return axios.post(
      `https://api.mangaupdates.com/v1/forums/temp_poll_images`,
      formData,options
    );
  }



export const getAddTemporaryPollImageMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addTemporaryPollImage>>, TError,{data: AddTemporaryPollImageBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addTemporaryPollImage>>, TError,{data: AddTemporaryPollImageBody}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addTemporaryPollImage>>, {data: AddTemporaryPollImageBody}> = (props) => {
          const {data} = props ?? {};

          return  addTemporaryPollImage(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddTemporaryPollImageMutationResult = NonNullable<Awaited<ReturnType<typeof addTemporaryPollImage>>>
    export type AddTemporaryPollImageMutationBody = AddTemporaryPollImageBody
    export type AddTemporaryPollImageMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary add a temporary poll image
 */
export const useAddTemporaryPollImage = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addTemporaryPollImage>>, TError,{data: AddTemporaryPollImageBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof addTemporaryPollImage>>,
        TError,
        {data: AddTemporaryPollImageBody},
        TContext
      > => {

      const mutationOptions = getAddTemporaryPollImageMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary update a forum topic poll (if present)
 */
export const updateTopicPoll = (
    forumId: number,
    topicId: number,
    forumPollModelUpdateV1: ForumPollModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.patch(
      `https://api.mangaupdates.com/v1/forums/${forumId}/topics/${topicId}/poll`,
      forumPollModelUpdateV1,options
    );
  }



export const getUpdateTopicPollMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTopicPoll>>, TError,{forumId: number;topicId: number;data: ForumPollModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateTopicPoll>>, TError,{forumId: number;topicId: number;data: ForumPollModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateTopicPoll>>, {forumId: number;topicId: number;data: ForumPollModelUpdateV1}> = (props) => {
          const {forumId,topicId,data} = props ?? {};

          return  updateTopicPoll(forumId,topicId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateTopicPollMutationResult = NonNullable<Awaited<ReturnType<typeof updateTopicPoll>>>
    export type UpdateTopicPollMutationBody = ForumPollModelUpdateV1
    export type UpdateTopicPollMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary update a forum topic poll (if present)
 */
export const useUpdateTopicPoll = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTopicPoll>>, TError,{forumId: number;topicId: number;data: ForumPollModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof updateTopicPoll>>,
        TError,
        {forumId: number;topicId: number;data: ForumPollModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getUpdateTopicPollMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary add a vote to a forum poll
 */
export const addPollVote = (
    forumId: number,
    topicId: number,
    choiceId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/forums/${forumId}/topics/${topicId}/poll/vote/${choiceId}`,undefined,options
    );
  }



export const getAddPollVoteMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addPollVote>>, TError,{forumId: number;topicId: number;choiceId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addPollVote>>, TError,{forumId: number;topicId: number;choiceId: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addPollVote>>, {forumId: number;topicId: number;choiceId: number}> = (props) => {
          const {forumId,topicId,choiceId} = props ?? {};

          return  addPollVote(forumId,topicId,choiceId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddPollVoteMutationResult = NonNullable<Awaited<ReturnType<typeof addPollVote>>>
    
    export type AddPollVoteMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary add a vote to a forum poll
 */
export const useAddPollVote = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addPollVote>>, TError,{forumId: number;topicId: number;choiceId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof addPollVote>>,
        TError,
        {forumId: number;topicId: number;choiceId: number},
        TContext
      > => {

      const mutationOptions = getAddPollVoteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary retrieve my vote from the poll
 */
export const retrieveVote = (
    forumId: number,
    topicId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ForumPollVoteModelV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/forums/${forumId}/topics/${topicId}/poll/vote`,options
    );
  }


export const getRetrieveVoteQueryKey = (forumId: number,
    topicId: number,) => {
    return [`https://api.mangaupdates.com/v1/forums/${forumId}/topics/${topicId}/poll/vote`] as const;
    }

    
export const getRetrieveVoteInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveVote>>>, TError = AxiosError<ApiResponseV1 | void>>(forumId: number,
    topicId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveVote>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveVoteQueryKey(forumId,topicId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveVote>>> = ({ signal }) => retrieveVote(forumId,topicId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(forumId && topicId),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveVote>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveVoteInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveVote>>>
export type RetrieveVoteInfiniteQueryError = AxiosError<ApiResponseV1 | void>

/**
 * @summary retrieve my vote from the poll
 */
export const useRetrieveVoteInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveVote>>>, TError = AxiosError<ApiResponseV1 | void>>(
 forumId: number,
    topicId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveVote>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveVoteInfiniteQueryOptions(forumId,topicId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveVoteQueryOptions = <TData = Awaited<ReturnType<typeof retrieveVote>>, TError = AxiosError<ApiResponseV1 | void>>(forumId: number,
    topicId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveVote>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveVoteQueryKey(forumId,topicId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveVote>>> = ({ signal }) => retrieveVote(forumId,topicId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(forumId && topicId),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveVote>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveVoteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveVote>>>
export type RetrieveVoteQueryError = AxiosError<ApiResponseV1 | void>

/**
 * @summary retrieve my vote from the poll
 */
export const useRetrieveVote = <TData = Awaited<ReturnType<typeof retrieveVote>>, TError = AxiosError<ApiResponseV1 | void>>(
 forumId: number,
    topicId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveVote>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveVoteQueryOptions(forumId,topicId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary retrieve a forum topic
 */
export const retrieveTopic = (
    forumId: number,
    topicId: number,
    params?: RetrieveTopicParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ForumTopicModelV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/forums/${forumId}/topics/${topicId}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getRetrieveTopicQueryKey = (forumId: number,
    topicId: number,
    params?: RetrieveTopicParams,) => {
    return [`https://api.mangaupdates.com/v1/forums/${forumId}/topics/${topicId}`, ...(params ? [params]: [])] as const;
    }

    
export const getRetrieveTopicInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveTopic>>>, TError = AxiosError<void>>(forumId: number,
    topicId: number,
    params?: RetrieveTopicParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveTopic>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveTopicQueryKey(forumId,topicId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveTopic>>> = ({ signal }) => retrieveTopic(forumId,topicId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(forumId && topicId),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveTopic>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveTopicInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveTopic>>>
export type RetrieveTopicInfiniteQueryError = AxiosError<void>

/**
 * @summary retrieve a forum topic
 */
export const useRetrieveTopicInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveTopic>>>, TError = AxiosError<void>>(
 forumId: number,
    topicId: number,
    params?: RetrieveTopicParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveTopic>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveTopicInfiniteQueryOptions(forumId,topicId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveTopicQueryOptions = <TData = Awaited<ReturnType<typeof retrieveTopic>>, TError = AxiosError<void>>(forumId: number,
    topicId: number,
    params?: RetrieveTopicParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveTopic>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveTopicQueryKey(forumId,topicId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveTopic>>> = ({ signal }) => retrieveTopic(forumId,topicId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(forumId && topicId),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveTopic>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveTopicQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveTopic>>>
export type RetrieveTopicQueryError = AxiosError<void>

/**
 * @summary retrieve a forum topic
 */
export const useRetrieveTopic = <TData = Awaited<ReturnType<typeof retrieveTopic>>, TError = AxiosError<void>>(
 forumId: number,
    topicId: number,
    params?: RetrieveTopicParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveTopic>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveTopicQueryOptions(forumId,topicId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary add a forum post
 */
export const addPost = (
    forumId: number,
    topicId: number,
    forumPostModelUpdateV1: ForumPostModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/forums/${forumId}/topics/${topicId}`,
      forumPostModelUpdateV1,options
    );
  }



export const getAddPostMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addPost>>, TError,{forumId: number;topicId: number;data: ForumPostModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addPost>>, TError,{forumId: number;topicId: number;data: ForumPostModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addPost>>, {forumId: number;topicId: number;data: ForumPostModelUpdateV1}> = (props) => {
          const {forumId,topicId,data} = props ?? {};

          return  addPost(forumId,topicId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddPostMutationResult = NonNullable<Awaited<ReturnType<typeof addPost>>>
    export type AddPostMutationBody = ForumPostModelUpdateV1
    export type AddPostMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary add a forum post
 */
export const useAddPost = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addPost>>, TError,{forumId: number;topicId: number;data: ForumPostModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof addPost>>,
        TError,
        {forumId: number;topicId: number;data: ForumPostModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getAddPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary delete a topic
 */
export const deleteTopic = (
    forumId: number,
    topicId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.delete(
      `https://api.mangaupdates.com/v1/forums/${forumId}/topics/${topicId}`,options
    );
  }



export const getDeleteTopicMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTopic>>, TError,{forumId: number;topicId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteTopic>>, TError,{forumId: number;topicId: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTopic>>, {forumId: number;topicId: number}> = (props) => {
          const {forumId,topicId} = props ?? {};

          return  deleteTopic(forumId,topicId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteTopicMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTopic>>>
    
    export type DeleteTopicMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary delete a topic
 */
export const useDeleteTopic = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTopic>>, TError,{forumId: number;topicId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteTopic>>,
        TError,
        {forumId: number;topicId: number},
        TContext
      > => {

      const mutationOptions = getDeleteTopicMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary update a forum topic
 */
export const updateTopic = (
    forumId: number,
    topicId: number,
    forumTopicModelUpdateV1: ForumTopicModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.patch(
      `https://api.mangaupdates.com/v1/forums/${forumId}/topics/${topicId}`,
      forumTopicModelUpdateV1,options
    );
  }



export const getUpdateTopicMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTopic>>, TError,{forumId: number;topicId: number;data: ForumTopicModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateTopic>>, TError,{forumId: number;topicId: number;data: ForumTopicModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateTopic>>, {forumId: number;topicId: number;data: ForumTopicModelUpdateV1}> = (props) => {
          const {forumId,topicId,data} = props ?? {};

          return  updateTopic(forumId,topicId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateTopicMutationResult = NonNullable<Awaited<ReturnType<typeof updateTopic>>>
    export type UpdateTopicMutationBody = ForumTopicModelUpdateV1
    export type UpdateTopicMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary update a forum topic
 */
export const useUpdateTopic = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTopic>>, TError,{forumId: number;topicId: number;data: ForumTopicModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof updateTopic>>,
        TError,
        {forumId: number;topicId: number;data: ForumTopicModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getUpdateTopicMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary retrieve a forum post
 */
export const retrievePost = (
    forumId: number,
    topicId: number,
    postId: number,
    params?: RetrievePostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ForumPostModelV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/forums/${forumId}/topics/${topicId}/posts/${postId}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getRetrievePostQueryKey = (forumId: number,
    topicId: number,
    postId: number,
    params?: RetrievePostParams,) => {
    return [`https://api.mangaupdates.com/v1/forums/${forumId}/topics/${topicId}/posts/${postId}`, ...(params ? [params]: [])] as const;
    }

    
export const getRetrievePostInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrievePost>>>, TError = AxiosError<void>>(forumId: number,
    topicId: number,
    postId: number,
    params?: RetrievePostParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrievePost>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrievePostQueryKey(forumId,topicId,postId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrievePost>>> = ({ signal }) => retrievePost(forumId,topicId,postId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(forumId && topicId && postId),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrievePost>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrievePostInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrievePost>>>
export type RetrievePostInfiniteQueryError = AxiosError<void>

/**
 * @summary retrieve a forum post
 */
export const useRetrievePostInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrievePost>>>, TError = AxiosError<void>>(
 forumId: number,
    topicId: number,
    postId: number,
    params?: RetrievePostParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrievePost>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrievePostInfiniteQueryOptions(forumId,topicId,postId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrievePostQueryOptions = <TData = Awaited<ReturnType<typeof retrievePost>>, TError = AxiosError<void>>(forumId: number,
    topicId: number,
    postId: number,
    params?: RetrievePostParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrievePost>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrievePostQueryKey(forumId,topicId,postId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrievePost>>> = ({ signal }) => retrievePost(forumId,topicId,postId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(forumId && topicId && postId),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrievePost>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrievePostQueryResult = NonNullable<Awaited<ReturnType<typeof retrievePost>>>
export type RetrievePostQueryError = AxiosError<void>

/**
 * @summary retrieve a forum post
 */
export const useRetrievePost = <TData = Awaited<ReturnType<typeof retrievePost>>, TError = AxiosError<void>>(
 forumId: number,
    topicId: number,
    postId: number,
    params?: RetrievePostParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrievePost>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrievePostQueryOptions(forumId,topicId,postId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary delete a post
 */
export const deletePost = (
    forumId: number,
    topicId: number,
    postId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.delete(
      `https://api.mangaupdates.com/v1/forums/${forumId}/topics/${topicId}/posts/${postId}`,options
    );
  }



export const getDeletePostMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePost>>, TError,{forumId: number;topicId: number;postId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deletePost>>, TError,{forumId: number;topicId: number;postId: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePost>>, {forumId: number;topicId: number;postId: number}> = (props) => {
          const {forumId,topicId,postId} = props ?? {};

          return  deletePost(forumId,topicId,postId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePostMutationResult = NonNullable<Awaited<ReturnType<typeof deletePost>>>
    
    export type DeletePostMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary delete a post
 */
export const useDeletePost = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePost>>, TError,{forumId: number;topicId: number;postId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deletePost>>,
        TError,
        {forumId: number;topicId: number;postId: number},
        TContext
      > => {

      const mutationOptions = getDeletePostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary update a forum post
 */
export const updatePost = (
    forumId: number,
    topicId: number,
    postId: number,
    forumPostModelUpdateV1: ForumPostModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.patch(
      `https://api.mangaupdates.com/v1/forums/${forumId}/topics/${topicId}/posts/${postId}`,
      forumPostModelUpdateV1,options
    );
  }



export const getUpdatePostMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePost>>, TError,{forumId: number;topicId: number;postId: number;data: ForumPostModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updatePost>>, TError,{forumId: number;topicId: number;postId: number;data: ForumPostModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePost>>, {forumId: number;topicId: number;postId: number;data: ForumPostModelUpdateV1}> = (props) => {
          const {forumId,topicId,postId,data} = props ?? {};

          return  updatePost(forumId,topicId,postId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePostMutationResult = NonNullable<Awaited<ReturnType<typeof updatePost>>>
    export type UpdatePostMutationBody = ForumPostModelUpdateV1
    export type UpdatePostMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary update a forum post
 */
export const useUpdatePost = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePost>>, TError,{forumId: number;topicId: number;postId: number;data: ForumPostModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof updatePost>>,
        TError,
        {forumId: number;topicId: number;postId: number;data: ForumPostModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getUpdatePostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary report a forum post
 */
export const reportPost = (
    forumId: number,
    topicId: number,
    postId: number,
    forumPostReportModelUpdateV1: ForumPostReportModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/forums/${forumId}/topics/${topicId}/posts/${postId}/report`,
      forumPostReportModelUpdateV1,options
    );
  }



export const getReportPostMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof reportPost>>, TError,{forumId: number;topicId: number;postId: number;data: ForumPostReportModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof reportPost>>, TError,{forumId: number;topicId: number;postId: number;data: ForumPostReportModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof reportPost>>, {forumId: number;topicId: number;postId: number;data: ForumPostReportModelUpdateV1}> = (props) => {
          const {forumId,topicId,postId,data} = props ?? {};

          return  reportPost(forumId,topicId,postId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ReportPostMutationResult = NonNullable<Awaited<ReturnType<typeof reportPost>>>
    export type ReportPostMutationBody = ForumPostReportModelUpdateV1
    export type ReportPostMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary report a forum post
 */
export const useReportPost = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof reportPost>>, TError,{forumId: number;topicId: number;postId: number;data: ForumPostReportModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof reportPost>>,
        TError,
        {forumId: number;topicId: number;postId: number;data: ForumPostReportModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getReportPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary delete a post report
 */
export const deletePostReport = (
    forumId: number,
    topicId: number,
    postId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.delete(
      `https://api.mangaupdates.com/v1/forums/${forumId}/topics/${topicId}/posts/${postId}/report`,options
    );
  }



export const getDeletePostReportMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePostReport>>, TError,{forumId: number;topicId: number;postId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deletePostReport>>, TError,{forumId: number;topicId: number;postId: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePostReport>>, {forumId: number;topicId: number;postId: number}> = (props) => {
          const {forumId,topicId,postId} = props ?? {};

          return  deletePostReport(forumId,topicId,postId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePostReportMutationResult = NonNullable<Awaited<ReturnType<typeof deletePostReport>>>
    
    export type DeletePostReportMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary delete a post report
 */
export const useDeletePostReport = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePostReport>>, TError,{forumId: number;topicId: number;postId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deletePostReport>>,
        TError,
        {forumId: number;topicId: number;postId: number},
        TContext
      > => {

      const mutationOptions = getDeletePostReportMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary show reported posts
 */
export const listReportedPosts = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ForumPostReportModelV1[]>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/forums/report`,options
    );
  }


export const getListReportedPostsQueryKey = () => {
    return [`https://api.mangaupdates.com/v1/forums/report`] as const;
    }

    
export const getListReportedPostsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof listReportedPosts>>>, TError = AxiosError<void>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof listReportedPosts>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListReportedPostsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listReportedPosts>>> = ({ signal }) => listReportedPosts({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof listReportedPosts>>, TError, TData> & { queryKey: QueryKey }
}

export type ListReportedPostsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof listReportedPosts>>>
export type ListReportedPostsInfiniteQueryError = AxiosError<void>

/**
 * @summary show reported posts
 */
export const useListReportedPostsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof listReportedPosts>>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof listReportedPosts>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getListReportedPostsInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getListReportedPostsQueryOptions = <TData = Awaited<ReturnType<typeof listReportedPosts>>, TError = AxiosError<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listReportedPosts>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListReportedPostsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listReportedPosts>>> = ({ signal }) => listReportedPosts({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listReportedPosts>>, TError, TData> & { queryKey: QueryKey }
}

export type ListReportedPostsQueryResult = NonNullable<Awaited<ReturnType<typeof listReportedPosts>>>
export type ListReportedPostsQueryError = AxiosError<void>

/**
 * @summary show reported posts
 */
export const useListReportedPosts = <TData = Awaited<ReturnType<typeof listReportedPosts>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listReportedPosts>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getListReportedPostsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary retrieve a forum post location within topic
 */
export const retrievePostLocation = (
    forumId: number,
    topicId: number,
    postId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/forums/${forumId}/topics/${topicId}/posts/${postId}/location`,options
    );
  }


export const getRetrievePostLocationQueryKey = (forumId: number,
    topicId: number,
    postId: number,) => {
    return [`https://api.mangaupdates.com/v1/forums/${forumId}/topics/${topicId}/posts/${postId}/location`] as const;
    }

    
export const getRetrievePostLocationInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrievePostLocation>>>, TError = AxiosError<void>>(forumId: number,
    topicId: number,
    postId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrievePostLocation>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrievePostLocationQueryKey(forumId,topicId,postId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrievePostLocation>>> = ({ signal }) => retrievePostLocation(forumId,topicId,postId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(forumId && topicId && postId),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrievePostLocation>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrievePostLocationInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrievePostLocation>>>
export type RetrievePostLocationInfiniteQueryError = AxiosError<void>

/**
 * @summary retrieve a forum post location within topic
 */
export const useRetrievePostLocationInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrievePostLocation>>>, TError = AxiosError<void>>(
 forumId: number,
    topicId: number,
    postId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrievePostLocation>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrievePostLocationInfiniteQueryOptions(forumId,topicId,postId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrievePostLocationQueryOptions = <TData = Awaited<ReturnType<typeof retrievePostLocation>>, TError = AxiosError<void>>(forumId: number,
    topicId: number,
    postId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrievePostLocation>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrievePostLocationQueryKey(forumId,topicId,postId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrievePostLocation>>> = ({ signal }) => retrievePostLocation(forumId,topicId,postId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(forumId && topicId && postId),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrievePostLocation>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrievePostLocationQueryResult = NonNullable<Awaited<ReturnType<typeof retrievePostLocation>>>
export type RetrievePostLocationQueryError = AxiosError<void>

/**
 * @summary retrieve a forum post location within topic
 */
export const useRetrievePostLocation = <TData = Awaited<ReturnType<typeof retrievePostLocation>>, TError = AxiosError<void>>(
 forumId: number,
    topicId: number,
    postId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrievePostLocation>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrievePostLocationQueryOptions(forumId,topicId,postId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary search forum
 */
export const searchForumPost = (
    forumSearchRequestV1: ForumSearchRequestV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ForumSearchResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/forums/search`,
      forumSearchRequestV1,options
    );
  }



export const getSearchForumPostMutationOptions = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchForumPost>>, TError,{data: ForumSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof searchForumPost>>, TError,{data: ForumSearchRequestV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchForumPost>>, {data: ForumSearchRequestV1}> = (props) => {
          const {data} = props ?? {};

          return  searchForumPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchForumPostMutationResult = NonNullable<Awaited<ReturnType<typeof searchForumPost>>>
    export type SearchForumPostMutationBody = ForumSearchRequestV1
    export type SearchForumPostMutationError = AxiosError<ApiResponseV1>

    /**
 * @summary search forum
 */
export const useSearchForumPost = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchForumPost>>, TError,{data: ForumSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof searchForumPost>>,
        TError,
        {data: ForumSearchRequestV1},
        TContext
      > => {

      const mutationOptions = getSearchForumPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary search specific forum
 */
export const searchSpecificForumPost = (
    forumId: number,
    forumSearchRequestV1: ForumSearchRequestV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ForumSearchResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/forums/${forumId}/search`,
      forumSearchRequestV1,options
    );
  }



export const getSearchSpecificForumPostMutationOptions = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchSpecificForumPost>>, TError,{forumId: number;data: ForumSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof searchSpecificForumPost>>, TError,{forumId: number;data: ForumSearchRequestV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchSpecificForumPost>>, {forumId: number;data: ForumSearchRequestV1}> = (props) => {
          const {forumId,data} = props ?? {};

          return  searchSpecificForumPost(forumId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchSpecificForumPostMutationResult = NonNullable<Awaited<ReturnType<typeof searchSpecificForumPost>>>
    export type SearchSpecificForumPostMutationBody = ForumSearchRequestV1
    export type SearchSpecificForumPostMutationError = AxiosError<ApiResponseV1>

    /**
 * @summary search specific forum
 */
export const useSearchSpecificForumPost = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchSpecificForumPost>>, TError,{forumId: number;data: ForumSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof searchSpecificForumPost>>,
        TError,
        {forumId: number;data: ForumSearchRequestV1},
        TContext
      > => {

      const mutationOptions = getSearchSpecificForumPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary search specific topic
 */
export const searchSpecificTopicPost = (
    forumId: number,
    topicId: number,
    forumSearchRequestV1: ForumSearchRequestV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ForumSearchResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/forums/${forumId}/topics/${topicId}/search`,
      forumSearchRequestV1,options
    );
  }



export const getSearchSpecificTopicPostMutationOptions = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchSpecificTopicPost>>, TError,{forumId: number;topicId: number;data: ForumSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof searchSpecificTopicPost>>, TError,{forumId: number;topicId: number;data: ForumSearchRequestV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchSpecificTopicPost>>, {forumId: number;topicId: number;data: ForumSearchRequestV1}> = (props) => {
          const {forumId,topicId,data} = props ?? {};

          return  searchSpecificTopicPost(forumId,topicId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchSpecificTopicPostMutationResult = NonNullable<Awaited<ReturnType<typeof searchSpecificTopicPost>>>
    export type SearchSpecificTopicPostMutationBody = ForumSearchRequestV1
    export type SearchSpecificTopicPostMutationError = AxiosError<ApiResponseV1>

    /**
 * @summary search specific topic
 */
export const useSearchSpecificTopicPost = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchSpecificTopicPost>>, TError,{forumId: number;topicId: number;data: ForumSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof searchSpecificTopicPost>>,
        TError,
        {forumId: number;topicId: number;data: ForumSearchRequestV1},
        TContext
      > => {

      const mutationOptions = getSearchSpecificTopicPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary show warn history for a user
 */
export const listWarnHistoryForUser = (
    userId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ForumWarnModelV1[]>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/forums/warn/${userId}/history`,options
    );
  }


export const getListWarnHistoryForUserQueryKey = (userId: number,) => {
    return [`https://api.mangaupdates.com/v1/forums/warn/${userId}/history`] as const;
    }

    
export const getListWarnHistoryForUserInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof listWarnHistoryForUser>>>, TError = AxiosError<void>>(userId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof listWarnHistoryForUser>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListWarnHistoryForUserQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listWarnHistoryForUser>>> = ({ signal }) => listWarnHistoryForUser(userId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof listWarnHistoryForUser>>, TError, TData> & { queryKey: QueryKey }
}

export type ListWarnHistoryForUserInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof listWarnHistoryForUser>>>
export type ListWarnHistoryForUserInfiniteQueryError = AxiosError<void>

/**
 * @summary show warn history for a user
 */
export const useListWarnHistoryForUserInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof listWarnHistoryForUser>>>, TError = AxiosError<void>>(
 userId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof listWarnHistoryForUser>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getListWarnHistoryForUserInfiniteQueryOptions(userId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getListWarnHistoryForUserQueryOptions = <TData = Awaited<ReturnType<typeof listWarnHistoryForUser>>, TError = AxiosError<void>>(userId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWarnHistoryForUser>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListWarnHistoryForUserQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listWarnHistoryForUser>>> = ({ signal }) => listWarnHistoryForUser(userId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listWarnHistoryForUser>>, TError, TData> & { queryKey: QueryKey }
}

export type ListWarnHistoryForUserQueryResult = NonNullable<Awaited<ReturnType<typeof listWarnHistoryForUser>>>
export type ListWarnHistoryForUserQueryError = AxiosError<void>

/**
 * @summary show warn history for a user
 */
export const useListWarnHistoryForUser = <TData = Awaited<ReturnType<typeof listWarnHistoryForUser>>, TError = AxiosError<void>>(
 userId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWarnHistoryForUser>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getListWarnHistoryForUserQueryOptions(userId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary gets the current warn status for user
 */
export const getCurrentWarnForUser = (
    userId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ForumWarnModelV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/forums/warn/${userId}`,options
    );
  }


export const getGetCurrentWarnForUserQueryKey = (userId: number,) => {
    return [`https://api.mangaupdates.com/v1/forums/warn/${userId}`] as const;
    }

    
export const getGetCurrentWarnForUserInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCurrentWarnForUser>>>, TError = AxiosError<unknown>>(userId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentWarnForUser>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentWarnForUserQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentWarnForUser>>> = ({ signal }) => getCurrentWarnForUser(userId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentWarnForUser>>, TError, TData> & { queryKey: QueryKey }
}

export type GetCurrentWarnForUserInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentWarnForUser>>>
export type GetCurrentWarnForUserInfiniteQueryError = AxiosError<unknown>

/**
 * @summary gets the current warn status for user
 */
export const useGetCurrentWarnForUserInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getCurrentWarnForUser>>>, TError = AxiosError<unknown>>(
 userId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentWarnForUser>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetCurrentWarnForUserInfiniteQueryOptions(userId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCurrentWarnForUserQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentWarnForUser>>, TError = AxiosError<unknown>>(userId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentWarnForUser>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentWarnForUserQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentWarnForUser>>> = ({ signal }) => getCurrentWarnForUser(userId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurrentWarnForUser>>, TError, TData> & { queryKey: QueryKey }
}

export type GetCurrentWarnForUserQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentWarnForUser>>>
export type GetCurrentWarnForUserQueryError = AxiosError<unknown>

/**
 * @summary gets the current warn status for user
 */
export const useGetCurrentWarnForUser = <TData = Awaited<ReturnType<typeof getCurrentWarnForUser>>, TError = AxiosError<unknown>>(
 userId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentWarnForUser>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetCurrentWarnForUserQueryOptions(userId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary update a user warn level
 */
export const updateUserWarnLevel = (
    userId: number,
    forumWarnModelUpdateV1: ForumWarnModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.put(
      `https://api.mangaupdates.com/v1/forums/warn/${userId}`,
      forumWarnModelUpdateV1,options
    );
  }



export const getUpdateUserWarnLevelMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUserWarnLevel>>, TError,{userId: number;data: ForumWarnModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateUserWarnLevel>>, TError,{userId: number;data: ForumWarnModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUserWarnLevel>>, {userId: number;data: ForumWarnModelUpdateV1}> = (props) => {
          const {userId,data} = props ?? {};

          return  updateUserWarnLevel(userId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUserWarnLevelMutationResult = NonNullable<Awaited<ReturnType<typeof updateUserWarnLevel>>>
    export type UpdateUserWarnLevelMutationBody = ForumWarnModelUpdateV1
    export type UpdateUserWarnLevelMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary update a user warn level
 */
export const useUpdateUserWarnLevel = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUserWarnLevel>>, TError,{userId: number;data: ForumWarnModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof updateUserWarnLevel>>,
        TError,
        {userId: number;data: ForumWarnModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getUpdateUserWarnLevelMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary get genres
 */
export const retrieveGenres = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GenreModelStatsV1[]>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/genres`,options
    );
  }


export const getRetrieveGenresQueryKey = () => {
    return [`https://api.mangaupdates.com/v1/genres`] as const;
    }

    
export const getRetrieveGenresInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveGenres>>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveGenres>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveGenresQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveGenres>>> = ({ signal }) => retrieveGenres({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveGenres>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveGenresInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveGenres>>>
export type RetrieveGenresInfiniteQueryError = AxiosError<unknown>

/**
 * @summary get genres
 */
export const useRetrieveGenresInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveGenres>>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveGenres>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveGenresInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveGenresQueryOptions = <TData = Awaited<ReturnType<typeof retrieveGenres>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveGenres>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveGenresQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveGenres>>> = ({ signal }) => retrieveGenres({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveGenres>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveGenresQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveGenres>>>
export type RetrieveGenresQueryError = AxiosError<unknown>

/**
 * @summary get genres
 */
export const useRetrieveGenres = <TData = Awaited<ReturnType<typeof retrieveGenres>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveGenres>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveGenresQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary add a genre
 */
export const addGenre = (
    genreModelUpdateV1: GenreModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/genres`,
      genreModelUpdateV1,options
    );
  }



export const getAddGenreMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addGenre>>, TError,{data: GenreModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addGenre>>, TError,{data: GenreModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addGenre>>, {data: GenreModelUpdateV1}> = (props) => {
          const {data} = props ?? {};

          return  addGenre(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddGenreMutationResult = NonNullable<Awaited<ReturnType<typeof addGenre>>>
    export type AddGenreMutationBody = GenreModelUpdateV1
    export type AddGenreMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary add a genre
 */
export const useAddGenre = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addGenre>>, TError,{data: GenreModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof addGenre>>,
        TError,
        {data: GenreModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getAddGenreMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary get genres
 */
export const retrieveGenreById = (
    id: number,
    params?: RetrieveGenreByIdParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GenreModelStatsV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/genres/${id}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getRetrieveGenreByIdQueryKey = (id: number,
    params?: RetrieveGenreByIdParams,) => {
    return [`https://api.mangaupdates.com/v1/genres/${id}`, ...(params ? [params]: [])] as const;
    }

    
export const getRetrieveGenreByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveGenreById>>>, TError = AxiosError<unknown>>(id: number,
    params?: RetrieveGenreByIdParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveGenreById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveGenreByIdQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveGenreById>>> = ({ signal }) => retrieveGenreById(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveGenreById>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveGenreByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveGenreById>>>
export type RetrieveGenreByIdInfiniteQueryError = AxiosError<unknown>

/**
 * @summary get genres
 */
export const useRetrieveGenreByIdInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveGenreById>>>, TError = AxiosError<unknown>>(
 id: number,
    params?: RetrieveGenreByIdParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveGenreById>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveGenreByIdInfiniteQueryOptions(id,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveGenreByIdQueryOptions = <TData = Awaited<ReturnType<typeof retrieveGenreById>>, TError = AxiosError<unknown>>(id: number,
    params?: RetrieveGenreByIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveGenreById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveGenreByIdQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveGenreById>>> = ({ signal }) => retrieveGenreById(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveGenreById>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveGenreByIdQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveGenreById>>>
export type RetrieveGenreByIdQueryError = AxiosError<unknown>

/**
 * @summary get genres
 */
export const useRetrieveGenreById = <TData = Awaited<ReturnType<typeof retrieveGenreById>>, TError = AxiosError<unknown>>(
 id: number,
    params?: RetrieveGenreByIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveGenreById>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveGenreByIdQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary delete a genre
 */
export const deleteGenre = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.delete(
      `https://api.mangaupdates.com/v1/genres/${id}`,options
    );
  }



export const getDeleteGenreMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteGenre>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteGenre>>, TError,{id: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteGenre>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteGenre(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteGenreMutationResult = NonNullable<Awaited<ReturnType<typeof deleteGenre>>>
    
    export type DeleteGenreMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary delete a genre
 */
export const useDeleteGenre = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteGenre>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteGenre>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteGenreMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary update a genre
 */
export const updateGenre = (
    id: number,
    genreModelUpdateV1: GenreModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.patch(
      `https://api.mangaupdates.com/v1/genres/${id}`,
      genreModelUpdateV1,options
    );
  }



export const getUpdateGenreMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateGenre>>, TError,{id: number;data: GenreModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateGenre>>, TError,{id: number;data: GenreModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateGenre>>, {id: number;data: GenreModelUpdateV1}> = (props) => {
          const {id,data} = props ?? {};

          return  updateGenre(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateGenreMutationResult = NonNullable<Awaited<ReturnType<typeof updateGenre>>>
    export type UpdateGenreMutationBody = GenreModelUpdateV1
    export type UpdateGenreMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary update a genre
 */
export const useUpdateGenre = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateGenre>>, TError,{id: number;data: GenreModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof updateGenre>>,
        TError,
        {id: number;data: GenreModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getUpdateGenreMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary add an group
 */
export const addGroup = (
    groupsModelUpdateV1: GroupsModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/groups`,
      groupsModelUpdateV1,options
    );
  }



export const getAddGroupMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addGroup>>, TError,{data: GroupsModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addGroup>>, TError,{data: GroupsModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addGroup>>, {data: GroupsModelUpdateV1}> = (props) => {
          const {data} = props ?? {};

          return  addGroup(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddGroupMutationResult = NonNullable<Awaited<ReturnType<typeof addGroup>>>
    export type AddGroupMutationBody = GroupsModelUpdateV1
    export type AddGroupMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary add an group
 */
export const useAddGroup = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addGroup>>, TError,{data: GroupsModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof addGroup>>,
        TError,
        {data: GroupsModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getAddGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary get a specific group
 */
export const retrieveGroup = (
    id: number,
    params?: RetrieveGroupParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GroupsModelV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/groups/${id}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getRetrieveGroupQueryKey = (id: number,
    params?: RetrieveGroupParams,) => {
    return [`https://api.mangaupdates.com/v1/groups/${id}`, ...(params ? [params]: [])] as const;
    }

    
export const getRetrieveGroupInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveGroup>>>, TError = AxiosError<void>>(id: number,
    params?: RetrieveGroupParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveGroup>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveGroupQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveGroup>>> = ({ signal }) => retrieveGroup(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveGroup>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveGroupInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveGroup>>>
export type RetrieveGroupInfiniteQueryError = AxiosError<void>

/**
 * @summary get a specific group
 */
export const useRetrieveGroupInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveGroup>>>, TError = AxiosError<void>>(
 id: number,
    params?: RetrieveGroupParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveGroup>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveGroupInfiniteQueryOptions(id,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveGroupQueryOptions = <TData = Awaited<ReturnType<typeof retrieveGroup>>, TError = AxiosError<void>>(id: number,
    params?: RetrieveGroupParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveGroup>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveGroupQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveGroup>>> = ({ signal }) => retrieveGroup(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveGroup>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveGroupQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveGroup>>>
export type RetrieveGroupQueryError = AxiosError<void>

/**
 * @summary get a specific group
 */
export const useRetrieveGroup = <TData = Awaited<ReturnType<typeof retrieveGroup>>, TError = AxiosError<void>>(
 id: number,
    params?: RetrieveGroupParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveGroup>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveGroupQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary delete a group
 */
export const deleteGroup = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.delete(
      `https://api.mangaupdates.com/v1/groups/${id}`,options
    );
  }



export const getDeleteGroupMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteGroup>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteGroup>>, TError,{id: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteGroup>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteGroup(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteGroupMutationResult = NonNullable<Awaited<ReturnType<typeof deleteGroup>>>
    
    export type DeleteGroupMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary delete a group
 */
export const useDeleteGroup = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteGroup>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteGroup>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary update an group
 */
export const updateGroup = (
    id: number,
    groupsModelUpdateV1: GroupsModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.patch(
      `https://api.mangaupdates.com/v1/groups/${id}`,
      groupsModelUpdateV1,options
    );
  }



export const getUpdateGroupMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateGroup>>, TError,{id: number;data: GroupsModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateGroup>>, TError,{id: number;data: GroupsModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateGroup>>, {id: number;data: GroupsModelUpdateV1}> = (props) => {
          const {id,data} = props ?? {};

          return  updateGroup(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateGroupMutationResult = NonNullable<Awaited<ReturnType<typeof updateGroup>>>
    export type UpdateGroupMutationBody = GroupsModelUpdateV1
    export type UpdateGroupMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary update an group
 */
export const useUpdateGroup = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateGroup>>, TError,{id: number;data: GroupsModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof updateGroup>>,
        TError,
        {id: number;data: GroupsModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getUpdateGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary reject and delete a group
 */
export const rejectGroup = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/groups/${id}/reject`,undefined,options
    );
  }



export const getRejectGroupMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rejectGroup>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof rejectGroup>>, TError,{id: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof rejectGroup>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  rejectGroup(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RejectGroupMutationResult = NonNullable<Awaited<ReturnType<typeof rejectGroup>>>
    
    export type RejectGroupMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary reject and delete a group
 */
export const useRejectGroup = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rejectGroup>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof rejectGroup>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getRejectGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary search groups
 */
export const searchGroupsPost = (
    groupsSearchRequestV1: GroupsSearchRequestV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GroupsSearchResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/groups/search`,
      groupsSearchRequestV1,options
    );
  }



export const getSearchGroupsPostMutationOptions = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchGroupsPost>>, TError,{data: GroupsSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof searchGroupsPost>>, TError,{data: GroupsSearchRequestV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchGroupsPost>>, {data: GroupsSearchRequestV1}> = (props) => {
          const {data} = props ?? {};

          return  searchGroupsPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchGroupsPostMutationResult = NonNullable<Awaited<ReturnType<typeof searchGroupsPost>>>
    export type SearchGroupsPostMutationBody = GroupsSearchRequestV1
    export type SearchGroupsPostMutationError = AxiosError<ApiResponseV1>

    /**
 * @summary search groups
 */
export const useSearchGroupsPost = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchGroupsPost>>, TError,{data: GroupsSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof searchGroupsPost>>,
        TError,
        {data: GroupsSearchRequestV1},
        TContext
      > => {

      const mutationOptions = getSearchGroupsPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary get the list of series and release frequency for a specific group
 */
export const retrieveGroupSeries = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GroupsSeriesListResponseV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/groups/${id}/series`,options
    );
  }


export const getRetrieveGroupSeriesQueryKey = (id: number,) => {
    return [`https://api.mangaupdates.com/v1/groups/${id}/series`] as const;
    }

    
export const getRetrieveGroupSeriesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveGroupSeries>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveGroupSeries>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveGroupSeriesQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveGroupSeries>>> = ({ signal }) => retrieveGroupSeries(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveGroupSeries>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveGroupSeriesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveGroupSeries>>>
export type RetrieveGroupSeriesInfiniteQueryError = AxiosError<void>

/**
 * @summary get the list of series and release frequency for a specific group
 */
export const useRetrieveGroupSeriesInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveGroupSeries>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveGroupSeries>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveGroupSeriesInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveGroupSeriesQueryOptions = <TData = Awaited<ReturnType<typeof retrieveGroupSeries>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveGroupSeries>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveGroupSeriesQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveGroupSeries>>> = ({ signal }) => retrieveGroupSeries(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveGroupSeries>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveGroupSeriesQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveGroupSeries>>>
export type RetrieveGroupSeriesQueryError = AxiosError<void>

/**
 * @summary get the list of series and release frequency for a specific group
 */
export const useRetrieveGroupSeries = <TData = Awaited<ReturnType<typeof retrieveGroupSeries>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveGroupSeries>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveGroupSeriesQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary retrieve list of user lists
 */
export const retrieveLists = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListsModelV1[]>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/lists`,options
    );
  }


export const getRetrieveListsQueryKey = () => {
    return [`https://api.mangaupdates.com/v1/lists`] as const;
    }

    
export const getRetrieveListsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveLists>>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveLists>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveListsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveLists>>> = ({ signal }) => retrieveLists({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveLists>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveListsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveLists>>>
export type RetrieveListsInfiniteQueryError = AxiosError<unknown>

/**
 * @summary retrieve list of user lists
 */
export const useRetrieveListsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveLists>>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveLists>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveListsInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveListsQueryOptions = <TData = Awaited<ReturnType<typeof retrieveLists>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveLists>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveListsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveLists>>> = ({ signal }) => retrieveLists({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveLists>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveListsQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveLists>>>
export type RetrieveListsQueryError = AxiosError<unknown>

/**
 * @summary retrieve list of user lists
 */
export const useRetrieveLists = <TData = Awaited<ReturnType<typeof retrieveLists>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveLists>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveListsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary add a custom user list
 */
export const addCustomList = (
    listsModelUpdateV1: ListsModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/lists`,
      listsModelUpdateV1,options
    );
  }



export const getAddCustomListMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addCustomList>>, TError,{data: ListsModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addCustomList>>, TError,{data: ListsModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addCustomList>>, {data: ListsModelUpdateV1}> = (props) => {
          const {data} = props ?? {};

          return  addCustomList(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddCustomListMutationResult = NonNullable<Awaited<ReturnType<typeof addCustomList>>>
    export type AddCustomListMutationBody = ListsModelUpdateV1
    export type AddCustomListMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary add a custom user list
 */
export const useAddCustomList = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addCustomList>>, TError,{data: ListsModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof addCustomList>>,
        TError,
        {data: ListsModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getAddCustomListMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary retrieve list metadata and options
 */
export const retrieveListById = (
    id: number,
    params?: RetrieveListByIdParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListsModelV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/lists/${id}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getRetrieveListByIdQueryKey = (id: number,
    params?: RetrieveListByIdParams,) => {
    return [`https://api.mangaupdates.com/v1/lists/${id}`, ...(params ? [params]: [])] as const;
    }

    
export const getRetrieveListByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveListById>>>, TError = AxiosError<void>>(id: number,
    params?: RetrieveListByIdParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveListById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveListByIdQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveListById>>> = ({ signal }) => retrieveListById(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveListById>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveListByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveListById>>>
export type RetrieveListByIdInfiniteQueryError = AxiosError<void>

/**
 * @summary retrieve list metadata and options
 */
export const useRetrieveListByIdInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveListById>>>, TError = AxiosError<void>>(
 id: number,
    params?: RetrieveListByIdParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveListById>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveListByIdInfiniteQueryOptions(id,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveListByIdQueryOptions = <TData = Awaited<ReturnType<typeof retrieveListById>>, TError = AxiosError<void>>(id: number,
    params?: RetrieveListByIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveListById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveListByIdQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveListById>>> = ({ signal }) => retrieveListById(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveListById>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveListByIdQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveListById>>>
export type RetrieveListByIdQueryError = AxiosError<void>

/**
 * @summary retrieve list metadata and options
 */
export const useRetrieveListById = <TData = Awaited<ReturnType<typeof retrieveListById>>, TError = AxiosError<void>>(
 id: number,
    params?: RetrieveListByIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveListById>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveListByIdQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary remove a custom list
 */
export const deleteCustomList = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.delete(
      `https://api.mangaupdates.com/v1/lists/${id}`,options
    );
  }



export const getDeleteCustomListMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCustomList>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteCustomList>>, TError,{id: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCustomList>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteCustomList(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCustomListMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCustomList>>>
    
    export type DeleteCustomListMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary remove a custom list
 */
export const useDeleteCustomList = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCustomList>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteCustomList>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteCustomListMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary update a user list
 */
export const updateList = (
    id: number,
    listsModelUpdateV1: ListsModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.patch(
      `https://api.mangaupdates.com/v1/lists/${id}`,
      listsModelUpdateV1,options
    );
  }



export const getUpdateListMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateList>>, TError,{id: number;data: ListsModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateList>>, TError,{id: number;data: ListsModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateList>>, {id: number;data: ListsModelUpdateV1}> = (props) => {
          const {id,data} = props ?? {};

          return  updateList(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateListMutationResult = NonNullable<Awaited<ReturnType<typeof updateList>>>
    export type UpdateListMutationBody = ListsModelUpdateV1
    export type UpdateListMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary update a user list
 */
export const useUpdateList = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateList>>, TError,{id: number;data: ListsModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof updateList>>,
        TError,
        {id: number;data: ListsModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getUpdateListMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary retrieve list of user lists
 */
export const retrievePublicLists = (
    userId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListsModelV1[]>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/lists/public/${userId}`,options
    );
  }


export const getRetrievePublicListsQueryKey = (userId: number,) => {
    return [`https://api.mangaupdates.com/v1/lists/public/${userId}`] as const;
    }

    
export const getRetrievePublicListsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrievePublicLists>>>, TError = AxiosError<unknown>>(userId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrievePublicLists>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrievePublicListsQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrievePublicLists>>> = ({ signal }) => retrievePublicLists(userId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrievePublicLists>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrievePublicListsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrievePublicLists>>>
export type RetrievePublicListsInfiniteQueryError = AxiosError<unknown>

/**
 * @summary retrieve list of user lists
 */
export const useRetrievePublicListsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrievePublicLists>>>, TError = AxiosError<unknown>>(
 userId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrievePublicLists>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrievePublicListsInfiniteQueryOptions(userId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrievePublicListsQueryOptions = <TData = Awaited<ReturnType<typeof retrievePublicLists>>, TError = AxiosError<unknown>>(userId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrievePublicLists>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrievePublicListsQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrievePublicLists>>> = ({ signal }) => retrievePublicLists(userId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrievePublicLists>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrievePublicListsQueryResult = NonNullable<Awaited<ReturnType<typeof retrievePublicLists>>>
export type RetrievePublicListsQueryError = AxiosError<unknown>

/**
 * @summary retrieve list of user lists
 */
export const useRetrievePublicLists = <TData = Awaited<ReturnType<typeof retrievePublicLists>>, TError = AxiosError<unknown>>(
 userId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrievePublicLists>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrievePublicListsQueryOptions(userId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary retrieve stats for user public lists
 */
export const retrievePublicListStats = (
    userId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListsPublicStatsModelV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/lists/public/${userId}/stats`,options
    );
  }


export const getRetrievePublicListStatsQueryKey = (userId: number,) => {
    return [`https://api.mangaupdates.com/v1/lists/public/${userId}/stats`] as const;
    }

    
export const getRetrievePublicListStatsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrievePublicListStats>>>, TError = AxiosError<unknown>>(userId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrievePublicListStats>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrievePublicListStatsQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrievePublicListStats>>> = ({ signal }) => retrievePublicListStats(userId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrievePublicListStats>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrievePublicListStatsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrievePublicListStats>>>
export type RetrievePublicListStatsInfiniteQueryError = AxiosError<unknown>

/**
 * @summary retrieve stats for user public lists
 */
export const useRetrievePublicListStatsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrievePublicListStats>>>, TError = AxiosError<unknown>>(
 userId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrievePublicListStats>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrievePublicListStatsInfiniteQueryOptions(userId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrievePublicListStatsQueryOptions = <TData = Awaited<ReturnType<typeof retrievePublicListStats>>, TError = AxiosError<unknown>>(userId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrievePublicListStats>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrievePublicListStatsQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrievePublicListStats>>> = ({ signal }) => retrievePublicListStats(userId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrievePublicListStats>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrievePublicListStatsQueryResult = NonNullable<Awaited<ReturnType<typeof retrievePublicListStats>>>
export type RetrievePublicListStatsQueryError = AxiosError<unknown>

/**
 * @summary retrieve stats for user public lists
 */
export const useRetrievePublicListStats = <TData = Awaited<ReturnType<typeof retrievePublicListStats>>, TError = AxiosError<unknown>>(
 userId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrievePublicListStats>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrievePublicListStatsQueryOptions(userId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary search lists
 */
export const searchPublicListsPost = (
    userId: number,
    id: number,
    listsSearchRequestV1: ListsSearchRequestV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListsPublicSearchResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/lists/public/${userId}/search/${id}`,
      listsSearchRequestV1,options
    );
  }



export const getSearchPublicListsPostMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchPublicListsPost>>, TError,{userId: number;id: number;data: ListsSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof searchPublicListsPost>>, TError,{userId: number;id: number;data: ListsSearchRequestV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchPublicListsPost>>, {userId: number;id: number;data: ListsSearchRequestV1}> = (props) => {
          const {userId,id,data} = props ?? {};

          return  searchPublicListsPost(userId,id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchPublicListsPostMutationResult = NonNullable<Awaited<ReturnType<typeof searchPublicListsPost>>>
    export type SearchPublicListsPostMutationBody = ListsSearchRequestV1
    export type SearchPublicListsPostMutationError = AxiosError<unknown>

    /**
 * @summary search lists
 */
export const useSearchPublicListsPost = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchPublicListsPost>>, TError,{userId: number;id: number;data: ListsSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof searchPublicListsPost>>,
        TError,
        {userId: number;id: number;data: ListsSearchRequestV1},
        TContext
      > => {

      const mutationOptions = getSearchPublicListsPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary search lists
 */
export const searchListsPost = (
    id: number,
    listsSearchRequestV1: ListsSearchRequestV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListsSearchResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/lists/${id}/search`,
      listsSearchRequestV1,options
    );
  }



export const getSearchListsPostMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchListsPost>>, TError,{id: number;data: ListsSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof searchListsPost>>, TError,{id: number;data: ListsSearchRequestV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchListsPost>>, {id: number;data: ListsSearchRequestV1}> = (props) => {
          const {id,data} = props ?? {};

          return  searchListsPost(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchListsPostMutationResult = NonNullable<Awaited<ReturnType<typeof searchListsPost>>>
    export type SearchListsPostMutationBody = ListsSearchRequestV1
    export type SearchListsPostMutationError = AxiosError<unknown>

    /**
 * @summary search lists
 */
export const useSearchListsPost = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchListsPost>>, TError,{id: number;data: ListsSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof searchListsPost>>,
        TError,
        {id: number;data: ListsSearchRequestV1},
        TContext
      > => {

      const mutationOptions = getSearchListsPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary add a series to a list
 */
export const addListSeries = (
    listsSeriesModelUpdateV1: ListsSeriesModelUpdateV1[], options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/lists/series`,
      listsSeriesModelUpdateV1,options
    );
  }



export const getAddListSeriesMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addListSeries>>, TError,{data: ListsSeriesModelUpdateV1[]}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addListSeries>>, TError,{data: ListsSeriesModelUpdateV1[]}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addListSeries>>, {data: ListsSeriesModelUpdateV1[]}> = (props) => {
          const {data} = props ?? {};

          return  addListSeries(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddListSeriesMutationResult = NonNullable<Awaited<ReturnType<typeof addListSeries>>>
    export type AddListSeriesMutationBody = ListsSeriesModelUpdateV1[]
    export type AddListSeriesMutationError = AxiosError<void>

    /**
 * @summary add a series to a list
 */
export const useAddListSeries = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addListSeries>>, TError,{data: ListsSeriesModelUpdateV1[]}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof addListSeries>>,
        TError,
        {data: ListsSeriesModelUpdateV1[]},
        TContext
      > => {

      const mutationOptions = getAddListSeriesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary add a list of series to a list
 */
export const addListSeriesBulk = (
    id: number,
    listsBulkAddModelV1: ListsBulkAddModelV1[], options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/lists/${id}/series/bulk`,
      listsBulkAddModelV1,options
    );
  }



export const getAddListSeriesBulkMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addListSeriesBulk>>, TError,{id: number;data: ListsBulkAddModelV1[]}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addListSeriesBulk>>, TError,{id: number;data: ListsBulkAddModelV1[]}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addListSeriesBulk>>, {id: number;data: ListsBulkAddModelV1[]}> = (props) => {
          const {id,data} = props ?? {};

          return  addListSeriesBulk(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddListSeriesBulkMutationResult = NonNullable<Awaited<ReturnType<typeof addListSeriesBulk>>>
    export type AddListSeriesBulkMutationBody = ListsBulkAddModelV1[]
    export type AddListSeriesBulkMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary add a list of series to a list
 */
export const useAddListSeriesBulk = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addListSeriesBulk>>, TError,{id: number;data: ListsBulkAddModelV1[]}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof addListSeriesBulk>>,
        TError,
        {id: number;data: ListsBulkAddModelV1[]},
        TContext
      > => {

      const mutationOptions = getAddListSeriesBulkMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary remove a series from a list
 */
export const deleteListSeries = (
    deleteListSeriesBody: number[], options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/lists/series/delete`,
      deleteListSeriesBody,options
    );
  }



export const getDeleteListSeriesMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteListSeries>>, TError,{data: number[]}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteListSeries>>, TError,{data: number[]}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteListSeries>>, {data: number[]}> = (props) => {
          const {data} = props ?? {};

          return  deleteListSeries(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteListSeriesMutationResult = NonNullable<Awaited<ReturnType<typeof deleteListSeries>>>
    export type DeleteListSeriesMutationBody = number[]
    export type DeleteListSeriesMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary remove a series from a list
 */
export const useDeleteListSeries = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteListSeries>>, TError,{data: number[]}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteListSeries>>,
        TError,
        {data: number[]},
        TContext
      > => {

      const mutationOptions = getDeleteListSeriesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary retrieve list series item
 */
export const retrieveListSeries = (
    seriesId: number,
    params?: RetrieveListSeriesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListsSeriesModelV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/lists/series/${seriesId}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getRetrieveListSeriesQueryKey = (seriesId: number,
    params?: RetrieveListSeriesParams,) => {
    return [`https://api.mangaupdates.com/v1/lists/series/${seriesId}`, ...(params ? [params]: [])] as const;
    }

    
export const getRetrieveListSeriesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveListSeries>>>, TError = AxiosError<void>>(seriesId: number,
    params?: RetrieveListSeriesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveListSeries>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveListSeriesQueryKey(seriesId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveListSeries>>> = ({ signal }) => retrieveListSeries(seriesId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(seriesId),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveListSeries>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveListSeriesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveListSeries>>>
export type RetrieveListSeriesInfiniteQueryError = AxiosError<void>

/**
 * @summary retrieve list series item
 */
export const useRetrieveListSeriesInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveListSeries>>>, TError = AxiosError<void>>(
 seriesId: number,
    params?: RetrieveListSeriesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveListSeries>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveListSeriesInfiniteQueryOptions(seriesId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveListSeriesQueryOptions = <TData = Awaited<ReturnType<typeof retrieveListSeries>>, TError = AxiosError<void>>(seriesId: number,
    params?: RetrieveListSeriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveListSeries>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveListSeriesQueryKey(seriesId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveListSeries>>> = ({ signal }) => retrieveListSeries(seriesId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(seriesId),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveListSeries>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveListSeriesQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveListSeries>>>
export type RetrieveListSeriesQueryError = AxiosError<void>

/**
 * @summary retrieve list series item
 */
export const useRetrieveListSeries = <TData = Awaited<ReturnType<typeof retrieveListSeries>>, TError = AxiosError<void>>(
 seriesId: number,
    params?: RetrieveListSeriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveListSeries>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveListSeriesQueryOptions(seriesId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary update a series list item
 */
export const updateListSeries = (
    listsSeriesModelUpdateV1: ListsSeriesModelUpdateV1[], options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/lists/series/update`,
      listsSeriesModelUpdateV1,options
    );
  }



export const getUpdateListSeriesMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateListSeries>>, TError,{data: ListsSeriesModelUpdateV1[]}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateListSeries>>, TError,{data: ListsSeriesModelUpdateV1[]}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateListSeries>>, {data: ListsSeriesModelUpdateV1[]}> = (props) => {
          const {data} = props ?? {};

          return  updateListSeries(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateListSeriesMutationResult = NonNullable<Awaited<ReturnType<typeof updateListSeries>>>
    export type UpdateListSeriesMutationBody = ListsSeriesModelUpdateV1[]
    export type UpdateListSeriesMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary update a series list item
 */
export const useUpdateListSeries = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateListSeries>>, TError,{data: ListsSeriesModelUpdateV1[]}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof updateListSeries>>,
        TError,
        {data: ListsSeriesModelUpdateV1[]},
        TContext
      > => {

      const mutationOptions = getUpdateListSeriesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary retrieve users who have similar interests based on series
 */
export const retrieveSimilarUsersBySeries = (
    listName: 'read' | 'wish' | 'complete' | 'unfinished' | 'hold',
    seriesId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListsSimilarUsersResponseV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/lists/similar/${listName}/${seriesId}`,options
    );
  }


export const getRetrieveSimilarUsersBySeriesQueryKey = (listName: 'read' | 'wish' | 'complete' | 'unfinished' | 'hold',
    seriesId: number,) => {
    return [`https://api.mangaupdates.com/v1/lists/similar/${listName}/${seriesId}`] as const;
    }

    
export const getRetrieveSimilarUsersBySeriesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveSimilarUsersBySeries>>>, TError = AxiosError<void>>(listName: 'read' | 'wish' | 'complete' | 'unfinished' | 'hold',
    seriesId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveSimilarUsersBySeries>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveSimilarUsersBySeriesQueryKey(listName,seriesId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveSimilarUsersBySeries>>> = ({ signal }) => retrieveSimilarUsersBySeries(listName,seriesId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(listName && seriesId),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveSimilarUsersBySeries>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveSimilarUsersBySeriesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveSimilarUsersBySeries>>>
export type RetrieveSimilarUsersBySeriesInfiniteQueryError = AxiosError<void>

/**
 * @summary retrieve users who have similar interests based on series
 */
export const useRetrieveSimilarUsersBySeriesInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveSimilarUsersBySeries>>>, TError = AxiosError<void>>(
 listName: 'read' | 'wish' | 'complete' | 'unfinished' | 'hold',
    seriesId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveSimilarUsersBySeries>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveSimilarUsersBySeriesInfiniteQueryOptions(listName,seriesId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveSimilarUsersBySeriesQueryOptions = <TData = Awaited<ReturnType<typeof retrieveSimilarUsersBySeries>>, TError = AxiosError<void>>(listName: 'read' | 'wish' | 'complete' | 'unfinished' | 'hold',
    seriesId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveSimilarUsersBySeries>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveSimilarUsersBySeriesQueryKey(listName,seriesId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveSimilarUsersBySeries>>> = ({ signal }) => retrieveSimilarUsersBySeries(listName,seriesId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(listName && seriesId),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveSimilarUsersBySeries>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveSimilarUsersBySeriesQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveSimilarUsersBySeries>>>
export type RetrieveSimilarUsersBySeriesQueryError = AxiosError<void>

/**
 * @summary retrieve users who have similar interests based on series
 */
export const useRetrieveSimilarUsersBySeries = <TData = Awaited<ReturnType<typeof retrieveSimilarUsersBySeries>>, TError = AxiosError<void>>(
 listName: 'read' | 'wish' | 'complete' | 'unfinished' | 'hold',
    seriesId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveSimilarUsersBySeries>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveSimilarUsersBySeriesQueryOptions(listName,seriesId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary get the current time
 */
export const time = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TimeV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/misc/time`,options
    );
  }


export const getTimeQueryKey = () => {
    return [`https://api.mangaupdates.com/v1/misc/time`] as const;
    }

    
export const getTimeInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof time>>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof time>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTimeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof time>>> = ({ signal }) => time({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof time>>, TError, TData> & { queryKey: QueryKey }
}

export type TimeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof time>>>
export type TimeInfiniteQueryError = AxiosError<unknown>

/**
 * @summary get the current time
 */
export const useTimeInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof time>>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof time>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getTimeInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getTimeQueryOptions = <TData = Awaited<ReturnType<typeof time>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof time>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTimeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof time>>> = ({ signal }) => time({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof time>>, TError, TData> & { queryKey: QueryKey }
}

export type TimeQueryResult = NonNullable<Awaited<ReturnType<typeof time>>>
export type TimeQueryError = AxiosError<unknown>

/**
 * @summary get the current time
 */
export const useTime = <TData = Awaited<ReturnType<typeof time>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof time>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getTimeQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary list online users
 */
export const listOnlineUsers = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MiscOnlineUsersModelV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/misc/online`,options
    );
  }


export const getListOnlineUsersQueryKey = () => {
    return [`https://api.mangaupdates.com/v1/misc/online`] as const;
    }

    
export const getListOnlineUsersInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof listOnlineUsers>>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof listOnlineUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListOnlineUsersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listOnlineUsers>>> = ({ signal }) => listOnlineUsers({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof listOnlineUsers>>, TError, TData> & { queryKey: QueryKey }
}

export type ListOnlineUsersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof listOnlineUsers>>>
export type ListOnlineUsersInfiniteQueryError = AxiosError<unknown>

/**
 * @summary list online users
 */
export const useListOnlineUsersInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof listOnlineUsers>>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof listOnlineUsers>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getListOnlineUsersInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getListOnlineUsersQueryOptions = <TData = Awaited<ReturnType<typeof listOnlineUsers>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listOnlineUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListOnlineUsersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listOnlineUsers>>> = ({ signal }) => listOnlineUsers({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listOnlineUsers>>, TError, TData> & { queryKey: QueryKey }
}

export type ListOnlineUsersQueryResult = NonNullable<Awaited<ReturnType<typeof listOnlineUsers>>>
export type ListOnlineUsersQueryError = AxiosError<unknown>

/**
 * @summary list online users
 */
export const useListOnlineUsers = <TData = Awaited<ReturnType<typeof listOnlineUsers>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listOnlineUsers>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getListOnlineUsersQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary get the status of a bulk transaction
 */
export const retrieveSlowTransactionStatus = (
    transactionId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MiscSlowTransactionStatusResponseV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/misc/slow-transaction-status/${transactionId}`,options
    );
  }


export const getRetrieveSlowTransactionStatusQueryKey = (transactionId: string,) => {
    return [`https://api.mangaupdates.com/v1/misc/slow-transaction-status/${transactionId}`] as const;
    }

    
export const getRetrieveSlowTransactionStatusInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveSlowTransactionStatus>>>, TError = AxiosError<void>>(transactionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveSlowTransactionStatus>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveSlowTransactionStatusQueryKey(transactionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveSlowTransactionStatus>>> = ({ signal }) => retrieveSlowTransactionStatus(transactionId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(transactionId),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveSlowTransactionStatus>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveSlowTransactionStatusInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveSlowTransactionStatus>>>
export type RetrieveSlowTransactionStatusInfiniteQueryError = AxiosError<void>

/**
 * @summary get the status of a bulk transaction
 */
export const useRetrieveSlowTransactionStatusInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveSlowTransactionStatus>>>, TError = AxiosError<void>>(
 transactionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveSlowTransactionStatus>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveSlowTransactionStatusInfiniteQueryOptions(transactionId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveSlowTransactionStatusQueryOptions = <TData = Awaited<ReturnType<typeof retrieveSlowTransactionStatus>>, TError = AxiosError<void>>(transactionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveSlowTransactionStatus>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveSlowTransactionStatusQueryKey(transactionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveSlowTransactionStatus>>> = ({ signal }) => retrieveSlowTransactionStatus(transactionId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(transactionId),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveSlowTransactionStatus>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveSlowTransactionStatusQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveSlowTransactionStatus>>>
export type RetrieveSlowTransactionStatusQueryError = AxiosError<void>

/**
 * @summary get the status of a bulk transaction
 */
export const useRetrieveSlowTransactionStatus = <TData = Awaited<ReturnType<typeof retrieveSlowTransactionStatus>>, TError = AxiosError<void>>(
 transactionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveSlowTransactionStatus>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveSlowTransactionStatusQueryOptions(transactionId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary show various site stats
 */
export const siteStats = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MiscStatsModelV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/misc/stats`,options
    );
  }


export const getSiteStatsQueryKey = () => {
    return [`https://api.mangaupdates.com/v1/misc/stats`] as const;
    }

    
export const getSiteStatsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof siteStats>>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof siteStats>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSiteStatsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof siteStats>>> = ({ signal }) => siteStats({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof siteStats>>, TError, TData> & { queryKey: QueryKey }
}

export type SiteStatsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof siteStats>>>
export type SiteStatsInfiniteQueryError = AxiosError<unknown>

/**
 * @summary show various site stats
 */
export const useSiteStatsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof siteStats>>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof siteStats>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSiteStatsInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getSiteStatsQueryOptions = <TData = Awaited<ReturnType<typeof siteStats>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof siteStats>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSiteStatsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof siteStats>>> = ({ signal }) => siteStats({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof siteStats>>, TError, TData> & { queryKey: QueryKey }
}

export type SiteStatsQueryResult = NonNullable<Awaited<ReturnType<typeof siteStats>>>
export type SiteStatsQueryError = AxiosError<unknown>

/**
 * @summary show various site stats
 */
export const useSiteStats = <TData = Awaited<ReturnType<typeof siteStats>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof siteStats>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSiteStatsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary get the active poll
 */
export const retrievePoll = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PollModelV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/poll`,options
    );
  }


export const getRetrievePollQueryKey = () => {
    return [`https://api.mangaupdates.com/v1/poll`] as const;
    }

    
export const getRetrievePollInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrievePoll>>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrievePoll>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrievePollQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrievePoll>>> = ({ signal }) => retrievePoll({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrievePoll>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrievePollInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrievePoll>>>
export type RetrievePollInfiniteQueryError = AxiosError<unknown>

/**
 * @summary get the active poll
 */
export const useRetrievePollInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrievePoll>>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrievePoll>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrievePollInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrievePollQueryOptions = <TData = Awaited<ReturnType<typeof retrievePoll>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrievePoll>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrievePollQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrievePoll>>> = ({ signal }) => retrievePoll({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrievePoll>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrievePollQueryResult = NonNullable<Awaited<ReturnType<typeof retrievePoll>>>
export type RetrievePollQueryError = AxiosError<unknown>

/**
 * @summary get the active poll
 */
export const useRetrievePoll = <TData = Awaited<ReturnType<typeof retrievePoll>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrievePoll>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrievePollQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary add a new poll
 */
export const addPoll = (
    pollModelUpdateV1: PollModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/poll`,
      pollModelUpdateV1,options
    );
  }



export const getAddPollMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addPoll>>, TError,{data: PollModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addPoll>>, TError,{data: PollModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addPoll>>, {data: PollModelUpdateV1}> = (props) => {
          const {data} = props ?? {};

          return  addPoll(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddPollMutationResult = NonNullable<Awaited<ReturnType<typeof addPoll>>>
    export type AddPollMutationBody = PollModelUpdateV1
    export type AddPollMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary add a new poll
 */
export const useAddPoll = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addPoll>>, TError,{data: PollModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof addPoll>>,
        TError,
        {data: PollModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getAddPollMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary archive the active poll
 */
export const archivePoll = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.delete(
      `https://api.mangaupdates.com/v1/poll`,options
    );
  }



export const getArchivePollMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof archivePoll>>, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof archivePoll>>, TError,void, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof archivePoll>>, void> = () => {
          

          return  archivePoll(axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ArchivePollMutationResult = NonNullable<Awaited<ReturnType<typeof archivePoll>>>
    
    export type ArchivePollMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary archive the active poll
 */
export const useArchivePoll = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof archivePoll>>, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof archivePoll>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getArchivePollMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary get old polls
 */
export const retrieveOldPolls = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/poll/old`,options
    );
  }


export const getRetrieveOldPollsQueryKey = () => {
    return [`https://api.mangaupdates.com/v1/poll/old`] as const;
    }

    
export const getRetrieveOldPollsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveOldPolls>>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveOldPolls>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveOldPollsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveOldPolls>>> = ({ signal }) => retrieveOldPolls({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveOldPolls>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveOldPollsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveOldPolls>>>
export type RetrieveOldPollsInfiniteQueryError = AxiosError<unknown>

/**
 * @summary get old polls
 */
export const useRetrieveOldPollsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveOldPolls>>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveOldPolls>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveOldPollsInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveOldPollsQueryOptions = <TData = Awaited<ReturnType<typeof retrieveOldPolls>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveOldPolls>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveOldPollsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveOldPolls>>> = ({ signal }) => retrieveOldPolls({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveOldPolls>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveOldPollsQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveOldPolls>>>
export type RetrieveOldPollsQueryError = AxiosError<unknown>

/**
 * @summary get old polls
 */
export const useRetrieveOldPolls = <TData = Awaited<ReturnType<typeof retrieveOldPolls>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveOldPolls>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveOldPollsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary vote in a poll
 */
export const votePollNoAnswer = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/poll/vote`,undefined,options
    );
  }



export const getVotePollNoAnswerMutationOptions = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof votePollNoAnswer>>, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof votePollNoAnswer>>, TError,void, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof votePollNoAnswer>>, void> = () => {
          

          return  votePollNoAnswer(axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type VotePollNoAnswerMutationResult = NonNullable<Awaited<ReturnType<typeof votePollNoAnswer>>>
    
    export type VotePollNoAnswerMutationError = AxiosError<ApiResponseV1>

    /**
 * @summary vote in a poll
 */
export const useVotePollNoAnswer = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof votePollNoAnswer>>, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof votePollNoAnswer>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getVotePollNoAnswerMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary vote in a poll answer
 */
export const votePollAnswer = (
    answerId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/poll/vote/${answerId}`,undefined,options
    );
  }



export const getVotePollAnswerMutationOptions = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof votePollAnswer>>, TError,{answerId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof votePollAnswer>>, TError,{answerId: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof votePollAnswer>>, {answerId: number}> = (props) => {
          const {answerId} = props ?? {};

          return  votePollAnswer(answerId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type VotePollAnswerMutationResult = NonNullable<Awaited<ReturnType<typeof votePollAnswer>>>
    
    export type VotePollAnswerMutationError = AxiosError<ApiResponseV1>

    /**
 * @summary vote in a poll answer
 */
export const useVotePollAnswer = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof votePollAnswer>>, TError,{answerId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof votePollAnswer>>,
        TError,
        {answerId: number},
        TContext
      > => {

      const mutationOptions = getVotePollAnswerMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary get information about whether the user has voted
 */
export const retrieveVoteStatus = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PollVoteStatusModelV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/poll/vote/status`,options
    );
  }


export const getRetrieveVoteStatusQueryKey = () => {
    return [`https://api.mangaupdates.com/v1/poll/vote/status`] as const;
    }

    
export const getRetrieveVoteStatusInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveVoteStatus>>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveVoteStatus>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveVoteStatusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveVoteStatus>>> = ({ signal }) => retrieveVoteStatus({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveVoteStatus>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveVoteStatusInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveVoteStatus>>>
export type RetrieveVoteStatusInfiniteQueryError = AxiosError<unknown>

/**
 * @summary get information about whether the user has voted
 */
export const useRetrieveVoteStatusInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveVoteStatus>>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveVoteStatus>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveVoteStatusInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveVoteStatusQueryOptions = <TData = Awaited<ReturnType<typeof retrieveVoteStatus>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveVoteStatus>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveVoteStatusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveVoteStatus>>> = ({ signal }) => retrieveVoteStatus({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveVoteStatus>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveVoteStatusQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveVoteStatus>>>
export type RetrieveVoteStatusQueryError = AxiosError<unknown>

/**
 * @summary get information about whether the user has voted
 */
export const useRetrieveVoteStatus = <TData = Awaited<ReturnType<typeof retrieveVoteStatus>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveVoteStatus>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveVoteStatusQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary add an publisher
 */
export const addPublisher = (
    publishersModelUpdateV1: PublishersModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/publishers`,
      publishersModelUpdateV1,options
    );
  }



export const getAddPublisherMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addPublisher>>, TError,{data: PublishersModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addPublisher>>, TError,{data: PublishersModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addPublisher>>, {data: PublishersModelUpdateV1}> = (props) => {
          const {data} = props ?? {};

          return  addPublisher(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddPublisherMutationResult = NonNullable<Awaited<ReturnType<typeof addPublisher>>>
    export type AddPublisherMutationBody = PublishersModelUpdateV1
    export type AddPublisherMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary add an publisher
 */
export const useAddPublisher = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addPublisher>>, TError,{data: PublishersModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof addPublisher>>,
        TError,
        {data: PublishersModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getAddPublisherMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary get a specific publisher
 */
export const retrievePublisher = (
    id: number,
    params?: RetrievePublisherParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PublishersModelV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/publishers/${id}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getRetrievePublisherQueryKey = (id: number,
    params?: RetrievePublisherParams,) => {
    return [`https://api.mangaupdates.com/v1/publishers/${id}`, ...(params ? [params]: [])] as const;
    }

    
export const getRetrievePublisherInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrievePublisher>>>, TError = AxiosError<void>>(id: number,
    params?: RetrievePublisherParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrievePublisher>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrievePublisherQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrievePublisher>>> = ({ signal }) => retrievePublisher(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrievePublisher>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrievePublisherInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrievePublisher>>>
export type RetrievePublisherInfiniteQueryError = AxiosError<void>

/**
 * @summary get a specific publisher
 */
export const useRetrievePublisherInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrievePublisher>>>, TError = AxiosError<void>>(
 id: number,
    params?: RetrievePublisherParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrievePublisher>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrievePublisherInfiniteQueryOptions(id,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrievePublisherQueryOptions = <TData = Awaited<ReturnType<typeof retrievePublisher>>, TError = AxiosError<void>>(id: number,
    params?: RetrievePublisherParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrievePublisher>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrievePublisherQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrievePublisher>>> = ({ signal }) => retrievePublisher(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrievePublisher>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrievePublisherQueryResult = NonNullable<Awaited<ReturnType<typeof retrievePublisher>>>
export type RetrievePublisherQueryError = AxiosError<void>

/**
 * @summary get a specific publisher
 */
export const useRetrievePublisher = <TData = Awaited<ReturnType<typeof retrievePublisher>>, TError = AxiosError<void>>(
 id: number,
    params?: RetrievePublisherParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrievePublisher>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrievePublisherQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary delete a publisher
 */
export const deletePublisher = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.delete(
      `https://api.mangaupdates.com/v1/publishers/${id}`,options
    );
  }



export const getDeletePublisherMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePublisher>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deletePublisher>>, TError,{id: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePublisher>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deletePublisher(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePublisherMutationResult = NonNullable<Awaited<ReturnType<typeof deletePublisher>>>
    
    export type DeletePublisherMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary delete a publisher
 */
export const useDeletePublisher = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePublisher>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deletePublisher>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeletePublisherMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary update a publisher
 */
export const updatePublisher = (
    id: number,
    publishersModelUpdateV1: PublishersModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.patch(
      `https://api.mangaupdates.com/v1/publishers/${id}`,
      publishersModelUpdateV1,options
    );
  }



export const getUpdatePublisherMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePublisher>>, TError,{id: number;data: PublishersModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updatePublisher>>, TError,{id: number;data: PublishersModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePublisher>>, {id: number;data: PublishersModelUpdateV1}> = (props) => {
          const {id,data} = props ?? {};

          return  updatePublisher(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePublisherMutationResult = NonNullable<Awaited<ReturnType<typeof updatePublisher>>>
    export type UpdatePublisherMutationBody = PublishersModelUpdateV1
    export type UpdatePublisherMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary update a publisher
 */
export const useUpdatePublisher = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePublisher>>, TError,{id: number;data: PublishersModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof updatePublisher>>,
        TError,
        {id: number;data: PublishersModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getUpdatePublisherMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary search publishers
 */
export const searchPublishersPost = (
    publishersSearchRequestV1: PublishersSearchRequestV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PublishersSearchResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/publishers/search`,
      publishersSearchRequestV1,options
    );
  }



export const getSearchPublishersPostMutationOptions = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchPublishersPost>>, TError,{data: PublishersSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof searchPublishersPost>>, TError,{data: PublishersSearchRequestV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchPublishersPost>>, {data: PublishersSearchRequestV1}> = (props) => {
          const {data} = props ?? {};

          return  searchPublishersPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchPublishersPostMutationResult = NonNullable<Awaited<ReturnType<typeof searchPublishersPost>>>
    export type SearchPublishersPostMutationBody = PublishersSearchRequestV1
    export type SearchPublishersPostMutationError = AxiosError<ApiResponseV1>

    /**
 * @summary search publishers
 */
export const useSearchPublishersPost = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchPublishersPost>>, TError,{data: PublishersSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof searchPublishersPost>>,
        TError,
        {data: PublishersSearchRequestV1},
        TContext
      > => {

      const mutationOptions = getSearchPublishersPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary get the list of series for a specific publisher
 */
export const retrievePublisherSeries = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PublishersSeriesListResponseV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/publishers/${id}/series`,options
    );
  }


export const getRetrievePublisherSeriesQueryKey = (id: number,) => {
    return [`https://api.mangaupdates.com/v1/publishers/${id}/series`] as const;
    }

    
export const getRetrievePublisherSeriesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrievePublisherSeries>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrievePublisherSeries>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrievePublisherSeriesQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrievePublisherSeries>>> = ({ signal }) => retrievePublisherSeries(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrievePublisherSeries>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrievePublisherSeriesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrievePublisherSeries>>>
export type RetrievePublisherSeriesInfiniteQueryError = AxiosError<void>

/**
 * @summary get the list of series for a specific publisher
 */
export const useRetrievePublisherSeriesInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrievePublisherSeries>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrievePublisherSeries>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrievePublisherSeriesInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrievePublisherSeriesQueryOptions = <TData = Awaited<ReturnType<typeof retrievePublisherSeries>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrievePublisherSeries>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrievePublisherSeriesQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrievePublisherSeries>>> = ({ signal }) => retrievePublisherSeries(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrievePublisherSeries>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrievePublisherSeriesQueryResult = NonNullable<Awaited<ReturnType<typeof retrievePublisherSeries>>>
export type RetrievePublisherSeriesQueryError = AxiosError<void>

/**
 * @summary get the list of series for a specific publisher
 */
export const useRetrievePublisherSeries = <TData = Awaited<ReturnType<typeof retrievePublisherSeries>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrievePublisherSeries>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrievePublisherSeriesQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary get the list of series for a specific publication
 */
export const retrievePublicationSeries = (
    params: RetrievePublicationSeriesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PublishersPublicationResponseV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/publishers/publication`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getRetrievePublicationSeriesQueryKey = (params: RetrievePublicationSeriesParams,) => {
    return [`https://api.mangaupdates.com/v1/publishers/publication`, ...(params ? [params]: [])] as const;
    }

    
export const getRetrievePublicationSeriesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrievePublicationSeries>>>, TError = AxiosError<ApiResponseV1 | void>>(params: RetrievePublicationSeriesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrievePublicationSeries>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrievePublicationSeriesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrievePublicationSeries>>> = ({ signal }) => retrievePublicationSeries(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrievePublicationSeries>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrievePublicationSeriesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrievePublicationSeries>>>
export type RetrievePublicationSeriesInfiniteQueryError = AxiosError<ApiResponseV1 | void>

/**
 * @summary get the list of series for a specific publication
 */
export const useRetrievePublicationSeriesInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrievePublicationSeries>>>, TError = AxiosError<ApiResponseV1 | void>>(
 params: RetrievePublicationSeriesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrievePublicationSeries>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrievePublicationSeriesInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrievePublicationSeriesQueryOptions = <TData = Awaited<ReturnType<typeof retrievePublicationSeries>>, TError = AxiosError<ApiResponseV1 | void>>(params: RetrievePublicationSeriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrievePublicationSeries>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrievePublicationSeriesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrievePublicationSeries>>> = ({ signal }) => retrievePublicationSeries(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrievePublicationSeries>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrievePublicationSeriesQueryResult = NonNullable<Awaited<ReturnType<typeof retrievePublicationSeries>>>
export type RetrievePublicationSeriesQueryError = AxiosError<ApiResponseV1 | void>

/**
 * @summary get the list of series for a specific publication
 */
export const useRetrievePublicationSeries = <TData = Awaited<ReturnType<typeof retrievePublicationSeries>>, TError = AxiosError<ApiResponseV1 | void>>(
 params: RetrievePublicationSeriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrievePublicationSeries>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrievePublicationSeriesQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary add an release
 */
export const addRelease = (
    releaseModelUpdateV1: ReleaseModelUpdateV1[], options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/releases`,
      releaseModelUpdateV1,options
    );
  }



export const getAddReleaseMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addRelease>>, TError,{data: ReleaseModelUpdateV1[]}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addRelease>>, TError,{data: ReleaseModelUpdateV1[]}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addRelease>>, {data: ReleaseModelUpdateV1[]}> = (props) => {
          const {data} = props ?? {};

          return  addRelease(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddReleaseMutationResult = NonNullable<Awaited<ReturnType<typeof addRelease>>>
    export type AddReleaseMutationBody = ReleaseModelUpdateV1[]
    export type AddReleaseMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary add an release
 */
export const useAddRelease = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addRelease>>, TError,{data: ReleaseModelUpdateV1[]}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof addRelease>>,
        TError,
        {data: ReleaseModelUpdateV1[]},
        TContext
      > => {

      const mutationOptions = getAddReleaseMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary get a specific release
 */
export const retrieveRelease = (
    id: number,
    params?: RetrieveReleaseParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ReleaseModelV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/releases/${id}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getRetrieveReleaseQueryKey = (id: number,
    params?: RetrieveReleaseParams,) => {
    return [`https://api.mangaupdates.com/v1/releases/${id}`, ...(params ? [params]: [])] as const;
    }

    
export const getRetrieveReleaseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveRelease>>>, TError = AxiosError<void>>(id: number,
    params?: RetrieveReleaseParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveRelease>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveReleaseQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveRelease>>> = ({ signal }) => retrieveRelease(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveRelease>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveReleaseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveRelease>>>
export type RetrieveReleaseInfiniteQueryError = AxiosError<void>

/**
 * @summary get a specific release
 */
export const useRetrieveReleaseInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveRelease>>>, TError = AxiosError<void>>(
 id: number,
    params?: RetrieveReleaseParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveRelease>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveReleaseInfiniteQueryOptions(id,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveReleaseQueryOptions = <TData = Awaited<ReturnType<typeof retrieveRelease>>, TError = AxiosError<void>>(id: number,
    params?: RetrieveReleaseParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveRelease>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveReleaseQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveRelease>>> = ({ signal }) => retrieveRelease(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveRelease>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveReleaseQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveRelease>>>
export type RetrieveReleaseQueryError = AxiosError<void>

/**
 * @summary get a specific release
 */
export const useRetrieveRelease = <TData = Awaited<ReturnType<typeof retrieveRelease>>, TError = AxiosError<void>>(
 id: number,
    params?: RetrieveReleaseParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveRelease>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveReleaseQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary delete a release
 */
export const deleteRelease = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.delete(
      `https://api.mangaupdates.com/v1/releases/${id}`,options
    );
  }



export const getDeleteReleaseMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRelease>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteRelease>>, TError,{id: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteRelease>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteRelease(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteReleaseMutationResult = NonNullable<Awaited<ReturnType<typeof deleteRelease>>>
    
    export type DeleteReleaseMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary delete a release
 */
export const useDeleteRelease = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRelease>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteRelease>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteReleaseMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary update an release
 */
export const updateRelease = (
    id: number,
    releaseModelUpdateV1: ReleaseModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.patch(
      `https://api.mangaupdates.com/v1/releases/${id}`,
      releaseModelUpdateV1,options
    );
  }



export const getUpdateReleaseMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRelease>>, TError,{id: number;data: ReleaseModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateRelease>>, TError,{id: number;data: ReleaseModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateRelease>>, {id: number;data: ReleaseModelUpdateV1}> = (props) => {
          const {id,data} = props ?? {};

          return  updateRelease(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateReleaseMutationResult = NonNullable<Awaited<ReturnType<typeof updateRelease>>>
    export type UpdateReleaseMutationBody = ReleaseModelUpdateV1
    export type UpdateReleaseMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary update an release
 */
export const useUpdateRelease = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRelease>>, TError,{id: number;data: ReleaseModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof updateRelease>>,
        TError,
        {id: number;data: ReleaseModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getUpdateReleaseMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary search releases to moderate
 */
export const moderateReleasesPost = (
    releaseModerateRequestV1: ReleaseModerateRequestV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ReleaseModerateResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/releases/moderate`,
      releaseModerateRequestV1,options
    );
  }



export const getModerateReleasesPostMutationOptions = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof moderateReleasesPost>>, TError,{data: ReleaseModerateRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof moderateReleasesPost>>, TError,{data: ReleaseModerateRequestV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof moderateReleasesPost>>, {data: ReleaseModerateRequestV1}> = (props) => {
          const {data} = props ?? {};

          return  moderateReleasesPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ModerateReleasesPostMutationResult = NonNullable<Awaited<ReturnType<typeof moderateReleasesPost>>>
    export type ModerateReleasesPostMutationBody = ReleaseModerateRequestV1
    export type ModerateReleasesPostMutationError = AxiosError<ApiResponseV1>

    /**
 * @summary search releases to moderate
 */
export const useModerateReleasesPost = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof moderateReleasesPost>>, TError,{data: ReleaseModerateRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof moderateReleasesPost>>,
        TError,
        {data: ReleaseModerateRequestV1},
        TContext
      > => {

      const mutationOptions = getModerateReleasesPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary show releases by day
 */
export const listReleasesByDay = (
    params?: ListReleasesByDayParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ReleaseSearchResponseV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/releases/days`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getListReleasesByDayQueryKey = (params?: ListReleasesByDayParams,) => {
    return [`https://api.mangaupdates.com/v1/releases/days`, ...(params ? [params]: [])] as const;
    }

    
export const getListReleasesByDayInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof listReleasesByDay>>>, TError = AxiosError<unknown>>(params?: ListReleasesByDayParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof listReleasesByDay>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListReleasesByDayQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listReleasesByDay>>> = ({ signal }) => listReleasesByDay(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof listReleasesByDay>>, TError, TData> & { queryKey: QueryKey }
}

export type ListReleasesByDayInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof listReleasesByDay>>>
export type ListReleasesByDayInfiniteQueryError = AxiosError<unknown>

/**
 * @summary show releases by day
 */
export const useListReleasesByDayInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof listReleasesByDay>>>, TError = AxiosError<unknown>>(
 params?: ListReleasesByDayParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof listReleasesByDay>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getListReleasesByDayInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getListReleasesByDayQueryOptions = <TData = Awaited<ReturnType<typeof listReleasesByDay>>, TError = AxiosError<unknown>>(params?: ListReleasesByDayParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listReleasesByDay>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListReleasesByDayQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listReleasesByDay>>> = ({ signal }) => listReleasesByDay(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listReleasesByDay>>, TError, TData> & { queryKey: QueryKey }
}

export type ListReleasesByDayQueryResult = NonNullable<Awaited<ReturnType<typeof listReleasesByDay>>>
export type ListReleasesByDayQueryError = AxiosError<unknown>

/**
 * @summary show releases by day
 */
export const useListReleasesByDay = <TData = Awaited<ReturnType<typeof listReleasesByDay>>, TError = AxiosError<unknown>>(
 params?: ListReleasesByDayParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listReleasesByDay>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getListReleasesByDayQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary releases rss feed
 */
export const releaseRssFeed = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/releases/rss`,options
    );
  }


export const getReleaseRssFeedQueryKey = () => {
    return [`https://api.mangaupdates.com/v1/releases/rss`] as const;
    }

    
export const getReleaseRssFeedInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof releaseRssFeed>>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof releaseRssFeed>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReleaseRssFeedQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof releaseRssFeed>>> = ({ signal }) => releaseRssFeed({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof releaseRssFeed>>, TError, TData> & { queryKey: QueryKey }
}

export type ReleaseRssFeedInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof releaseRssFeed>>>
export type ReleaseRssFeedInfiniteQueryError = AxiosError<unknown>

/**
 * @summary releases rss feed
 */
export const useReleaseRssFeedInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof releaseRssFeed>>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof releaseRssFeed>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getReleaseRssFeedInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getReleaseRssFeedQueryOptions = <TData = Awaited<ReturnType<typeof releaseRssFeed>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof releaseRssFeed>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReleaseRssFeedQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof releaseRssFeed>>> = ({ signal }) => releaseRssFeed({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof releaseRssFeed>>, TError, TData> & { queryKey: QueryKey }
}

export type ReleaseRssFeedQueryResult = NonNullable<Awaited<ReturnType<typeof releaseRssFeed>>>
export type ReleaseRssFeedQueryError = AxiosError<unknown>

/**
 * @summary releases rss feed
 */
export const useReleaseRssFeed = <TData = Awaited<ReturnType<typeof releaseRssFeed>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof releaseRssFeed>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getReleaseRssFeedQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary search releases
 */
export const searchReleasesPost = (
    releaseSearchRequestV1: ReleaseSearchRequestV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ReleaseSearchResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/releases/search`,
      releaseSearchRequestV1,options
    );
  }



export const getSearchReleasesPostMutationOptions = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchReleasesPost>>, TError,{data: ReleaseSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof searchReleasesPost>>, TError,{data: ReleaseSearchRequestV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchReleasesPost>>, {data: ReleaseSearchRequestV1}> = (props) => {
          const {data} = props ?? {};

          return  searchReleasesPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchReleasesPostMutationResult = NonNullable<Awaited<ReturnType<typeof searchReleasesPost>>>
    export type SearchReleasesPostMutationBody = ReleaseSearchRequestV1
    export type SearchReleasesPostMutationError = AxiosError<ApiResponseV1>

    /**
 * @summary search releases
 */
export const useSearchReleasesPost = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchReleasesPost>>, TError,{data: ReleaseSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof searchReleasesPost>>,
        TError,
        {data: ReleaseSearchRequestV1},
        TContext
      > => {

      const mutationOptions = getSearchReleasesPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary add a review
 */
export const addReview = (
    reviewModelUpdateV1: ReviewModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/reviews`,
      reviewModelUpdateV1,options
    );
  }



export const getAddReviewMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addReview>>, TError,{data: ReviewModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addReview>>, TError,{data: ReviewModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addReview>>, {data: ReviewModelUpdateV1}> = (props) => {
          const {data} = props ?? {};

          return  addReview(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddReviewMutationResult = NonNullable<Awaited<ReturnType<typeof addReview>>>
    export type AddReviewMutationBody = ReviewModelUpdateV1
    export type AddReviewMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary add a review
 */
export const useAddReview = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addReview>>, TError,{data: ReviewModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof addReview>>,
        TError,
        {data: ReviewModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getAddReviewMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary add a review comment
 */
export const addReviewComment = (
    id: number,
    reviewCommentModelUpdateV1: ReviewCommentModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/reviews/${id}/comments`,
      reviewCommentModelUpdateV1,options
    );
  }



export const getAddReviewCommentMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addReviewComment>>, TError,{id: number;data: ReviewCommentModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addReviewComment>>, TError,{id: number;data: ReviewCommentModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addReviewComment>>, {id: number;data: ReviewCommentModelUpdateV1}> = (props) => {
          const {id,data} = props ?? {};

          return  addReviewComment(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddReviewCommentMutationResult = NonNullable<Awaited<ReturnType<typeof addReviewComment>>>
    export type AddReviewCommentMutationBody = ReviewCommentModelUpdateV1
    export type AddReviewCommentMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary add a review comment
 */
export const useAddReviewComment = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addReviewComment>>, TError,{id: number;data: ReviewCommentModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof addReviewComment>>,
        TError,
        {id: number;data: ReviewCommentModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getAddReviewCommentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary get a specific review comment
 */
export const retrieveReviewComment = (
    id: number,
    commentId: number,
    params?: RetrieveReviewCommentParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ReviewCommentModelV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/reviews/${id}/comments/${commentId}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getRetrieveReviewCommentQueryKey = (id: number,
    commentId: number,
    params?: RetrieveReviewCommentParams,) => {
    return [`https://api.mangaupdates.com/v1/reviews/${id}/comments/${commentId}`, ...(params ? [params]: [])] as const;
    }

    
export const getRetrieveReviewCommentInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveReviewComment>>>, TError = AxiosError<void>>(id: number,
    commentId: number,
    params?: RetrieveReviewCommentParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveReviewComment>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveReviewCommentQueryKey(id,commentId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveReviewComment>>> = ({ signal }) => retrieveReviewComment(id,commentId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id && commentId),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveReviewComment>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveReviewCommentInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveReviewComment>>>
export type RetrieveReviewCommentInfiniteQueryError = AxiosError<void>

/**
 * @summary get a specific review comment
 */
export const useRetrieveReviewCommentInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveReviewComment>>>, TError = AxiosError<void>>(
 id: number,
    commentId: number,
    params?: RetrieveReviewCommentParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveReviewComment>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveReviewCommentInfiniteQueryOptions(id,commentId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveReviewCommentQueryOptions = <TData = Awaited<ReturnType<typeof retrieveReviewComment>>, TError = AxiosError<void>>(id: number,
    commentId: number,
    params?: RetrieveReviewCommentParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveReviewComment>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveReviewCommentQueryKey(id,commentId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveReviewComment>>> = ({ signal }) => retrieveReviewComment(id,commentId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id && commentId),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveReviewComment>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveReviewCommentQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveReviewComment>>>
export type RetrieveReviewCommentQueryError = AxiosError<void>

/**
 * @summary get a specific review comment
 */
export const useRetrieveReviewComment = <TData = Awaited<ReturnType<typeof retrieveReviewComment>>, TError = AxiosError<void>>(
 id: number,
    commentId: number,
    params?: RetrieveReviewCommentParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveReviewComment>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveReviewCommentQueryOptions(id,commentId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary delete a review comment
 */
export const deleteReviewComment = (
    id: number,
    commentId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.delete(
      `https://api.mangaupdates.com/v1/reviews/${id}/comments/${commentId}`,options
    );
  }



export const getDeleteReviewCommentMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteReviewComment>>, TError,{id: number;commentId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteReviewComment>>, TError,{id: number;commentId: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteReviewComment>>, {id: number;commentId: number}> = (props) => {
          const {id,commentId} = props ?? {};

          return  deleteReviewComment(id,commentId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteReviewCommentMutationResult = NonNullable<Awaited<ReturnType<typeof deleteReviewComment>>>
    
    export type DeleteReviewCommentMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary delete a review comment
 */
export const useDeleteReviewComment = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteReviewComment>>, TError,{id: number;commentId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteReviewComment>>,
        TError,
        {id: number;commentId: number},
        TContext
      > => {

      const mutationOptions = getDeleteReviewCommentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary update a review comment
 */
export const updateReviewComment = (
    id: number,
    commentId: number,
    reviewCommentModelUpdateV1: ReviewCommentModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.patch(
      `https://api.mangaupdates.com/v1/reviews/${id}/comments/${commentId}`,
      reviewCommentModelUpdateV1,options
    );
  }



export const getUpdateReviewCommentMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateReviewComment>>, TError,{id: number;commentId: number;data: ReviewCommentModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateReviewComment>>, TError,{id: number;commentId: number;data: ReviewCommentModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateReviewComment>>, {id: number;commentId: number;data: ReviewCommentModelUpdateV1}> = (props) => {
          const {id,commentId,data} = props ?? {};

          return  updateReviewComment(id,commentId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateReviewCommentMutationResult = NonNullable<Awaited<ReturnType<typeof updateReviewComment>>>
    export type UpdateReviewCommentMutationBody = ReviewCommentModelUpdateV1
    export type UpdateReviewCommentMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary update a review comment
 */
export const useUpdateReviewComment = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateReviewComment>>, TError,{id: number;commentId: number;data: ReviewCommentModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof updateReviewComment>>,
        TError,
        {id: number;commentId: number;data: ReviewCommentModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getUpdateReviewCommentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary moderate review comments
 */
export const reviewCommentsModerationPost = (
    reviewCommentSearchRequestV1: ReviewCommentSearchRequestV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ReviewCommentSearchResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/reviews/comments/moderation`,
      reviewCommentSearchRequestV1,options
    );
  }



export const getReviewCommentsModerationPostMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof reviewCommentsModerationPost>>, TError,{data: ReviewCommentSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof reviewCommentsModerationPost>>, TError,{data: ReviewCommentSearchRequestV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof reviewCommentsModerationPost>>, {data: ReviewCommentSearchRequestV1}> = (props) => {
          const {data} = props ?? {};

          return  reviewCommentsModerationPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ReviewCommentsModerationPostMutationResult = NonNullable<Awaited<ReturnType<typeof reviewCommentsModerationPost>>>
    export type ReviewCommentsModerationPostMutationBody = ReviewCommentSearchRequestV1
    export type ReviewCommentsModerationPostMutationError = AxiosError<unknown>

    /**
 * @summary moderate review comments
 */
export const useReviewCommentsModerationPost = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof reviewCommentsModerationPost>>, TError,{data: ReviewCommentSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof reviewCommentsModerationPost>>,
        TError,
        {data: ReviewCommentSearchRequestV1},
        TContext
      > => {

      const mutationOptions = getReviewCommentsModerationPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary search review comments
 */
export const searchReviewCommentsPost = (
    id: number,
    reviewCommentSearchRequestV1: ReviewCommentSearchRequestV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ReviewCommentSearchResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/reviews/${id}/comments/search`,
      reviewCommentSearchRequestV1,options
    );
  }



export const getSearchReviewCommentsPostMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchReviewCommentsPost>>, TError,{id: number;data: ReviewCommentSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof searchReviewCommentsPost>>, TError,{id: number;data: ReviewCommentSearchRequestV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchReviewCommentsPost>>, {id: number;data: ReviewCommentSearchRequestV1}> = (props) => {
          const {id,data} = props ?? {};

          return  searchReviewCommentsPost(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchReviewCommentsPostMutationResult = NonNullable<Awaited<ReturnType<typeof searchReviewCommentsPost>>>
    export type SearchReviewCommentsPostMutationBody = ReviewCommentSearchRequestV1
    export type SearchReviewCommentsPostMutationError = AxiosError<unknown>

    /**
 * @summary search review comments
 */
export const useSearchReviewCommentsPost = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchReviewCommentsPost>>, TError,{id: number;data: ReviewCommentSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof searchReviewCommentsPost>>,
        TError,
        {id: number;data: ReviewCommentSearchRequestV1},
        TContext
      > => {

      const mutationOptions = getSearchReviewCommentsPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary get a specific review
 */
export const retrieveReview = (
    id: number,
    params?: RetrieveReviewParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ReviewModelV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/reviews/${id}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getRetrieveReviewQueryKey = (id: number,
    params?: RetrieveReviewParams,) => {
    return [`https://api.mangaupdates.com/v1/reviews/${id}`, ...(params ? [params]: [])] as const;
    }

    
export const getRetrieveReviewInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveReview>>>, TError = AxiosError<void>>(id: number,
    params?: RetrieveReviewParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveReview>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveReviewQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveReview>>> = ({ signal }) => retrieveReview(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveReview>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveReviewInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveReview>>>
export type RetrieveReviewInfiniteQueryError = AxiosError<void>

/**
 * @summary get a specific review
 */
export const useRetrieveReviewInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveReview>>>, TError = AxiosError<void>>(
 id: number,
    params?: RetrieveReviewParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveReview>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveReviewInfiniteQueryOptions(id,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveReviewQueryOptions = <TData = Awaited<ReturnType<typeof retrieveReview>>, TError = AxiosError<void>>(id: number,
    params?: RetrieveReviewParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveReview>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveReviewQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveReview>>> = ({ signal }) => retrieveReview(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveReview>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveReviewQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveReview>>>
export type RetrieveReviewQueryError = AxiosError<void>

/**
 * @summary get a specific review
 */
export const useRetrieveReview = <TData = Awaited<ReturnType<typeof retrieveReview>>, TError = AxiosError<void>>(
 id: number,
    params?: RetrieveReviewParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveReview>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveReviewQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary delete a review
 */
export const deleteReview = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.delete(
      `https://api.mangaupdates.com/v1/reviews/${id}`,options
    );
  }



export const getDeleteReviewMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteReview>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteReview>>, TError,{id: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteReview>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteReview(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteReviewMutationResult = NonNullable<Awaited<ReturnType<typeof deleteReview>>>
    
    export type DeleteReviewMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary delete a review
 */
export const useDeleteReview = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteReview>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteReview>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteReviewMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary update a review
 */
export const updateReview = (
    id: number,
    reviewModelUpdateV1: ReviewModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.patch(
      `https://api.mangaupdates.com/v1/reviews/${id}`,
      reviewModelUpdateV1,options
    );
  }



export const getUpdateReviewMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateReview>>, TError,{id: number;data: ReviewModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateReview>>, TError,{id: number;data: ReviewModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateReview>>, {id: number;data: ReviewModelUpdateV1}> = (props) => {
          const {id,data} = props ?? {};

          return  updateReview(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateReviewMutationResult = NonNullable<Awaited<ReturnType<typeof updateReview>>>
    export type UpdateReviewMutationBody = ReviewModelUpdateV1
    export type UpdateReviewMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary update a review
 */
export const useUpdateReview = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateReview>>, TError,{id: number;data: ReviewModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof updateReview>>,
        TError,
        {id: number;data: ReviewModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getUpdateReviewMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary search reviews
 */
export const searchReviewsPost = (
    reviewSearchRequestV1: ReviewSearchRequestV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ReviewSearchResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/reviews/search`,
      reviewSearchRequestV1,options
    );
  }



export const getSearchReviewsPostMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchReviewsPost>>, TError,{data: ReviewSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof searchReviewsPost>>, TError,{data: ReviewSearchRequestV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchReviewsPost>>, {data: ReviewSearchRequestV1}> = (props) => {
          const {data} = props ?? {};

          return  searchReviewsPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchReviewsPostMutationResult = NonNullable<Awaited<ReturnType<typeof searchReviewsPost>>>
    export type SearchReviewsPostMutationBody = ReviewSearchRequestV1
    export type SearchReviewsPostMutationError = AxiosError<unknown>

    /**
 * @summary search reviews
 */
export const useSearchReviewsPost = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchReviewsPost>>, TError,{data: ReviewSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof searchReviewsPost>>,
        TError,
        {data: ReviewSearchRequestV1},
        TContext
      > => {

      const mutationOptions = getSearchReviewsPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary add an series
 */
export const addSeries = (
    seriesModelUpdateV1: SeriesModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/series`,
      seriesModelUpdateV1,options
    );
  }



export const getAddSeriesMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addSeries>>, TError,{data: SeriesModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addSeries>>, TError,{data: SeriesModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addSeries>>, {data: SeriesModelUpdateV1}> = (props) => {
          const {data} = props ?? {};

          return  addSeries(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddSeriesMutationResult = NonNullable<Awaited<ReturnType<typeof addSeries>>>
    export type AddSeriesMutationBody = SeriesModelUpdateV1
    export type AddSeriesMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary add an series
 */
export const useAddSeries = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addSeries>>, TError,{data: SeriesModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof addSeries>>,
        TError,
        {data: SeriesModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getAddSeriesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary combine two series categories
 */
export const combineSeriesCategories = (
    id: number,
    seriesCategoryUpdateModelV1: SeriesCategoryUpdateModelV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/series/${id}/categories/combine`,
      seriesCategoryUpdateModelV1,options
    );
  }



export const getCombineSeriesCategoriesMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof combineSeriesCategories>>, TError,{id: number;data: SeriesCategoryUpdateModelV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof combineSeriesCategories>>, TError,{id: number;data: SeriesCategoryUpdateModelV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof combineSeriesCategories>>, {id: number;data: SeriesCategoryUpdateModelV1}> = (props) => {
          const {id,data} = props ?? {};

          return  combineSeriesCategories(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CombineSeriesCategoriesMutationResult = NonNullable<Awaited<ReturnType<typeof combineSeriesCategories>>>
    export type CombineSeriesCategoriesMutationBody = SeriesCategoryUpdateModelV1
    export type CombineSeriesCategoriesMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary combine two series categories
 */
export const useCombineSeriesCategories = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof combineSeriesCategories>>, TError,{id: number;data: SeriesCategoryUpdateModelV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof combineSeriesCategories>>,
        TError,
        {id: number;data: SeriesCategoryUpdateModelV1},
        TContext
      > => {

      const mutationOptions = getCombineSeriesCategoriesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary deletes a series category
 */
export const deleteSeriesCategory = (
    id: number,
    categoriesModelUpdateV1: CategoriesModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/series/${id}/categories/delete`,
      categoriesModelUpdateV1,options
    );
  }



export const getDeleteSeriesCategoryMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSeriesCategory>>, TError,{id: number;data: CategoriesModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteSeriesCategory>>, TError,{id: number;data: CategoriesModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteSeriesCategory>>, {id: number;data: CategoriesModelUpdateV1}> = (props) => {
          const {id,data} = props ?? {};

          return  deleteSeriesCategory(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteSeriesCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSeriesCategory>>>
    export type DeleteSeriesCategoryMutationBody = CategoriesModelUpdateV1
    export type DeleteSeriesCategoryMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary deletes a series category
 */
export const useDeleteSeriesCategory = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSeriesCategory>>, TError,{id: number;data: CategoriesModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteSeriesCategory>>,
        TError,
        {id: number;data: CategoriesModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getDeleteSeriesCategoryMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary renames a series category
 */
export const renameSeriesCategory = (
    id: number,
    seriesCategoryUpdateModelV1: SeriesCategoryUpdateModelV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/series/${id}/categories/rename`,
      seriesCategoryUpdateModelV1,options
    );
  }



export const getRenameSeriesCategoryMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof renameSeriesCategory>>, TError,{id: number;data: SeriesCategoryUpdateModelV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof renameSeriesCategory>>, TError,{id: number;data: SeriesCategoryUpdateModelV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof renameSeriesCategory>>, {id: number;data: SeriesCategoryUpdateModelV1}> = (props) => {
          const {id,data} = props ?? {};

          return  renameSeriesCategory(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RenameSeriesCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof renameSeriesCategory>>>
    export type RenameSeriesCategoryMutationBody = SeriesCategoryUpdateModelV1
    export type RenameSeriesCategoryMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary renames a series category
 */
export const useRenameSeriesCategory = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof renameSeriesCategory>>, TError,{id: number;data: SeriesCategoryUpdateModelV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof renameSeriesCategory>>,
        TError,
        {id: number;data: SeriesCategoryUpdateModelV1},
        TContext
      > => {

      const mutationOptions = getRenameSeriesCategoryMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary get category votes for the current user
 */
export const retrieveSeriesCategoryVotes = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SeriesCategoryVoteModelV1[]>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/series/${id}/categories/votes`,options
    );
  }


export const getRetrieveSeriesCategoryVotesQueryKey = (id: number,) => {
    return [`https://api.mangaupdates.com/v1/series/${id}/categories/votes`] as const;
    }

    
export const getRetrieveSeriesCategoryVotesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveSeriesCategoryVotes>>>, TError = AxiosError<unknown>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveSeriesCategoryVotes>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveSeriesCategoryVotesQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveSeriesCategoryVotes>>> = ({ signal }) => retrieveSeriesCategoryVotes(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveSeriesCategoryVotes>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveSeriesCategoryVotesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveSeriesCategoryVotes>>>
export type RetrieveSeriesCategoryVotesInfiniteQueryError = AxiosError<unknown>

/**
 * @summary get category votes for the current user
 */
export const useRetrieveSeriesCategoryVotesInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveSeriesCategoryVotes>>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveSeriesCategoryVotes>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveSeriesCategoryVotesInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveSeriesCategoryVotesQueryOptions = <TData = Awaited<ReturnType<typeof retrieveSeriesCategoryVotes>>, TError = AxiosError<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveSeriesCategoryVotes>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveSeriesCategoryVotesQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveSeriesCategoryVotes>>> = ({ signal }) => retrieveSeriesCategoryVotes(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveSeriesCategoryVotes>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveSeriesCategoryVotesQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveSeriesCategoryVotes>>>
export type RetrieveSeriesCategoryVotesQueryError = AxiosError<unknown>

/**
 * @summary get category votes for the current user
 */
export const useRetrieveSeriesCategoryVotes = <TData = Awaited<ReturnType<typeof retrieveSeriesCategoryVotes>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveSeriesCategoryVotes>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveSeriesCategoryVotesQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary add a vote for a category on a series
 */
export const addSeriesCategoryVote = (
    id: number,
    seriesCategoryVoteModelV1: SeriesCategoryVoteModelV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/series/${id}/categories/vote`,
      seriesCategoryVoteModelV1,options
    );
  }



export const getAddSeriesCategoryVoteMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addSeriesCategoryVote>>, TError,{id: number;data: SeriesCategoryVoteModelV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addSeriesCategoryVote>>, TError,{id: number;data: SeriesCategoryVoteModelV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addSeriesCategoryVote>>, {id: number;data: SeriesCategoryVoteModelV1}> = (props) => {
          const {id,data} = props ?? {};

          return  addSeriesCategoryVote(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddSeriesCategoryVoteMutationResult = NonNullable<Awaited<ReturnType<typeof addSeriesCategoryVote>>>
    export type AddSeriesCategoryVoteMutationBody = SeriesCategoryVoteModelV1
    export type AddSeriesCategoryVoteMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary add a vote for a category on a series
 */
export const useAddSeriesCategoryVote = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addSeriesCategoryVote>>, TError,{id: number;data: SeriesCategoryVoteModelV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof addSeriesCategoryVote>>,
        TError,
        {id: number;data: SeriesCategoryVoteModelV1},
        TContext
      > => {

      const mutationOptions = getAddSeriesCategoryVoteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary remove series category vote for user
 */
export const removeSeriesCategoryVote = (
    id: number,
    seriesCategoryVoteDeleteModelV1: SeriesCategoryVoteDeleteModelV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/series/${id}/categories/vote/delete`,
      seriesCategoryVoteDeleteModelV1,options
    );
  }



export const getRemoveSeriesCategoryVoteMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeSeriesCategoryVote>>, TError,{id: number;data: SeriesCategoryVoteDeleteModelV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof removeSeriesCategoryVote>>, TError,{id: number;data: SeriesCategoryVoteDeleteModelV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeSeriesCategoryVote>>, {id: number;data: SeriesCategoryVoteDeleteModelV1}> = (props) => {
          const {id,data} = props ?? {};

          return  removeSeriesCategoryVote(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveSeriesCategoryVoteMutationResult = NonNullable<Awaited<ReturnType<typeof removeSeriesCategoryVote>>>
    export type RemoveSeriesCategoryVoteMutationBody = SeriesCategoryVoteDeleteModelV1
    export type RemoveSeriesCategoryVoteMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary remove series category vote for user
 */
export const useRemoveSeriesCategoryVote = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeSeriesCategoryVote>>, TError,{id: number;data: SeriesCategoryVoteDeleteModelV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof removeSeriesCategoryVote>>,
        TError,
        {id: number;data: SeriesCategoryVoteDeleteModelV1},
        TContext
      > => {

      const mutationOptions = getRemoveSeriesCategoryVoteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary add a series comment
 */
export const addSeriesComment = (
    id: number,
    seriesCommentModelUpdateV1: SeriesCommentModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/series/${id}/comments`,
      seriesCommentModelUpdateV1,options
    );
  }



export const getAddSeriesCommentMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addSeriesComment>>, TError,{id: number;data: SeriesCommentModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addSeriesComment>>, TError,{id: number;data: SeriesCommentModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addSeriesComment>>, {id: number;data: SeriesCommentModelUpdateV1}> = (props) => {
          const {id,data} = props ?? {};

          return  addSeriesComment(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddSeriesCommentMutationResult = NonNullable<Awaited<ReturnType<typeof addSeriesComment>>>
    export type AddSeriesCommentMutationBody = SeriesCommentModelUpdateV1
    export type AddSeriesCommentMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary add a series comment
 */
export const useAddSeriesComment = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addSeriesComment>>, TError,{id: number;data: SeriesCommentModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof addSeriesComment>>,
        TError,
        {id: number;data: SeriesCommentModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getAddSeriesCommentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary get a specific series comment
 */
export const retrieveSeriesComment = (
    id: number,
    commentId: number,
    params?: RetrieveSeriesCommentParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SeriesCommentModelV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/series/${id}/comments/${commentId}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getRetrieveSeriesCommentQueryKey = (id: number,
    commentId: number,
    params?: RetrieveSeriesCommentParams,) => {
    return [`https://api.mangaupdates.com/v1/series/${id}/comments/${commentId}`, ...(params ? [params]: [])] as const;
    }

    
export const getRetrieveSeriesCommentInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveSeriesComment>>>, TError = AxiosError<void>>(id: number,
    commentId: number,
    params?: RetrieveSeriesCommentParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveSeriesComment>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveSeriesCommentQueryKey(id,commentId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveSeriesComment>>> = ({ signal }) => retrieveSeriesComment(id,commentId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id && commentId),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveSeriesComment>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveSeriesCommentInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveSeriesComment>>>
export type RetrieveSeriesCommentInfiniteQueryError = AxiosError<void>

/**
 * @summary get a specific series comment
 */
export const useRetrieveSeriesCommentInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveSeriesComment>>>, TError = AxiosError<void>>(
 id: number,
    commentId: number,
    params?: RetrieveSeriesCommentParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveSeriesComment>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveSeriesCommentInfiniteQueryOptions(id,commentId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveSeriesCommentQueryOptions = <TData = Awaited<ReturnType<typeof retrieveSeriesComment>>, TError = AxiosError<void>>(id: number,
    commentId: number,
    params?: RetrieveSeriesCommentParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveSeriesComment>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveSeriesCommentQueryKey(id,commentId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveSeriesComment>>> = ({ signal }) => retrieveSeriesComment(id,commentId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id && commentId),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveSeriesComment>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveSeriesCommentQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveSeriesComment>>>
export type RetrieveSeriesCommentQueryError = AxiosError<void>

/**
 * @summary get a specific series comment
 */
export const useRetrieveSeriesComment = <TData = Awaited<ReturnType<typeof retrieveSeriesComment>>, TError = AxiosError<void>>(
 id: number,
    commentId: number,
    params?: RetrieveSeriesCommentParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveSeriesComment>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveSeriesCommentQueryOptions(id,commentId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary delete a series comment
 */
export const deleteSeriesComment = (
    id: number,
    commentId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.delete(
      `https://api.mangaupdates.com/v1/series/${id}/comments/${commentId}`,options
    );
  }



export const getDeleteSeriesCommentMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSeriesComment>>, TError,{id: number;commentId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteSeriesComment>>, TError,{id: number;commentId: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteSeriesComment>>, {id: number;commentId: number}> = (props) => {
          const {id,commentId} = props ?? {};

          return  deleteSeriesComment(id,commentId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteSeriesCommentMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSeriesComment>>>
    
    export type DeleteSeriesCommentMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary delete a series comment
 */
export const useDeleteSeriesComment = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSeriesComment>>, TError,{id: number;commentId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteSeriesComment>>,
        TError,
        {id: number;commentId: number},
        TContext
      > => {

      const mutationOptions = getDeleteSeriesCommentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary update a series comment
 */
export const updateSeriesComment = (
    id: number,
    commentId: number,
    seriesCommentModelUpdateV1: SeriesCommentModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.patch(
      `https://api.mangaupdates.com/v1/series/${id}/comments/${commentId}`,
      seriesCommentModelUpdateV1,options
    );
  }



export const getUpdateSeriesCommentMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSeriesComment>>, TError,{id: number;commentId: number;data: SeriesCommentModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateSeriesComment>>, TError,{id: number;commentId: number;data: SeriesCommentModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSeriesComment>>, {id: number;commentId: number;data: SeriesCommentModelUpdateV1}> = (props) => {
          const {id,commentId,data} = props ?? {};

          return  updateSeriesComment(id,commentId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateSeriesCommentMutationResult = NonNullable<Awaited<ReturnType<typeof updateSeriesComment>>>
    export type UpdateSeriesCommentMutationBody = SeriesCommentModelUpdateV1
    export type UpdateSeriesCommentMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary update a series comment
 */
export const useUpdateSeriesComment = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSeriesComment>>, TError,{id: number;commentId: number;data: SeriesCommentModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof updateSeriesComment>>,
        TError,
        {id: number;commentId: number;data: SeriesCommentModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getUpdateSeriesCommentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary moderate series comments
 */
export const seriesCommentsModerationPost = (
    seriesCommentSearchRequestV1: SeriesCommentSearchRequestV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SeriesCommentModerationResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/series/comments/moderation`,
      seriesCommentSearchRequestV1,options
    );
  }



export const getSeriesCommentsModerationPostMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof seriesCommentsModerationPost>>, TError,{data: SeriesCommentSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof seriesCommentsModerationPost>>, TError,{data: SeriesCommentSearchRequestV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof seriesCommentsModerationPost>>, {data: SeriesCommentSearchRequestV1}> = (props) => {
          const {data} = props ?? {};

          return  seriesCommentsModerationPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SeriesCommentsModerationPostMutationResult = NonNullable<Awaited<ReturnType<typeof seriesCommentsModerationPost>>>
    export type SeriesCommentsModerationPostMutationBody = SeriesCommentSearchRequestV1
    export type SeriesCommentsModerationPostMutationError = AxiosError<unknown>

    /**
 * @summary moderate series comments
 */
export const useSeriesCommentsModerationPost = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof seriesCommentsModerationPost>>, TError,{data: SeriesCommentSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof seriesCommentsModerationPost>>,
        TError,
        {data: SeriesCommentSearchRequestV1},
        TContext
      > => {

      const mutationOptions = getSeriesCommentsModerationPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary report a series comment
 */
export const reportSeriesComment = (
    id: number,
    commentId: number,
    seriesCommentReportModelV1: SeriesCommentReportModelV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/series/${id}/comments/${commentId}/report`,
      seriesCommentReportModelV1,options
    );
  }



export const getReportSeriesCommentMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof reportSeriesComment>>, TError,{id: number;commentId: number;data: SeriesCommentReportModelV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof reportSeriesComment>>, TError,{id: number;commentId: number;data: SeriesCommentReportModelV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof reportSeriesComment>>, {id: number;commentId: number;data: SeriesCommentReportModelV1}> = (props) => {
          const {id,commentId,data} = props ?? {};

          return  reportSeriesComment(id,commentId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ReportSeriesCommentMutationResult = NonNullable<Awaited<ReturnType<typeof reportSeriesComment>>>
    export type ReportSeriesCommentMutationBody = SeriesCommentReportModelV1
    export type ReportSeriesCommentMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary report a series comment
 */
export const useReportSeriesComment = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof reportSeriesComment>>, TError,{id: number;commentId: number;data: SeriesCommentReportModelV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof reportSeriesComment>>,
        TError,
        {id: number;commentId: number;data: SeriesCommentReportModelV1},
        TContext
      > => {

      const mutationOptions = getReportSeriesCommentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary get my series comment
 */
export const retrieveMySeriesComment = (
    id: number,
    params?: RetrieveMySeriesCommentParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SeriesCommentModelV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/series/${id}/comments/my_comment`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getRetrieveMySeriesCommentQueryKey = (id: number,
    params?: RetrieveMySeriesCommentParams,) => {
    return [`https://api.mangaupdates.com/v1/series/${id}/comments/my_comment`, ...(params ? [params]: [])] as const;
    }

    
export const getRetrieveMySeriesCommentInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveMySeriesComment>>>, TError = AxiosError<void>>(id: number,
    params?: RetrieveMySeriesCommentParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveMySeriesComment>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveMySeriesCommentQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveMySeriesComment>>> = ({ signal }) => retrieveMySeriesComment(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveMySeriesComment>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveMySeriesCommentInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveMySeriesComment>>>
export type RetrieveMySeriesCommentInfiniteQueryError = AxiosError<void>

/**
 * @summary get my series comment
 */
export const useRetrieveMySeriesCommentInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveMySeriesComment>>>, TError = AxiosError<void>>(
 id: number,
    params?: RetrieveMySeriesCommentParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveMySeriesComment>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveMySeriesCommentInfiniteQueryOptions(id,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveMySeriesCommentQueryOptions = <TData = Awaited<ReturnType<typeof retrieveMySeriesComment>>, TError = AxiosError<void>>(id: number,
    params?: RetrieveMySeriesCommentParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveMySeriesComment>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveMySeriesCommentQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveMySeriesComment>>> = ({ signal }) => retrieveMySeriesComment(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveMySeriesComment>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveMySeriesCommentQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveMySeriesComment>>>
export type RetrieveMySeriesCommentQueryError = AxiosError<void>

/**
 * @summary get my series comment
 */
export const useRetrieveMySeriesComment = <TData = Awaited<ReturnType<typeof retrieveMySeriesComment>>, TError = AxiosError<void>>(
 id: number,
    params?: RetrieveMySeriesCommentParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveMySeriesComment>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveMySeriesCommentQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary get a specific series comment location
 */
export const retrieveSeriesCommentLocation = (
    id: number,
    commentId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/series/${id}/comments/${commentId}/location`,options
    );
  }


export const getRetrieveSeriesCommentLocationQueryKey = (id: number,
    commentId: number,) => {
    return [`https://api.mangaupdates.com/v1/series/${id}/comments/${commentId}/location`] as const;
    }

    
export const getRetrieveSeriesCommentLocationInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveSeriesCommentLocation>>>, TError = AxiosError<unknown>>(id: number,
    commentId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveSeriesCommentLocation>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveSeriesCommentLocationQueryKey(id,commentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveSeriesCommentLocation>>> = ({ signal }) => retrieveSeriesCommentLocation(id,commentId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id && commentId),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveSeriesCommentLocation>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveSeriesCommentLocationInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveSeriesCommentLocation>>>
export type RetrieveSeriesCommentLocationInfiniteQueryError = AxiosError<unknown>

/**
 * @summary get a specific series comment location
 */
export const useRetrieveSeriesCommentLocationInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveSeriesCommentLocation>>>, TError = AxiosError<unknown>>(
 id: number,
    commentId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveSeriesCommentLocation>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveSeriesCommentLocationInfiniteQueryOptions(id,commentId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveSeriesCommentLocationQueryOptions = <TData = Awaited<ReturnType<typeof retrieveSeriesCommentLocation>>, TError = AxiosError<unknown>>(id: number,
    commentId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveSeriesCommentLocation>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveSeriesCommentLocationQueryKey(id,commentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveSeriesCommentLocation>>> = ({ signal }) => retrieveSeriesCommentLocation(id,commentId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id && commentId),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveSeriesCommentLocation>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveSeriesCommentLocationQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveSeriesCommentLocation>>>
export type RetrieveSeriesCommentLocationQueryError = AxiosError<unknown>

/**
 * @summary get a specific series comment location
 */
export const useRetrieveSeriesCommentLocation = <TData = Awaited<ReturnType<typeof retrieveSeriesCommentLocation>>, TError = AxiosError<unknown>>(
 id: number,
    commentId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveSeriesCommentLocation>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveSeriesCommentLocationQueryOptions(id,commentId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary search series comments
 */
export const searchSeriesCommentsPost = (
    id: number,
    seriesCommentSearchRequestV1: SeriesCommentSearchRequestV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SeriesCommentSearchResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/series/${id}/comments/search`,
      seriesCommentSearchRequestV1,options
    );
  }



export const getSearchSeriesCommentsPostMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchSeriesCommentsPost>>, TError,{id: number;data: SeriesCommentSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof searchSeriesCommentsPost>>, TError,{id: number;data: SeriesCommentSearchRequestV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchSeriesCommentsPost>>, {id: number;data: SeriesCommentSearchRequestV1}> = (props) => {
          const {id,data} = props ?? {};

          return  searchSeriesCommentsPost(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchSeriesCommentsPostMutationResult = NonNullable<Awaited<ReturnType<typeof searchSeriesCommentsPost>>>
    export type SearchSeriesCommentsPostMutationBody = SeriesCommentSearchRequestV1
    export type SearchSeriesCommentsPostMutationError = AxiosError<unknown>

    /**
 * @summary search series comments
 */
export const useSearchSeriesCommentsPost = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchSeriesCommentsPost>>, TError,{id: number;data: SeriesCommentSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof searchSeriesCommentsPost>>,
        TError,
        {id: number;data: SeriesCommentSearchRequestV1},
        TContext
      > => {

      const mutationOptions = getSearchSeriesCommentsPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary set usefulness of a series comment
 */
export const addSeriesCommentUsefulFlag = (
    id: number,
    commentId: number,
    seriesCommentUsefulModelV1: SeriesCommentUsefulModelV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.put(
      `https://api.mangaupdates.com/v1/series/${id}/comments/${commentId}/useful`,
      seriesCommentUsefulModelV1,options
    );
  }



export const getAddSeriesCommentUsefulFlagMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addSeriesCommentUsefulFlag>>, TError,{id: number;commentId: number;data: SeriesCommentUsefulModelV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addSeriesCommentUsefulFlag>>, TError,{id: number;commentId: number;data: SeriesCommentUsefulModelV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addSeriesCommentUsefulFlag>>, {id: number;commentId: number;data: SeriesCommentUsefulModelV1}> = (props) => {
          const {id,commentId,data} = props ?? {};

          return  addSeriesCommentUsefulFlag(id,commentId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddSeriesCommentUsefulFlagMutationResult = NonNullable<Awaited<ReturnType<typeof addSeriesCommentUsefulFlag>>>
    export type AddSeriesCommentUsefulFlagMutationBody = SeriesCommentUsefulModelV1
    export type AddSeriesCommentUsefulFlagMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary set usefulness of a series comment
 */
export const useAddSeriesCommentUsefulFlag = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addSeriesCommentUsefulFlag>>, TError,{id: number;commentId: number;data: SeriesCommentUsefulModelV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof addSeriesCommentUsefulFlag>>,
        TError,
        {id: number;commentId: number;data: SeriesCommentUsefulModelV1},
        TContext
      > => {

      const mutationOptions = getAddSeriesCommentUsefulFlagMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary remove usefulness of a series comment
 */
export const removeSeriesCommentUsefulFlag = (
    id: number,
    commentId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.delete(
      `https://api.mangaupdates.com/v1/series/${id}/comments/${commentId}/useful`,options
    );
  }



export const getRemoveSeriesCommentUsefulFlagMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeSeriesCommentUsefulFlag>>, TError,{id: number;commentId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof removeSeriesCommentUsefulFlag>>, TError,{id: number;commentId: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeSeriesCommentUsefulFlag>>, {id: number;commentId: number}> = (props) => {
          const {id,commentId} = props ?? {};

          return  removeSeriesCommentUsefulFlag(id,commentId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveSeriesCommentUsefulFlagMutationResult = NonNullable<Awaited<ReturnType<typeof removeSeriesCommentUsefulFlag>>>
    
    export type RemoveSeriesCommentUsefulFlagMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary remove usefulness of a series comment
 */
export const useRemoveSeriesCommentUsefulFlag = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeSeriesCommentUsefulFlag>>, TError,{id: number;commentId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof removeSeriesCommentUsefulFlag>>,
        TError,
        {id: number;commentId: number},
        TContext
      > => {

      const mutationOptions = getRemoveSeriesCommentUsefulFlagMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary get a specific series
 */
export const retrieveSeries = (
    id: number,
    params?: RetrieveSeriesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SeriesModelV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/series/${id}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getRetrieveSeriesQueryKey = (id: number,
    params?: RetrieveSeriesParams,) => {
    return [`https://api.mangaupdates.com/v1/series/${id}`, ...(params ? [params]: [])] as const;
    }

    
export const getRetrieveSeriesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveSeries>>>, TError = AxiosError<void>>(id: number,
    params?: RetrieveSeriesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveSeries>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveSeriesQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveSeries>>> = ({ signal }) => retrieveSeries(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveSeries>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveSeriesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveSeries>>>
export type RetrieveSeriesInfiniteQueryError = AxiosError<void>

/**
 * @summary get a specific series
 */
export const useRetrieveSeriesInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveSeries>>>, TError = AxiosError<void>>(
 id: number,
    params?: RetrieveSeriesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveSeries>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveSeriesInfiniteQueryOptions(id,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveSeriesQueryOptions = <TData = Awaited<ReturnType<typeof retrieveSeries>>, TError = AxiosError<void>>(id: number,
    params?: RetrieveSeriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveSeries>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveSeriesQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveSeries>>> = ({ signal }) => retrieveSeries(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveSeries>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveSeriesQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveSeries>>>
export type RetrieveSeriesQueryError = AxiosError<void>

/**
 * @summary get a specific series
 */
export const useRetrieveSeries = <TData = Awaited<ReturnType<typeof retrieveSeries>>, TError = AxiosError<void>>(
 id: number,
    params?: RetrieveSeriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveSeries>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveSeriesQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary delete a series
 */
export const deleteSeries = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.delete(
      `https://api.mangaupdates.com/v1/series/${id}`,options
    );
  }



export const getDeleteSeriesMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSeries>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteSeries>>, TError,{id: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteSeries>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteSeries(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteSeriesMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSeries>>>
    
    export type DeleteSeriesMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary delete a series
 */
export const useDeleteSeries = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSeries>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteSeries>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteSeriesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary update an series
 */
export const updateSeries = (
    id: number,
    seriesModelUpdateV1: SeriesModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.patch(
      `https://api.mangaupdates.com/v1/series/${id}`,
      seriesModelUpdateV1,options
    );
  }



export const getUpdateSeriesMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSeries>>, TError,{id: number;data: SeriesModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateSeries>>, TError,{id: number;data: SeriesModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSeries>>, {id: number;data: SeriesModelUpdateV1}> = (props) => {
          const {id,data} = props ?? {};

          return  updateSeries(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateSeriesMutationResult = NonNullable<Awaited<ReturnType<typeof updateSeries>>>
    export type UpdateSeriesMutationBody = SeriesModelUpdateV1
    export type UpdateSeriesMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary update an series
 */
export const useUpdateSeries = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSeries>>, TError,{id: number;data: SeriesModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof updateSeries>>,
        TError,
        {id: number;data: SeriesModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getUpdateSeriesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary get the list of groups scanlating a specific series
 */
export const retrieveSeriesGroups = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SeriesGroupListResponseV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/series/${id}/groups`,options
    );
  }


export const getRetrieveSeriesGroupsQueryKey = (id: number,) => {
    return [`https://api.mangaupdates.com/v1/series/${id}/groups`] as const;
    }

    
export const getRetrieveSeriesGroupsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveSeriesGroups>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveSeriesGroups>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveSeriesGroupsQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveSeriesGroups>>> = ({ signal }) => retrieveSeriesGroups(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveSeriesGroups>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveSeriesGroupsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveSeriesGroups>>>
export type RetrieveSeriesGroupsInfiniteQueryError = AxiosError<void>

/**
 * @summary get the list of groups scanlating a specific series
 */
export const useRetrieveSeriesGroupsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveSeriesGroups>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveSeriesGroups>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveSeriesGroupsInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveSeriesGroupsQueryOptions = <TData = Awaited<ReturnType<typeof retrieveSeriesGroups>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveSeriesGroups>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveSeriesGroupsQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveSeriesGroups>>> = ({ signal }) => retrieveSeriesGroups(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveSeriesGroups>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveSeriesGroupsQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveSeriesGroups>>>
export type RetrieveSeriesGroupsQueryError = AxiosError<void>

/**
 * @summary get the list of groups scanlating a specific series
 */
export const useRetrieveSeriesGroups = <TData = Awaited<ReturnType<typeof retrieveSeriesGroups>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveSeriesGroups>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveSeriesGroupsQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary search series history
 */
export const searchSeriesHistoryPost = (
    id: number,
    perPageSearchRequestV1: PerPageSearchRequestV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SeriesHistorySearchResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/series/${id}/history`,
      perPageSearchRequestV1,options
    );
  }



export const getSearchSeriesHistoryPostMutationOptions = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchSeriesHistoryPost>>, TError,{id: number;data: PerPageSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof searchSeriesHistoryPost>>, TError,{id: number;data: PerPageSearchRequestV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchSeriesHistoryPost>>, {id: number;data: PerPageSearchRequestV1}> = (props) => {
          const {id,data} = props ?? {};

          return  searchSeriesHistoryPost(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchSeriesHistoryPostMutationResult = NonNullable<Awaited<ReturnType<typeof searchSeriesHistoryPost>>>
    export type SearchSeriesHistoryPostMutationBody = PerPageSearchRequestV1
    export type SearchSeriesHistoryPostMutationError = AxiosError<ApiResponseV1>

    /**
 * @summary search series history
 */
export const useSearchSeriesHistoryPost = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchSeriesHistoryPost>>, TError,{id: number;data: PerPageSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof searchSeriesHistoryPost>>,
        TError,
        {id: number;data: PerPageSearchRequestV1},
        TContext
      > => {

      const mutationOptions = getSearchSeriesHistoryPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary get a specific series lock
 */
export const retrieveSeriesLocks = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SeriesLockModelV1[]>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/series/${id}/locks`,options
    );
  }


export const getRetrieveSeriesLocksQueryKey = (id: number,) => {
    return [`https://api.mangaupdates.com/v1/series/${id}/locks`] as const;
    }

    
export const getRetrieveSeriesLocksInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveSeriesLocks>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveSeriesLocks>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveSeriesLocksQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveSeriesLocks>>> = ({ signal }) => retrieveSeriesLocks(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveSeriesLocks>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveSeriesLocksInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveSeriesLocks>>>
export type RetrieveSeriesLocksInfiniteQueryError = AxiosError<void>

/**
 * @summary get a specific series lock
 */
export const useRetrieveSeriesLocksInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveSeriesLocks>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveSeriesLocks>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveSeriesLocksInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveSeriesLocksQueryOptions = <TData = Awaited<ReturnType<typeof retrieveSeriesLocks>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveSeriesLocks>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveSeriesLocksQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveSeriesLocks>>> = ({ signal }) => retrieveSeriesLocks(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveSeriesLocks>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveSeriesLocksQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveSeriesLocks>>>
export type RetrieveSeriesLocksQueryError = AxiosError<void>

/**
 * @summary get a specific series lock
 */
export const useRetrieveSeriesLocks = <TData = Awaited<ReturnType<typeof retrieveSeriesLocks>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveSeriesLocks>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveSeriesLocksQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary lock a field of an series
 */
export const lockSeriesField = (
    id: number,
    item: string,
    seriesLockModelUpdateV1: SeriesLockModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/series/${id}/locks/${item}/lock`,
      seriesLockModelUpdateV1,options
    );
  }



export const getLockSeriesFieldMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lockSeriesField>>, TError,{id: number;item: string;data: SeriesLockModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof lockSeriesField>>, TError,{id: number;item: string;data: SeriesLockModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof lockSeriesField>>, {id: number;item: string;data: SeriesLockModelUpdateV1}> = (props) => {
          const {id,item,data} = props ?? {};

          return  lockSeriesField(id,item,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LockSeriesFieldMutationResult = NonNullable<Awaited<ReturnType<typeof lockSeriesField>>>
    export type LockSeriesFieldMutationBody = SeriesLockModelUpdateV1
    export type LockSeriesFieldMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary lock a field of an series
 */
export const useLockSeriesField = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lockSeriesField>>, TError,{id: number;item: string;data: SeriesLockModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof lockSeriesField>>,
        TError,
        {id: number;item: string;data: SeriesLockModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getLockSeriesFieldMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary unlock a field of an series
 */
export const unlockSeriesField = (
    id: number,
    item: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/series/${id}/locks/${item}/unlock`,undefined,options
    );
  }



export const getUnlockSeriesFieldMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unlockSeriesField>>, TError,{id: number;item: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof unlockSeriesField>>, TError,{id: number;item: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof unlockSeriesField>>, {id: number;item: string}> = (props) => {
          const {id,item} = props ?? {};

          return  unlockSeriesField(id,item,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UnlockSeriesFieldMutationResult = NonNullable<Awaited<ReturnType<typeof unlockSeriesField>>>
    
    export type UnlockSeriesFieldMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary unlock a field of an series
 */
export const useUnlockSeriesField = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unlockSeriesField>>, TError,{id: number;item: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof unlockSeriesField>>,
        TError,
        {id: number;item: string},
        TContext
      > => {

      const mutationOptions = getUnlockSeriesFieldMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary get a specific series rank location
 */
export const retrieveSeriesRankLocation = (
    id: number,
    type: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/series/${id}/rank/${type}`,options
    );
  }


export const getRetrieveSeriesRankLocationQueryKey = (id: number,
    type: string,) => {
    return [`https://api.mangaupdates.com/v1/series/${id}/rank/${type}`] as const;
    }

    
export const getRetrieveSeriesRankLocationInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveSeriesRankLocation>>>, TError = AxiosError<unknown>>(id: number,
    type: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveSeriesRankLocation>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveSeriesRankLocationQueryKey(id,type);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveSeriesRankLocation>>> = ({ signal }) => retrieveSeriesRankLocation(id,type, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id && type),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveSeriesRankLocation>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveSeriesRankLocationInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveSeriesRankLocation>>>
export type RetrieveSeriesRankLocationInfiniteQueryError = AxiosError<unknown>

/**
 * @summary get a specific series rank location
 */
export const useRetrieveSeriesRankLocationInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveSeriesRankLocation>>>, TError = AxiosError<unknown>>(
 id: number,
    type: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveSeriesRankLocation>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveSeriesRankLocationInfiniteQueryOptions(id,type,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveSeriesRankLocationQueryOptions = <TData = Awaited<ReturnType<typeof retrieveSeriesRankLocation>>, TError = AxiosError<unknown>>(id: number,
    type: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveSeriesRankLocation>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveSeriesRankLocationQueryKey(id,type);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveSeriesRankLocation>>> = ({ signal }) => retrieveSeriesRankLocation(id,type, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id && type),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveSeriesRankLocation>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveSeriesRankLocationQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveSeriesRankLocation>>>
export type RetrieveSeriesRankLocationQueryError = AxiosError<unknown>

/**
 * @summary get a specific series rank location
 */
export const useRetrieveSeriesRankLocation = <TData = Awaited<ReturnType<typeof retrieveSeriesRankLocation>>, TError = AxiosError<unknown>>(
 id: number,
    type: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveSeriesRankLocation>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveSeriesRankLocationQueryOptions(id,type,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary get a specific series rating for a user
 */
export const retrieveUserSeriesRating = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SeriesRatingModelV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/series/${id}/rating`,options
    );
  }


export const getRetrieveUserSeriesRatingQueryKey = (id: number,) => {
    return [`https://api.mangaupdates.com/v1/series/${id}/rating`] as const;
    }

    
export const getRetrieveUserSeriesRatingInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveUserSeriesRating>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveUserSeriesRating>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveUserSeriesRatingQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveUserSeriesRating>>> = ({ signal }) => retrieveUserSeriesRating(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveUserSeriesRating>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveUserSeriesRatingInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveUserSeriesRating>>>
export type RetrieveUserSeriesRatingInfiniteQueryError = AxiosError<void>

/**
 * @summary get a specific series rating for a user
 */
export const useRetrieveUserSeriesRatingInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveUserSeriesRating>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveUserSeriesRating>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveUserSeriesRatingInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveUserSeriesRatingQueryOptions = <TData = Awaited<ReturnType<typeof retrieveUserSeriesRating>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveUserSeriesRating>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveUserSeriesRatingQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveUserSeriesRating>>> = ({ signal }) => retrieveUserSeriesRating(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveUserSeriesRating>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveUserSeriesRatingQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveUserSeriesRating>>>
export type RetrieveUserSeriesRatingQueryError = AxiosError<void>

/**
 * @summary get a specific series rating for a user
 */
export const useRetrieveUserSeriesRating = <TData = Awaited<ReturnType<typeof retrieveUserSeriesRating>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveUserSeriesRating>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveUserSeriesRatingQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary update the user rating for a series
 */
export const updateUserSeriesRating = (
    id: number,
    seriesRatingModelV1: SeriesRatingModelV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.put(
      `https://api.mangaupdates.com/v1/series/${id}/rating`,
      seriesRatingModelV1,options
    );
  }



export const getUpdateUserSeriesRatingMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUserSeriesRating>>, TError,{id: number;data: SeriesRatingModelV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateUserSeriesRating>>, TError,{id: number;data: SeriesRatingModelV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUserSeriesRating>>, {id: number;data: SeriesRatingModelV1}> = (props) => {
          const {id,data} = props ?? {};

          return  updateUserSeriesRating(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUserSeriesRatingMutationResult = NonNullable<Awaited<ReturnType<typeof updateUserSeriesRating>>>
    export type UpdateUserSeriesRatingMutationBody = SeriesRatingModelV1
    export type UpdateUserSeriesRatingMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary update the user rating for a series
 */
export const useUpdateUserSeriesRating = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUserSeriesRating>>, TError,{id: number;data: SeriesRatingModelV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof updateUserSeriesRating>>,
        TError,
        {id: number;data: SeriesRatingModelV1},
        TContext
      > => {

      const mutationOptions = getUpdateUserSeriesRatingMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary delete a series rating for a user
 */
export const deleteUserSeriesRating = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.delete(
      `https://api.mangaupdates.com/v1/series/${id}/rating`,options
    );
  }



export const getDeleteUserSeriesRatingMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUserSeriesRating>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteUserSeriesRating>>, TError,{id: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUserSeriesRating>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteUserSeriesRating(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUserSeriesRatingMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUserSeriesRating>>>
    
    export type DeleteUserSeriesRatingMutationError = AxiosError<void>

    /**
 * @summary delete a series rating for a user
 */
export const useDeleteUserSeriesRating = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUserSeriesRating>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteUserSeriesRating>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteUserSeriesRatingMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary get a the series rating rainbow
 */
export const retrieveSeriesRatingRainbow = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SeriesRatingRainbowModelV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/series/${id}/ratingrainbow`,options
    );
  }


export const getRetrieveSeriesRatingRainbowQueryKey = (id: number,) => {
    return [`https://api.mangaupdates.com/v1/series/${id}/ratingrainbow`] as const;
    }

    
export const getRetrieveSeriesRatingRainbowInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveSeriesRatingRainbow>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveSeriesRatingRainbow>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveSeriesRatingRainbowQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveSeriesRatingRainbow>>> = ({ signal }) => retrieveSeriesRatingRainbow(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveSeriesRatingRainbow>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveSeriesRatingRainbowInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveSeriesRatingRainbow>>>
export type RetrieveSeriesRatingRainbowInfiniteQueryError = AxiosError<void>

/**
 * @summary get a the series rating rainbow
 */
export const useRetrieveSeriesRatingRainbowInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveSeriesRatingRainbow>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveSeriesRatingRainbow>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveSeriesRatingRainbowInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveSeriesRatingRainbowQueryOptions = <TData = Awaited<ReturnType<typeof retrieveSeriesRatingRainbow>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveSeriesRatingRainbow>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveSeriesRatingRainbowQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveSeriesRatingRainbow>>> = ({ signal }) => retrieveSeriesRatingRainbow(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveSeriesRatingRainbow>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveSeriesRatingRainbowQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveSeriesRatingRainbow>>>
export type RetrieveSeriesRatingRainbowQueryError = AxiosError<void>

/**
 * @summary get a the series rating rainbow
 */
export const useRetrieveSeriesRatingRainbow = <TData = Awaited<ReturnType<typeof retrieveSeriesRatingRainbow>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveSeriesRatingRainbow>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveSeriesRatingRainbowQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary releases rss feed for a specific series
 */
export const seriesReleaseRssFeed = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/series/${id}/rss`,options
    );
  }


export const getSeriesReleaseRssFeedQueryKey = (id: number,) => {
    return [`https://api.mangaupdates.com/v1/series/${id}/rss`] as const;
    }

    
export const getSeriesReleaseRssFeedInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof seriesReleaseRssFeed>>>, TError = AxiosError<unknown>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof seriesReleaseRssFeed>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSeriesReleaseRssFeedQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof seriesReleaseRssFeed>>> = ({ signal }) => seriesReleaseRssFeed(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof seriesReleaseRssFeed>>, TError, TData> & { queryKey: QueryKey }
}

export type SeriesReleaseRssFeedInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof seriesReleaseRssFeed>>>
export type SeriesReleaseRssFeedInfiniteQueryError = AxiosError<unknown>

/**
 * @summary releases rss feed for a specific series
 */
export const useSeriesReleaseRssFeedInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof seriesReleaseRssFeed>>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof seriesReleaseRssFeed>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSeriesReleaseRssFeedInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getSeriesReleaseRssFeedQueryOptions = <TData = Awaited<ReturnType<typeof seriesReleaseRssFeed>>, TError = AxiosError<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof seriesReleaseRssFeed>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSeriesReleaseRssFeedQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof seriesReleaseRssFeed>>> = ({ signal }) => seriesReleaseRssFeed(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof seriesReleaseRssFeed>>, TError, TData> & { queryKey: QueryKey }
}

export type SeriesReleaseRssFeedQueryResult = NonNullable<Awaited<ReturnType<typeof seriesReleaseRssFeed>>>
export type SeriesReleaseRssFeedQueryError = AxiosError<unknown>

/**
 * @summary releases rss feed for a specific series
 */
export const useSeriesReleaseRssFeed = <TData = Awaited<ReturnType<typeof seriesReleaseRssFeed>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof seriesReleaseRssFeed>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSeriesReleaseRssFeedQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary search series
 */
export const searchSeriesPost = (
    seriesSearchRequestV1: SeriesSearchRequestV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SeriesSearchResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/series/search`,
      seriesSearchRequestV1,options
    );
  }



export const getSearchSeriesPostMutationOptions = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchSeriesPost>>, TError,{data: SeriesSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof searchSeriesPost>>, TError,{data: SeriesSearchRequestV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchSeriesPost>>, {data: SeriesSearchRequestV1}> = (props) => {
          const {data} = props ?? {};

          return  searchSeriesPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchSeriesPostMutationResult = NonNullable<Awaited<ReturnType<typeof searchSeriesPost>>>
    export type SearchSeriesPostMutationBody = SeriesSearchRequestV1
    export type SearchSeriesPostMutationError = AxiosError<ApiResponseV1>

    /**
 * @summary search series
 */
export const useSearchSeriesPost = <TError = AxiosError<ApiResponseV1>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchSeriesPost>>, TError,{data: SeriesSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof searchSeriesPost>>,
        TError,
        {data: SeriesSearchRequestV1},
        TContext
      > => {

      const mutationOptions = getSearchSeriesPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary update the image of an series
 */
export const updateSeriesImage = (
    id: number,
    updateSeriesImageBody: UpdateSeriesImageBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {const formData = new FormData();
if(updateSeriesImageBody.image !== undefined) {
 formData.append('image', updateSeriesImageBody.image)
 }

    
    return axios.post(
      `https://api.mangaupdates.com/v1/series/${id}/image`,
      formData,options
    );
  }



export const getUpdateSeriesImageMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSeriesImage>>, TError,{id: number;data: UpdateSeriesImageBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateSeriesImage>>, TError,{id: number;data: UpdateSeriesImageBody}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSeriesImage>>, {id: number;data: UpdateSeriesImageBody}> = (props) => {
          const {id,data} = props ?? {};

          return  updateSeriesImage(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateSeriesImageMutationResult = NonNullable<Awaited<ReturnType<typeof updateSeriesImage>>>
    export type UpdateSeriesImageMutationBody = UpdateSeriesImageBody
    export type UpdateSeriesImageMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary update the image of an series
 */
export const useUpdateSeriesImage = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSeriesImage>>, TError,{id: number;data: UpdateSeriesImageBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof updateSeriesImage>>,
        TError,
        {id: number;data: UpdateSeriesImageBody},
        TContext
      > => {

      const mutationOptions = getUpdateSeriesImageMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary delete the image of an series
 */
export const deleteSeriesImage = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.delete(
      `https://api.mangaupdates.com/v1/series/${id}/image`,options
    );
  }



export const getDeleteSeriesImageMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSeriesImage>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteSeriesImage>>, TError,{id: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteSeriesImage>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteSeriesImage(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteSeriesImageMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSeriesImage>>>
    
    export type DeleteSeriesImageMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary delete the image of an series
 */
export const useDeleteSeriesImage = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSeriesImage>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteSeriesImage>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteSeriesImageMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary get user group
 */
export const retrieveUserGroupById = (
    id: string,
    params?: RetrieveUserGroupByIdParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserGroupModelV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/membergroups/${id}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getRetrieveUserGroupByIdQueryKey = (id: string,
    params?: RetrieveUserGroupByIdParams,) => {
    return [`https://api.mangaupdates.com/v1/membergroups/${id}`, ...(params ? [params]: [])] as const;
    }

    
export const getRetrieveUserGroupByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveUserGroupById>>>, TError = AxiosError<unknown>>(id: string,
    params?: RetrieveUserGroupByIdParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveUserGroupById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveUserGroupByIdQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveUserGroupById>>> = ({ signal }) => retrieveUserGroupById(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveUserGroupById>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveUserGroupByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveUserGroupById>>>
export type RetrieveUserGroupByIdInfiniteQueryError = AxiosError<unknown>

/**
 * @summary get user group
 */
export const useRetrieveUserGroupByIdInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveUserGroupById>>>, TError = AxiosError<unknown>>(
 id: string,
    params?: RetrieveUserGroupByIdParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveUserGroupById>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveUserGroupByIdInfiniteQueryOptions(id,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveUserGroupByIdQueryOptions = <TData = Awaited<ReturnType<typeof retrieveUserGroupById>>, TError = AxiosError<unknown>>(id: string,
    params?: RetrieveUserGroupByIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveUserGroupById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveUserGroupByIdQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveUserGroupById>>> = ({ signal }) => retrieveUserGroupById(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveUserGroupById>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveUserGroupByIdQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveUserGroupById>>>
export type RetrieveUserGroupByIdQueryError = AxiosError<unknown>

/**
 * @summary get user group
 */
export const useRetrieveUserGroupById = <TData = Awaited<ReturnType<typeof retrieveUserGroupById>>, TError = AxiosError<unknown>>(
 id: string,
    params?: RetrieveUserGroupByIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveUserGroupById>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveUserGroupByIdQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary add or update a user group
 */
export const addOrUpdateUserGroup = (
    id: string,
    userGroupModelUpdateV1: UserGroupModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.put(
      `https://api.mangaupdates.com/v1/membergroups/${id}`,
      userGroupModelUpdateV1,options
    );
  }



export const getAddOrUpdateUserGroupMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addOrUpdateUserGroup>>, TError,{id: string;data: UserGroupModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addOrUpdateUserGroup>>, TError,{id: string;data: UserGroupModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addOrUpdateUserGroup>>, {id: string;data: UserGroupModelUpdateV1}> = (props) => {
          const {id,data} = props ?? {};

          return  addOrUpdateUserGroup(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddOrUpdateUserGroupMutationResult = NonNullable<Awaited<ReturnType<typeof addOrUpdateUserGroup>>>
    export type AddOrUpdateUserGroupMutationBody = UserGroupModelUpdateV1
    export type AddOrUpdateUserGroupMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary add or update a user group
 */
export const useAddOrUpdateUserGroup = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addOrUpdateUserGroup>>, TError,{id: string;data: UserGroupModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof addOrUpdateUserGroup>>,
        TError,
        {id: string;data: UserGroupModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getAddOrUpdateUserGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary delete a user group
 */
export const deleteUserGroup = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.delete(
      `https://api.mangaupdates.com/v1/membergroups/${id}`,options
    );
  }



export const getDeleteUserGroupMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUserGroup>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteUserGroup>>, TError,{id: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUserGroup>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteUserGroup(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUserGroupMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUserGroup>>>
    
    export type DeleteUserGroupMutationError = AxiosError<void>

    /**
 * @summary delete a user group
 */
export const useDeleteUserGroup = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUserGroup>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteUserGroup>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteUserGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary get user groups
 */
export const retrieveUserGroups = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserGroupModelV1[]>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/membergroups`,options
    );
  }


export const getRetrieveUserGroupsQueryKey = () => {
    return [`https://api.mangaupdates.com/v1/membergroups`] as const;
    }

    
export const getRetrieveUserGroupsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveUserGroups>>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveUserGroups>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveUserGroupsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveUserGroups>>> = ({ signal }) => retrieveUserGroups({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveUserGroups>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveUserGroupsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveUserGroups>>>
export type RetrieveUserGroupsInfiniteQueryError = AxiosError<unknown>

/**
 * @summary get user groups
 */
export const useRetrieveUserGroupsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveUserGroups>>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveUserGroups>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveUserGroupsInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveUserGroupsQueryOptions = <TData = Awaited<ReturnType<typeof retrieveUserGroups>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveUserGroups>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveUserGroupsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveUserGroups>>> = ({ signal }) => retrieveUserGroups({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveUserGroups>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveUserGroupsQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveUserGroups>>>
export type RetrieveUserGroupsQueryError = AxiosError<unknown>

/**
 * @summary get user groups
 */
export const useRetrieveUserGroups = <TData = Awaited<ReturnType<typeof retrieveUserGroups>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveUserGroups>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveUserGroupsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary add a member
 */
export const addMember = (
    userModelUpdateV1: UserModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/members`,
      userModelUpdateV1,options
    );
  }



export const getAddMemberMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addMember>>, TError,{data: UserModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addMember>>, TError,{data: UserModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addMember>>, {data: UserModelUpdateV1}> = (props) => {
          const {data} = props ?? {};

          return  addMember(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddMemberMutationResult = NonNullable<Awaited<ReturnType<typeof addMember>>>
    export type AddMemberMutationBody = UserModelUpdateV1
    export type AddMemberMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary add a member
 */
export const useAddMember = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addMember>>, TError,{data: UserModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof addMember>>,
        TError,
        {data: UserModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getAddMemberMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary search change requests for a specific user
 */
export const searchMemberChangeRequests = (
    id: number,
    params?: SearchMemberChangeRequestsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserChangeRequestSearchResponseV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/members/${id}/requests`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getSearchMemberChangeRequestsQueryKey = (id: number,
    params?: SearchMemberChangeRequestsParams,) => {
    return [`https://api.mangaupdates.com/v1/members/${id}/requests`, ...(params ? [params]: [])] as const;
    }

    
export const getSearchMemberChangeRequestsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof searchMemberChangeRequests>>>, TError = AxiosError<void>>(id: number,
    params?: SearchMemberChangeRequestsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchMemberChangeRequests>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchMemberChangeRequestsQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchMemberChangeRequests>>> = ({ signal }) => searchMemberChangeRequests(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchMemberChangeRequests>>, TError, TData> & { queryKey: QueryKey }
}

export type SearchMemberChangeRequestsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof searchMemberChangeRequests>>>
export type SearchMemberChangeRequestsInfiniteQueryError = AxiosError<void>

/**
 * @summary search change requests for a specific user
 */
export const useSearchMemberChangeRequestsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof searchMemberChangeRequests>>>, TError = AxiosError<void>>(
 id: number,
    params?: SearchMemberChangeRequestsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchMemberChangeRequests>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSearchMemberChangeRequestsInfiniteQueryOptions(id,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getSearchMemberChangeRequestsQueryOptions = <TData = Awaited<ReturnType<typeof searchMemberChangeRequests>>, TError = AxiosError<void>>(id: number,
    params?: SearchMemberChangeRequestsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchMemberChangeRequests>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchMemberChangeRequestsQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchMemberChangeRequests>>> = ({ signal }) => searchMemberChangeRequests(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchMemberChangeRequests>>, TError, TData> & { queryKey: QueryKey }
}

export type SearchMemberChangeRequestsQueryResult = NonNullable<Awaited<ReturnType<typeof searchMemberChangeRequests>>>
export type SearchMemberChangeRequestsQueryError = AxiosError<void>

/**
 * @summary search change requests for a specific user
 */
export const useSearchMemberChangeRequests = <TData = Awaited<ReturnType<typeof searchMemberChangeRequests>>, TError = AxiosError<void>>(
 id: number,
    params?: SearchMemberChangeRequestsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchMemberChangeRequests>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSearchMemberChangeRequestsQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary add a change request
 */
export const addMemberChangeRequest = (
    id: number,
    userChangeRequestModelUpdateV1: UserChangeRequestModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/members/${id}/requests`,
      userChangeRequestModelUpdateV1,options
    );
  }



export const getAddMemberChangeRequestMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addMemberChangeRequest>>, TError,{id: number;data: UserChangeRequestModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addMemberChangeRequest>>, TError,{id: number;data: UserChangeRequestModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addMemberChangeRequest>>, {id: number;data: UserChangeRequestModelUpdateV1}> = (props) => {
          const {id,data} = props ?? {};

          return  addMemberChangeRequest(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddMemberChangeRequestMutationResult = NonNullable<Awaited<ReturnType<typeof addMemberChangeRequest>>>
    export type AddMemberChangeRequestMutationBody = UserChangeRequestModelUpdateV1
    export type AddMemberChangeRequestMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary add a change request
 */
export const useAddMemberChangeRequest = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addMemberChangeRequest>>, TError,{id: number;data: UserChangeRequestModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof addMemberChangeRequest>>,
        TError,
        {id: number;data: UserChangeRequestModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getAddMemberChangeRequestMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary get change requests for a specific user
 */
export const retrieveMemberChangeRequest = (
    id: number,
    requestId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserChangeRequestModelV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/members/${id}/requests/${requestId}`,options
    );
  }


export const getRetrieveMemberChangeRequestQueryKey = (id: number,
    requestId: number,) => {
    return [`https://api.mangaupdates.com/v1/members/${id}/requests/${requestId}`] as const;
    }

    
export const getRetrieveMemberChangeRequestInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveMemberChangeRequest>>>, TError = AxiosError<void>>(id: number,
    requestId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveMemberChangeRequest>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveMemberChangeRequestQueryKey(id,requestId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveMemberChangeRequest>>> = ({ signal }) => retrieveMemberChangeRequest(id,requestId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id && requestId),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveMemberChangeRequest>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveMemberChangeRequestInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveMemberChangeRequest>>>
export type RetrieveMemberChangeRequestInfiniteQueryError = AxiosError<void>

/**
 * @summary get change requests for a specific user
 */
export const useRetrieveMemberChangeRequestInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveMemberChangeRequest>>>, TError = AxiosError<void>>(
 id: number,
    requestId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveMemberChangeRequest>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveMemberChangeRequestInfiniteQueryOptions(id,requestId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveMemberChangeRequestQueryOptions = <TData = Awaited<ReturnType<typeof retrieveMemberChangeRequest>>, TError = AxiosError<void>>(id: number,
    requestId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveMemberChangeRequest>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveMemberChangeRequestQueryKey(id,requestId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveMemberChangeRequest>>> = ({ signal }) => retrieveMemberChangeRequest(id,requestId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id && requestId),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveMemberChangeRequest>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveMemberChangeRequestQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveMemberChangeRequest>>>
export type RetrieveMemberChangeRequestQueryError = AxiosError<void>

/**
 * @summary get change requests for a specific user
 */
export const useRetrieveMemberChangeRequest = <TData = Awaited<ReturnType<typeof retrieveMemberChangeRequest>>, TError = AxiosError<void>>(
 id: number,
    requestId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveMemberChangeRequest>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveMemberChangeRequestQueryOptions(id,requestId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary add a change request
 */
export const deleteMemberChangeRequest = (
    id: number,
    requestId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.delete(
      `https://api.mangaupdates.com/v1/members/${id}/requests/${requestId}`,options
    );
  }



export const getDeleteMemberChangeRequestMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteMemberChangeRequest>>, TError,{id: number;requestId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteMemberChangeRequest>>, TError,{id: number;requestId: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteMemberChangeRequest>>, {id: number;requestId: number}> = (props) => {
          const {id,requestId} = props ?? {};

          return  deleteMemberChangeRequest(id,requestId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteMemberChangeRequestMutationResult = NonNullable<Awaited<ReturnType<typeof deleteMemberChangeRequest>>>
    
    export type DeleteMemberChangeRequestMutationError = AxiosError<void>

    /**
 * @summary add a change request
 */
export const useDeleteMemberChangeRequest = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteMemberChangeRequest>>, TError,{id: number;requestId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteMemberChangeRequest>>,
        TError,
        {id: number;requestId: number},
        TContext
      > => {

      const mutationOptions = getDeleteMemberChangeRequestMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary update a change request
 */
export const updateMemberChangeRequest = (
    id: number,
    requestId: number,
    userChangeRequestModelUpdateV1: UserChangeRequestModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.patch(
      `https://api.mangaupdates.com/v1/members/${id}/requests/${requestId}`,
      userChangeRequestModelUpdateV1,options
    );
  }



export const getUpdateMemberChangeRequestMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateMemberChangeRequest>>, TError,{id: number;requestId: number;data: UserChangeRequestModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateMemberChangeRequest>>, TError,{id: number;requestId: number;data: UserChangeRequestModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateMemberChangeRequest>>, {id: number;requestId: number;data: UserChangeRequestModelUpdateV1}> = (props) => {
          const {id,requestId,data} = props ?? {};

          return  updateMemberChangeRequest(id,requestId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateMemberChangeRequestMutationResult = NonNullable<Awaited<ReturnType<typeof updateMemberChangeRequest>>>
    export type UpdateMemberChangeRequestMutationBody = UserChangeRequestModelUpdateV1
    export type UpdateMemberChangeRequestMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary update a change request
 */
export const useUpdateMemberChangeRequest = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateMemberChangeRequest>>, TError,{id: number;requestId: number;data: UserChangeRequestModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof updateMemberChangeRequest>>,
        TError,
        {id: number;requestId: number;data: UserChangeRequestModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getUpdateMemberChangeRequestMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary get a specific members
 */
export const retrieveMember = (
    id: number,
    params?: RetrieveMemberParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserModelV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/members/${id}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getRetrieveMemberQueryKey = (id: number,
    params?: RetrieveMemberParams,) => {
    return [`https://api.mangaupdates.com/v1/members/${id}`, ...(params ? [params]: [])] as const;
    }

    
export const getRetrieveMemberInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveMember>>>, TError = AxiosError<void>>(id: number,
    params?: RetrieveMemberParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveMember>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveMemberQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveMember>>> = ({ signal }) => retrieveMember(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveMember>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveMemberInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveMember>>>
export type RetrieveMemberInfiniteQueryError = AxiosError<void>

/**
 * @summary get a specific members
 */
export const useRetrieveMemberInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveMember>>>, TError = AxiosError<void>>(
 id: number,
    params?: RetrieveMemberParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveMember>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveMemberInfiniteQueryOptions(id,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveMemberQueryOptions = <TData = Awaited<ReturnType<typeof retrieveMember>>, TError = AxiosError<void>>(id: number,
    params?: RetrieveMemberParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveMember>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveMemberQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveMember>>> = ({ signal }) => retrieveMember(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveMember>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveMemberQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveMember>>>
export type RetrieveMemberQueryError = AxiosError<void>

/**
 * @summary get a specific members
 */
export const useRetrieveMember = <TData = Awaited<ReturnType<typeof retrieveMember>>, TError = AxiosError<void>>(
 id: number,
    params?: RetrieveMemberParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveMember>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveMemberQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary delete a member
 */
export const deleteMember = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.delete(
      `https://api.mangaupdates.com/v1/members/${id}`,options
    );
  }



export const getDeleteMemberMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteMember>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteMember>>, TError,{id: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteMember>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteMember(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteMemberMutationResult = NonNullable<Awaited<ReturnType<typeof deleteMember>>>
    
    export type DeleteMemberMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary delete a member
 */
export const useDeleteMember = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteMember>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteMember>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteMemberMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary update a member
 */
export const updateMember = (
    id: number,
    userModelUpdateV1: UserModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.patch(
      `https://api.mangaupdates.com/v1/members/${id}`,
      userModelUpdateV1,options
    );
  }



export const getUpdateMemberMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateMember>>, TError,{id: number;data: UserModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateMember>>, TError,{id: number;data: UserModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateMember>>, {id: number;data: UserModelUpdateV1}> = (props) => {
          const {id,data} = props ?? {};

          return  updateMember(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateMemberMutationResult = NonNullable<Awaited<ReturnType<typeof updateMember>>>
    export type UpdateMemberMutationBody = UserModelUpdateV1
    export type UpdateMemberMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary update a member
 */
export const useUpdateMember = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateMember>>, TError,{id: number;data: UserModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof updateMember>>,
        TError,
        {id: number;data: UserModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getUpdateMemberMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary get genre filters for a specific user
 */
export const retrieveMemberGenreFilters = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserGenreFilterModelV1[]>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/members/${id}/genre/filters`,options
    );
  }


export const getRetrieveMemberGenreFiltersQueryKey = (id: number,) => {
    return [`https://api.mangaupdates.com/v1/members/${id}/genre/filters`] as const;
    }

    
export const getRetrieveMemberGenreFiltersInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveMemberGenreFilters>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveMemberGenreFilters>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveMemberGenreFiltersQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveMemberGenreFilters>>> = ({ signal }) => retrieveMemberGenreFilters(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveMemberGenreFilters>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveMemberGenreFiltersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveMemberGenreFilters>>>
export type RetrieveMemberGenreFiltersInfiniteQueryError = AxiosError<void>

/**
 * @summary get genre filters for a specific user
 */
export const useRetrieveMemberGenreFiltersInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveMemberGenreFilters>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveMemberGenreFilters>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveMemberGenreFiltersInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveMemberGenreFiltersQueryOptions = <TData = Awaited<ReturnType<typeof retrieveMemberGenreFilters>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveMemberGenreFilters>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveMemberGenreFiltersQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveMemberGenreFilters>>> = ({ signal }) => retrieveMemberGenreFilters(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveMemberGenreFilters>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveMemberGenreFiltersQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveMemberGenreFilters>>>
export type RetrieveMemberGenreFiltersQueryError = AxiosError<void>

/**
 * @summary get genre filters for a specific user
 */
export const useRetrieveMemberGenreFilters = <TData = Awaited<ReturnType<typeof retrieveMemberGenreFilters>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveMemberGenreFilters>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveMemberGenreFiltersQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary filter a genre for a user
 */
export const addMemberGenreFilter = (
    id: number,
    genreId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/members/${id}/genre/${genreId}/filter`,undefined,options
    );
  }



export const getAddMemberGenreFilterMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addMemberGenreFilter>>, TError,{id: number;genreId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addMemberGenreFilter>>, TError,{id: number;genreId: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addMemberGenreFilter>>, {id: number;genreId: number}> = (props) => {
          const {id,genreId} = props ?? {};

          return  addMemberGenreFilter(id,genreId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddMemberGenreFilterMutationResult = NonNullable<Awaited<ReturnType<typeof addMemberGenreFilter>>>
    
    export type AddMemberGenreFilterMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary filter a genre for a user
 */
export const useAddMemberGenreFilter = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addMemberGenreFilter>>, TError,{id: number;genreId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof addMemberGenreFilter>>,
        TError,
        {id: number;genreId: number},
        TContext
      > => {

      const mutationOptions = getAddMemberGenreFilterMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary remove a filter for a genre for a user
 */
export const removeMemberGenreFilter = (
    id: number,
    genreId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.delete(
      `https://api.mangaupdates.com/v1/members/${id}/genre/${genreId}/filter`,options
    );
  }



export const getRemoveMemberGenreFilterMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeMemberGenreFilter>>, TError,{id: number;genreId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof removeMemberGenreFilter>>, TError,{id: number;genreId: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeMemberGenreFilter>>, {id: number;genreId: number}> = (props) => {
          const {id,genreId} = props ?? {};

          return  removeMemberGenreFilter(id,genreId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveMemberGenreFilterMutationResult = NonNullable<Awaited<ReturnType<typeof removeMemberGenreFilter>>>
    
    export type RemoveMemberGenreFilterMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary remove a filter for a genre for a user
 */
export const useRemoveMemberGenreFilter = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeMemberGenreFilter>>, TError,{id: number;genreId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof removeMemberGenreFilter>>,
        TError,
        {id: number;genreId: number},
        TContext
      > => {

      const mutationOptions = getRemoveMemberGenreFilterMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary get highlights for a specific user
 */
export const retrieveMemberGenreHighlights = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserGenreHighlightModelV1[]>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/members/${id}/genre/highlights`,options
    );
  }


export const getRetrieveMemberGenreHighlightsQueryKey = (id: number,) => {
    return [`https://api.mangaupdates.com/v1/members/${id}/genre/highlights`] as const;
    }

    
export const getRetrieveMemberGenreHighlightsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveMemberGenreHighlights>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveMemberGenreHighlights>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveMemberGenreHighlightsQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveMemberGenreHighlights>>> = ({ signal }) => retrieveMemberGenreHighlights(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveMemberGenreHighlights>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveMemberGenreHighlightsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveMemberGenreHighlights>>>
export type RetrieveMemberGenreHighlightsInfiniteQueryError = AxiosError<void>

/**
 * @summary get highlights for a specific user
 */
export const useRetrieveMemberGenreHighlightsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveMemberGenreHighlights>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveMemberGenreHighlights>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveMemberGenreHighlightsInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveMemberGenreHighlightsQueryOptions = <TData = Awaited<ReturnType<typeof retrieveMemberGenreHighlights>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveMemberGenreHighlights>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveMemberGenreHighlightsQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveMemberGenreHighlights>>> = ({ signal }) => retrieveMemberGenreHighlights(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveMemberGenreHighlights>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveMemberGenreHighlightsQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveMemberGenreHighlights>>>
export type RetrieveMemberGenreHighlightsQueryError = AxiosError<void>

/**
 * @summary get highlights for a specific user
 */
export const useRetrieveMemberGenreHighlights = <TData = Awaited<ReturnType<typeof retrieveMemberGenreHighlights>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveMemberGenreHighlights>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveMemberGenreHighlightsQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary highlight a genre for a user
 */
export const addMemberGenreHighlight = (
    id: number,
    genreId: number,
    userGenreHighlightModelUpdateV1: UserGenreHighlightModelUpdateV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/members/${id}/genre/${genreId}/highlight`,
      userGenreHighlightModelUpdateV1,options
    );
  }



export const getAddMemberGenreHighlightMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addMemberGenreHighlight>>, TError,{id: number;genreId: number;data: UserGenreHighlightModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addMemberGenreHighlight>>, TError,{id: number;genreId: number;data: UserGenreHighlightModelUpdateV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addMemberGenreHighlight>>, {id: number;genreId: number;data: UserGenreHighlightModelUpdateV1}> = (props) => {
          const {id,genreId,data} = props ?? {};

          return  addMemberGenreHighlight(id,genreId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddMemberGenreHighlightMutationResult = NonNullable<Awaited<ReturnType<typeof addMemberGenreHighlight>>>
    export type AddMemberGenreHighlightMutationBody = UserGenreHighlightModelUpdateV1
    export type AddMemberGenreHighlightMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary highlight a genre for a user
 */
export const useAddMemberGenreHighlight = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addMemberGenreHighlight>>, TError,{id: number;genreId: number;data: UserGenreHighlightModelUpdateV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof addMemberGenreHighlight>>,
        TError,
        {id: number;genreId: number;data: UserGenreHighlightModelUpdateV1},
        TContext
      > => {

      const mutationOptions = getAddMemberGenreHighlightMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary remove a highlight for a genre for a user
 */
export const removeMemberGenreHighlight = (
    id: number,
    genreId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.delete(
      `https://api.mangaupdates.com/v1/members/${id}/genre/${genreId}/highlight`,options
    );
  }



export const getRemoveMemberGenreHighlightMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeMemberGenreHighlight>>, TError,{id: number;genreId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof removeMemberGenreHighlight>>, TError,{id: number;genreId: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeMemberGenreHighlight>>, {id: number;genreId: number}> = (props) => {
          const {id,genreId} = props ?? {};

          return  removeMemberGenreHighlight(id,genreId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveMemberGenreHighlightMutationResult = NonNullable<Awaited<ReturnType<typeof removeMemberGenreHighlight>>>
    
    export type RemoveMemberGenreHighlightMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary remove a highlight for a genre for a user
 */
export const useRemoveMemberGenreHighlight = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeMemberGenreHighlight>>, TError,{id: number;genreId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof removeMemberGenreHighlight>>,
        TError,
        {id: number;genreId: number},
        TContext
      > => {

      const mutationOptions = getRemoveMemberGenreHighlightMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary reset genre highlights and filters for a user
 */
export const resetGenreSettings = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/members/${id}/genre/reset`,undefined,options
    );
  }



export const getResetGenreSettingsMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetGenreSettings>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof resetGenreSettings>>, TError,{id: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof resetGenreSettings>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  resetGenreSettings(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ResetGenreSettingsMutationResult = NonNullable<Awaited<ReturnType<typeof resetGenreSettings>>>
    
    export type ResetGenreSettingsMutationError = AxiosError<void>

    /**
 * @summary reset genre highlights and filters for a user
 */
export const useResetGenreSettings = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetGenreSettings>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof resetGenreSettings>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getResetGenreSettingsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary get group filters for a specific user
 */
export const retrieveMemberGroupFilters = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserGroupFilterModelV1[]>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/members/${id}/group/filters`,options
    );
  }


export const getRetrieveMemberGroupFiltersQueryKey = (id: number,) => {
    return [`https://api.mangaupdates.com/v1/members/${id}/group/filters`] as const;
    }

    
export const getRetrieveMemberGroupFiltersInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveMemberGroupFilters>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveMemberGroupFilters>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveMemberGroupFiltersQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveMemberGroupFilters>>> = ({ signal }) => retrieveMemberGroupFilters(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveMemberGroupFilters>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveMemberGroupFiltersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveMemberGroupFilters>>>
export type RetrieveMemberGroupFiltersInfiniteQueryError = AxiosError<void>

/**
 * @summary get group filters for a specific user
 */
export const useRetrieveMemberGroupFiltersInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveMemberGroupFilters>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveMemberGroupFilters>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveMemberGroupFiltersInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveMemberGroupFiltersQueryOptions = <TData = Awaited<ReturnType<typeof retrieveMemberGroupFilters>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveMemberGroupFilters>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveMemberGroupFiltersQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveMemberGroupFilters>>> = ({ signal }) => retrieveMemberGroupFilters(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveMemberGroupFilters>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveMemberGroupFiltersQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveMemberGroupFilters>>>
export type RetrieveMemberGroupFiltersQueryError = AxiosError<void>

/**
 * @summary get group filters for a specific user
 */
export const useRetrieveMemberGroupFilters = <TData = Awaited<ReturnType<typeof retrieveMemberGroupFilters>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveMemberGroupFilters>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveMemberGroupFiltersQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary filter a group for a user
 */
export const addUserGroupFilter = (
    id: number,
    groupId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/members/${id}/group/${groupId}/filter`,undefined,options
    );
  }



export const getAddUserGroupFilterMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addUserGroupFilter>>, TError,{id: number;groupId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addUserGroupFilter>>, TError,{id: number;groupId: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addUserGroupFilter>>, {id: number;groupId: number}> = (props) => {
          const {id,groupId} = props ?? {};

          return  addUserGroupFilter(id,groupId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddUserGroupFilterMutationResult = NonNullable<Awaited<ReturnType<typeof addUserGroupFilter>>>
    
    export type AddUserGroupFilterMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary filter a group for a user
 */
export const useAddUserGroupFilter = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addUserGroupFilter>>, TError,{id: number;groupId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof addUserGroupFilter>>,
        TError,
        {id: number;groupId: number},
        TContext
      > => {

      const mutationOptions = getAddUserGroupFilterMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary remove a filter for a group for a user
 */
export const removeUserGroupFilter = (
    id: number,
    groupId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.delete(
      `https://api.mangaupdates.com/v1/members/${id}/group/${groupId}/filter`,options
    );
  }



export const getRemoveUserGroupFilterMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeUserGroupFilter>>, TError,{id: number;groupId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof removeUserGroupFilter>>, TError,{id: number;groupId: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeUserGroupFilter>>, {id: number;groupId: number}> = (props) => {
          const {id,groupId} = props ?? {};

          return  removeUserGroupFilter(id,groupId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveUserGroupFilterMutationResult = NonNullable<Awaited<ReturnType<typeof removeUserGroupFilter>>>
    
    export type RemoveUserGroupFilterMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary remove a filter for a group for a user
 */
export const useRemoveUserGroupFilter = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeUserGroupFilter>>, TError,{id: number;groupId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof removeUserGroupFilter>>,
        TError,
        {id: number;groupId: number},
        TContext
      > => {

      const mutationOptions = getRemoveUserGroupFilterMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary get avatars for a specific user
 */
export const retrieveMemberAvatars = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AvatarModelV1[]>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/members/${id}/avatars`,options
    );
  }


export const getRetrieveMemberAvatarsQueryKey = (id: number,) => {
    return [`https://api.mangaupdates.com/v1/members/${id}/avatars`] as const;
    }

    
export const getRetrieveMemberAvatarsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveMemberAvatars>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveMemberAvatars>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveMemberAvatarsQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveMemberAvatars>>> = ({ signal }) => retrieveMemberAvatars(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveMemberAvatars>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveMemberAvatarsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveMemberAvatars>>>
export type RetrieveMemberAvatarsInfiniteQueryError = AxiosError<void>

/**
 * @summary get avatars for a specific user
 */
export const useRetrieveMemberAvatarsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveMemberAvatars>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveMemberAvatars>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveMemberAvatarsInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveMemberAvatarsQueryOptions = <TData = Awaited<ReturnType<typeof retrieveMemberAvatars>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveMemberAvatars>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveMemberAvatarsQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveMemberAvatars>>> = ({ signal }) => retrieveMemberAvatars(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveMemberAvatars>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveMemberAvatarsQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveMemberAvatars>>>
export type RetrieveMemberAvatarsQueryError = AxiosError<void>

/**
 * @summary get avatars for a specific user
 */
export const useRetrieveMemberAvatars = <TData = Awaited<ReturnType<typeof retrieveMemberAvatars>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveMemberAvatars>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveMemberAvatarsQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary search members
 */
export const searchMembersPost = (
    userSearchRequestV1: UserSearchRequestV1, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserSearchResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/members/search`,
      userSearchRequestV1,options
    );
  }



export const getSearchMembersPostMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchMembersPost>>, TError,{data: UserSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof searchMembersPost>>, TError,{data: UserSearchRequestV1}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchMembersPost>>, {data: UserSearchRequestV1}> = (props) => {
          const {data} = props ?? {};

          return  searchMembersPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchMembersPostMutationResult = NonNullable<Awaited<ReturnType<typeof searchMembersPost>>>
    export type SearchMembersPostMutationBody = UserSearchRequestV1
    export type SearchMembersPostMutationError = AxiosError<unknown>

    /**
 * @summary search members
 */
export const useSearchMembersPost = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchMembersPost>>, TError,{data: UserSearchRequestV1}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof searchMembersPost>>,
        TError,
        {data: UserSearchRequestV1},
        TContext
      > => {

      const mutationOptions = getSearchMembersPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary get topic subscriptions for a specific user
 */
export const retrieveMemberTopicSubscriptions = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserSubscribedTopicModelV1[]>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/members/${id}/topics`,options
    );
  }


export const getRetrieveMemberTopicSubscriptionsQueryKey = (id: number,) => {
    return [`https://api.mangaupdates.com/v1/members/${id}/topics`] as const;
    }

    
export const getRetrieveMemberTopicSubscriptionsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveMemberTopicSubscriptions>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveMemberTopicSubscriptions>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveMemberTopicSubscriptionsQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveMemberTopicSubscriptions>>> = ({ signal }) => retrieveMemberTopicSubscriptions(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveMemberTopicSubscriptions>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveMemberTopicSubscriptionsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveMemberTopicSubscriptions>>>
export type RetrieveMemberTopicSubscriptionsInfiniteQueryError = AxiosError<void>

/**
 * @summary get topic subscriptions for a specific user
 */
export const useRetrieveMemberTopicSubscriptionsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveMemberTopicSubscriptions>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveMemberTopicSubscriptions>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveMemberTopicSubscriptionsInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveMemberTopicSubscriptionsQueryOptions = <TData = Awaited<ReturnType<typeof retrieveMemberTopicSubscriptions>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveMemberTopicSubscriptions>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveMemberTopicSubscriptionsQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveMemberTopicSubscriptions>>> = ({ signal }) => retrieveMemberTopicSubscriptions(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveMemberTopicSubscriptions>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveMemberTopicSubscriptionsQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveMemberTopicSubscriptions>>>
export type RetrieveMemberTopicSubscriptionsQueryError = AxiosError<void>

/**
 * @summary get topic subscriptions for a specific user
 */
export const useRetrieveMemberTopicSubscriptions = <TData = Awaited<ReturnType<typeof retrieveMemberTopicSubscriptions>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveMemberTopicSubscriptions>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveMemberTopicSubscriptionsQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary get a subscription to a specific topic for a user
 */
export const retrieveMemberTopicSubscription = (
    id: number,
    topicId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserSubscribedTopicModelV1>> => {
    
    return axios.get(
      `https://api.mangaupdates.com/v1/members/${id}/topics/${topicId}`,options
    );
  }


export const getRetrieveMemberTopicSubscriptionQueryKey = (id: number,
    topicId: number,) => {
    return [`https://api.mangaupdates.com/v1/members/${id}/topics/${topicId}`] as const;
    }

    
export const getRetrieveMemberTopicSubscriptionInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveMemberTopicSubscription>>>, TError = AxiosError<void>>(id: number,
    topicId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveMemberTopicSubscription>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveMemberTopicSubscriptionQueryKey(id,topicId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveMemberTopicSubscription>>> = ({ signal }) => retrieveMemberTopicSubscription(id,topicId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id && topicId),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveMemberTopicSubscription>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveMemberTopicSubscriptionInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveMemberTopicSubscription>>>
export type RetrieveMemberTopicSubscriptionInfiniteQueryError = AxiosError<void>

/**
 * @summary get a subscription to a specific topic for a user
 */
export const useRetrieveMemberTopicSubscriptionInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof retrieveMemberTopicSubscription>>>, TError = AxiosError<void>>(
 id: number,
    topicId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof retrieveMemberTopicSubscription>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveMemberTopicSubscriptionInfiniteQueryOptions(id,topicId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRetrieveMemberTopicSubscriptionQueryOptions = <TData = Awaited<ReturnType<typeof retrieveMemberTopicSubscription>>, TError = AxiosError<void>>(id: number,
    topicId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveMemberTopicSubscription>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRetrieveMemberTopicSubscriptionQueryKey(id,topicId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveMemberTopicSubscription>>> = ({ signal }) => retrieveMemberTopicSubscription(id,topicId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id && topicId),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof retrieveMemberTopicSubscription>>, TError, TData> & { queryKey: QueryKey }
}

export type RetrieveMemberTopicSubscriptionQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveMemberTopicSubscription>>>
export type RetrieveMemberTopicSubscriptionQueryError = AxiosError<void>

/**
 * @summary get a subscription to a specific topic for a user
 */
export const useRetrieveMemberTopicSubscription = <TData = Awaited<ReturnType<typeof retrieveMemberTopicSubscription>>, TError = AxiosError<void>>(
 id: number,
    topicId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveMemberTopicSubscription>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRetrieveMemberTopicSubscriptionQueryOptions(id,topicId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary add a topic subscription for a user
 */
export const addUserTopicSubscription = (
    id: number,
    topicId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/members/${id}/topics/${topicId}`,undefined,options
    );
  }



export const getAddUserTopicSubscriptionMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addUserTopicSubscription>>, TError,{id: number;topicId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addUserTopicSubscription>>, TError,{id: number;topicId: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addUserTopicSubscription>>, {id: number;topicId: number}> = (props) => {
          const {id,topicId} = props ?? {};

          return  addUserTopicSubscription(id,topicId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddUserTopicSubscriptionMutationResult = NonNullable<Awaited<ReturnType<typeof addUserTopicSubscription>>>
    
    export type AddUserTopicSubscriptionMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary add a topic subscription for a user
 */
export const useAddUserTopicSubscription = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addUserTopicSubscription>>, TError,{id: number;topicId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof addUserTopicSubscription>>,
        TError,
        {id: number;topicId: number},
        TContext
      > => {

      const mutationOptions = getAddUserTopicSubscriptionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary remove a topic subscription for a user
 */
export const removeUserTopicSubscription = (
    id: number,
    topicId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.delete(
      `https://api.mangaupdates.com/v1/members/${id}/topics/${topicId}`,options
    );
  }



export const getRemoveUserTopicSubscriptionMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeUserTopicSubscription>>, TError,{id: number;topicId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof removeUserTopicSubscription>>, TError,{id: number;topicId: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeUserTopicSubscription>>, {id: number;topicId: number}> = (props) => {
          const {id,topicId} = props ?? {};

          return  removeUserTopicSubscription(id,topicId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveUserTopicSubscriptionMutationResult = NonNullable<Awaited<ReturnType<typeof removeUserTopicSubscription>>>
    
    export type RemoveUserTopicSubscriptionMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary remove a topic subscription for a user
 */
export const useRemoveUserTopicSubscription = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeUserTopicSubscription>>, TError,{id: number;topicId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof removeUserTopicSubscription>>,
        TError,
        {id: number;topicId: number},
        TContext
      > => {

      const mutationOptions = getRemoveUserTopicSubscriptionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary add a new member avatar
 */
export const addMemberAvatar = (
    id: number,
    addMemberAvatarBody: AddMemberAvatarBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {const formData = new FormData();
if(addMemberAvatarBody.image !== undefined) {
 formData.append('image', addMemberAvatarBody.image)
 }
if(addMemberAvatarBody.title !== undefined) {
 formData.append('title', addMemberAvatarBody.title)
 }

    
    return axios.post(
      `https://api.mangaupdates.com/v1/members/${id}/avatar`,
      formData,options
    );
  }



export const getAddMemberAvatarMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addMemberAvatar>>, TError,{id: number;data: AddMemberAvatarBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addMemberAvatar>>, TError,{id: number;data: AddMemberAvatarBody}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addMemberAvatar>>, {id: number;data: AddMemberAvatarBody}> = (props) => {
          const {id,data} = props ?? {};

          return  addMemberAvatar(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddMemberAvatarMutationResult = NonNullable<Awaited<ReturnType<typeof addMemberAvatar>>>
    export type AddMemberAvatarMutationBody = AddMemberAvatarBody
    export type AddMemberAvatarMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary add a new member avatar
 */
export const useAddMemberAvatar = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addMemberAvatar>>, TError,{id: number;data: AddMemberAvatarBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof addMemberAvatar>>,
        TError,
        {id: number;data: AddMemberAvatarBody},
        TContext
      > => {

      const mutationOptions = getAddMemberAvatarMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary delete a member avatar
 */
export const deleteMemberAvatar = (
    id: number,
    avatarId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.delete(
      `https://api.mangaupdates.com/v1/members/${id}/avatar/${avatarId}`,options
    );
  }



export const getDeleteMemberAvatarMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteMemberAvatar>>, TError,{id: number;avatarId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteMemberAvatar>>, TError,{id: number;avatarId: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteMemberAvatar>>, {id: number;avatarId: number}> = (props) => {
          const {id,avatarId} = props ?? {};

          return  deleteMemberAvatar(id,avatarId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteMemberAvatarMutationResult = NonNullable<Awaited<ReturnType<typeof deleteMemberAvatar>>>
    
    export type DeleteMemberAvatarMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary delete a member avatar
 */
export const useDeleteMemberAvatar = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteMemberAvatar>>, TError,{id: number;avatarId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteMemberAvatar>>,
        TError,
        {id: number;avatarId: number},
        TContext
      > => {

      const mutationOptions = getDeleteMemberAvatarMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary upgrade a member
 */
export const approveMemberUpgrade = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/members/${id}/upgrade/approve`,undefined,options
    );
  }



export const getApproveMemberUpgradeMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof approveMemberUpgrade>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof approveMemberUpgrade>>, TError,{id: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof approveMemberUpgrade>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  approveMemberUpgrade(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApproveMemberUpgradeMutationResult = NonNullable<Awaited<ReturnType<typeof approveMemberUpgrade>>>
    
    export type ApproveMemberUpgradeMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary upgrade a member
 */
export const useApproveMemberUpgrade = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof approveMemberUpgrade>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof approveMemberUpgrade>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getApproveMemberUpgradeMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary reject a member upgrade
 */
export const rejectMemberUpgrade = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseV1>> => {
    
    return axios.post(
      `https://api.mangaupdates.com/v1/members/${id}/upgrade/reject`,undefined,options
    );
  }



export const getRejectMemberUpgradeMutationOptions = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rejectMemberUpgrade>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof rejectMemberUpgrade>>, TError,{id: number}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof rejectMemberUpgrade>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  rejectMemberUpgrade(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RejectMemberUpgradeMutationResult = NonNullable<Awaited<ReturnType<typeof rejectMemberUpgrade>>>
    
    export type RejectMemberUpgradeMutationError = AxiosError<ApiResponseV1 | void>

    /**
 * @summary reject a member upgrade
 */
export const useRejectMemberUpgrade = <TError = AxiosError<ApiResponseV1 | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rejectMemberUpgrade>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof rejectMemberUpgrade>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getRejectMemberUpgradeMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
