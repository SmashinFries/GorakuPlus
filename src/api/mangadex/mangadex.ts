/**
 * Generated by orval v6.31.0 üç∫
 * Do not edit manually.
 * MangaDex API
 * MangaDex is an ad-free manga reader offering high-quality images!

This document details our API as it is right now. It is in no way a promise to never change it, although we will endeavour to publicly notify any major change.

# Acceptable use policy

Usage of our services implies acceptance of the following:
- You **MUST** credit us
- You **MUST** credit scanlation groups if you offer the ability to read chapters
- You **CANNOT** run ads or paid services on your website and/or apps

These may change at any time for any and no reason and it is up to you check for updates from time to time.

# Security issues

If you believe you found a security issue in our API, please check our [security.txt](/security.txt) to get in touch privately.

 * OpenAPI spec version: 5.10.2
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  InfiniteData,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import axios from 'axios'
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios'
import type {
  ApiClientCreate,
  ApiClientEdit,
  ApiClientList,
  ApiClientResponse,
  AuthorCreate,
  AuthorEdit,
  AuthorList,
  AuthorResponse,
  BeginEditSession,
  BeginUploadSession,
  Chapter,
  ChapterEdit,
  ChapterList,
  ChapterReadMarkerBatch,
  ChapterResponse,
  CheckResponse,
  CommitMangaDraftBody,
  CommitUploadSession,
  CoverEdit,
  CoverList,
  CoverResponse,
  CreateScanlationGroup,
  CustomListCreate,
  CustomListEdit,
  CustomListList,
  CustomListResponse,
  DeleteApiclient200,
  DeleteApiclientParams,
  ErrorResponse,
  FollowListId200,
  FollowListIdBody,
  ForumsThreadCreateBody,
  ForumsThreadResponse,
  GetApiclientParams,
  GetApiclientSecret200,
  GetAtHomeServerChapterId200,
  GetAtHomeServerChapterIdParams,
  GetAuthorIdParams,
  GetAuthorParams,
  GetChapterIdParams,
  GetChapterParams,
  GetCoverIdParams,
  GetCoverParams,
  GetGroupIdParams,
  GetListApiclientsParams,
  GetListIdFeedParams,
  GetMangaAggregate200,
  GetMangaAggregateParams,
  GetMangaChapterReadmarkers200,
  GetMangaChapterReadmarkers2200,
  GetMangaChapterReadmarkers2Params,
  GetMangaDraftsParams,
  GetMangaIdDraftParams,
  GetMangaIdFeedParams,
  GetMangaIdParams,
  GetMangaIdStatus200,
  GetMangaRandomParams,
  GetMangaRelationParams,
  GetMangaStatus200,
  GetMangaStatusParams,
  GetRating200,
  GetRatingParams,
  GetReadingHistory200,
  GetReportReasonsByCategory200,
  GetReportsParams,
  GetSearchGroupParams,
  GetSearchMangaParams,
  GetSettings200,
  GetSettingsTemplate200,
  GetSettingsTemplateVersion200,
  GetStatisticsChapterUuid200,
  GetStatisticsChapters200,
  GetStatisticsChaptersParams,
  GetStatisticsGroupUuid200,
  GetStatisticsGroups200,
  GetStatisticsGroupsParams,
  GetStatisticsManga200,
  GetStatisticsMangaParams,
  GetStatisticsMangaUuid200,
  GetUserFollowsGroupParams,
  GetUserFollowsListParams,
  GetUserFollowsMangaFeedParams,
  GetUserFollowsMangaParams,
  GetUserFollowsUserParams,
  GetUserIdListParams,
  GetUserListParams,
  GetUserParams,
  Login,
  LoginResponse,
  LogoutResponse,
  MangaCreate,
  MangaList,
  MangaRelationCreate,
  MangaRelationList,
  MangaRelationResponse,
  MangaResponse,
  MappingIdBody,
  MappingIdResponse,
  PostCaptchaSolve200,
  PostCaptchaSolveBody,
  PostMangaChapterReadmarkers200,
  PostMangaChapterReadmarkersParams,
  PostRatingMangaIdBody,
  PostRegenerateApiclientSecret200,
  PostRegenerateApiclientSecretBody,
  PostReportBody,
  PostSettings200,
  PostSettingsBody,
  PostSettingsTemplate200,
  PostSettingsTemplateBody,
  PutMangaIdBody,
  PutUploadSessionFile200,
  PutUploadSessionFileBody,
  RefreshResponse,
  RefreshToken,
  ReportListResponse,
  Response,
  ScanlationGroupEdit,
  ScanlationGroupList,
  ScanlationGroupResponse,
  TagResponse,
  UnfollowListId200,
  UnfollowListIdBody,
  UpdateMangaStatus,
  UploadCheckApprovalRequired200,
  UploadCheckApprovalRequiredBody,
  UploadCoverBody,
  UploadSession,
  UserList,
  UserResponse
} from './models'




/**
 * Returns a plaintext response containing only the word "pong" if the API is healthy
 * @summary Ping healthcheck
 */
export const getPing = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    return axios.get(
      `/ping`,options
    );
  }


export const getGetPingQueryKey = () => {
    return [`/ping`] as const;
    }

    
export const getGetPingQueryOptions = <TData = Awaited<ReturnType<typeof getPing>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPing>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPingQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPing>>> = ({ signal }) => getPing({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPing>>, TError, TData> & { queryKey: QueryKey }
}

export type GetPingQueryResult = NonNullable<Awaited<ReturnType<typeof getPing>>>
export type GetPingQueryError = AxiosError<unknown>

/**
 * @summary Ping healthcheck
 */
export const useGetPing = <TData = Awaited<ReturnType<typeof getPing>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPing>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetPingQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Search a list of Manga.
 * @summary Manga list
 */
export const getSearchManga = (
    params?: GetSearchMangaParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MangaList>> => {
    
    return axios.get(
      `/manga`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetSearchMangaQueryKey = (params?: GetSearchMangaParams,) => {
    return [`/manga`, ...(params ? [params]: [])] as const;
    }

    
export const getGetSearchMangaInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSearchManga>>, GetSearchMangaParams['offset']>, TError = AxiosError<ErrorResponse>>(params?: GetSearchMangaParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSearchManga>>, TError, TData, Awaited<ReturnType<typeof getSearchManga>>, QueryKey, GetSearchMangaParams['offset']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSearchMangaQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSearchManga>>, QueryKey, GetSearchMangaParams['offset']> = ({ signal, pageParam }) => getSearchManga({...params, offset: pageParam || params?.['offset']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSearchManga>>, TError, TData, Awaited<ReturnType<typeof getSearchManga>>, QueryKey, GetSearchMangaParams['offset']> & { queryKey: QueryKey }
}

export type GetSearchMangaInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSearchManga>>>
export type GetSearchMangaInfiniteQueryError = AxiosError<ErrorResponse>

/**
 * @summary Manga list
 */
export const useGetSearchMangaInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getSearchManga>>, GetSearchMangaParams['offset']>, TError = AxiosError<ErrorResponse>>(
 params?: GetSearchMangaParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSearchManga>>, TError, TData, Awaited<ReturnType<typeof getSearchManga>>, QueryKey, GetSearchMangaParams['offset']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSearchMangaInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new Manga.
 * @summary Create Manga
 */
export const postManga = (
    mangaCreate: MangaCreate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MangaResponse>> => {
    
    return axios.post(
      `/manga`,
      mangaCreate,options
    );
  }



export const getPostMangaMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postManga>>, TError,{data: MangaCreate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postManga>>, TError,{data: MangaCreate}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postManga>>, {data: MangaCreate}> = (props) => {
          const {data} = props ?? {};

          return  postManga(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostMangaMutationResult = NonNullable<Awaited<ReturnType<typeof postManga>>>
    export type PostMangaMutationBody = MangaCreate
    export type PostMangaMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create Manga
 */
export const usePostManga = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postManga>>, TError,{data: MangaCreate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postManga>>,
        TError,
        {data: MangaCreate},
        TContext
      > => {

      const mutationOptions = getPostMangaMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get Manga volumes & chapters
 */
export const getMangaAggregate = (
    id: string,
    params?: GetMangaAggregateParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetMangaAggregate200>> => {
    
    return axios.get(
      `/manga/${id}/aggregate`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetMangaAggregateQueryKey = (id: string,
    params?: GetMangaAggregateParams,) => {
    return [`/manga/${id}/aggregate`, ...(params ? [params]: [])] as const;
    }

    
export const getGetMangaAggregateQueryOptions = <TData = Awaited<ReturnType<typeof getMangaAggregate>>, TError = AxiosError<unknown>>(id: string,
    params?: GetMangaAggregateParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaAggregate>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMangaAggregateQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMangaAggregate>>> = ({ signal }) => getMangaAggregate(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMangaAggregate>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMangaAggregateQueryResult = NonNullable<Awaited<ReturnType<typeof getMangaAggregate>>>
export type GetMangaAggregateQueryError = AxiosError<unknown>

/**
 * @summary Get Manga volumes & chapters
 */
export const useGetMangaAggregate = <TData = Awaited<ReturnType<typeof getMangaAggregate>>, TError = AxiosError<unknown>>(
 id: string,
    params?: GetMangaAggregateParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaAggregate>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMangaAggregateQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get Manga.
 * @summary Get Manga
 */
export const getMangaId = (
    id: string,
    params?: GetMangaIdParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MangaResponse>> => {
    
    return axios.get(
      `/manga/${id}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetMangaIdQueryKey = (id: string,
    params?: GetMangaIdParams,) => {
    return [`/manga/${id}`, ...(params ? [params]: [])] as const;
    }

    
export const getGetMangaIdQueryOptions = <TData = Awaited<ReturnType<typeof getMangaId>>, TError = AxiosError<ErrorResponse>>(id: string,
    params?: GetMangaIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMangaIdQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMangaId>>> = ({ signal }) => getMangaId(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMangaId>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMangaIdQueryResult = NonNullable<Awaited<ReturnType<typeof getMangaId>>>
export type GetMangaIdQueryError = AxiosError<ErrorResponse>

/**
 * @summary Get Manga
 */
export const useGetMangaId = <TData = Awaited<ReturnType<typeof getMangaId>>, TError = AxiosError<ErrorResponse>>(
 id: string,
    params?: GetMangaIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMangaIdQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update Manga
 */
export const putMangaId = (
    id: string,
    putMangaIdBody: PutMangaIdBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MangaResponse>> => {
    
    return axios.put(
      `/manga/${id}`,
      putMangaIdBody,options
    );
  }



export const getPutMangaIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putMangaId>>, TError,{id: string;data: PutMangaIdBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof putMangaId>>, TError,{id: string;data: PutMangaIdBody}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putMangaId>>, {id: string;data: PutMangaIdBody}> = (props) => {
          const {id,data} = props ?? {};

          return  putMangaId(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutMangaIdMutationResult = NonNullable<Awaited<ReturnType<typeof putMangaId>>>
    export type PutMangaIdMutationBody = PutMangaIdBody
    export type PutMangaIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Update Manga
 */
export const usePutMangaId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putMangaId>>, TError,{id: string;data: PutMangaIdBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof putMangaId>>,
        TError,
        {id: string;data: PutMangaIdBody},
        TContext
      > => {

      const mutationOptions = getPutMangaIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete Manga
 */
export const deleteMangaId = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Response>> => {
    
    return axios.delete(
      `/manga/${id}`,options
    );
  }



export const getDeleteMangaIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteMangaId>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteMangaId>>, TError,{id: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteMangaId>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteMangaId(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteMangaIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteMangaId>>>
    
    export type DeleteMangaIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Delete Manga
 */
export const useDeleteMangaId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteMangaId>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteMangaId>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteMangaIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @deprecated
 * @summary Login
 */
export const postAuthLogin = (
    login: Login, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<LoginResponse>> => {
    
    return axios.post(
      `/auth/login`,
      login,options
    );
  }



export const getPostAuthLoginMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAuthLogin>>, TError,{data: Login}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postAuthLogin>>, TError,{data: Login}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAuthLogin>>, {data: Login}> = (props) => {
          const {data} = props ?? {};

          return  postAuthLogin(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAuthLoginMutationResult = NonNullable<Awaited<ReturnType<typeof postAuthLogin>>>
    export type PostAuthLoginMutationBody = Login
    export type PostAuthLoginMutationError = AxiosError<ErrorResponse>

    /**
 * @deprecated
 * @summary Login
 */
export const usePostAuthLogin = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAuthLogin>>, TError,{data: Login}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postAuthLogin>>,
        TError,
        {data: Login},
        TContext
      > => {

      const mutationOptions = getPostAuthLoginMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * The returned list of permissions is computed depending on the generic role permissions that the token user has, their personal overrides, and the OpenID scopes of the token (we do not offer granular token permissions yet)

 * @summary Check the set of permissions associated with the current token
 */
export const getAuthCheck = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CheckResponse>> => {
    
    return axios.get(
      `/auth/check`,options
    );
  }


export const getGetAuthCheckQueryKey = () => {
    return [`/auth/check`] as const;
    }

    
export const getGetAuthCheckQueryOptions = <TData = Awaited<ReturnType<typeof getAuthCheck>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthCheck>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAuthCheckQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuthCheck>>> = ({ signal }) => getAuthCheck({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAuthCheck>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAuthCheckQueryResult = NonNullable<Awaited<ReturnType<typeof getAuthCheck>>>
export type GetAuthCheckQueryError = AxiosError<unknown>

/**
 * @summary Check the set of permissions associated with the current token
 */
export const useGetAuthCheck = <TData = Awaited<ReturnType<typeof getAuthCheck>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthCheck>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAuthCheckQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @deprecated
 * @summary Logout
 */
export const postAuthLogout = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<LogoutResponse>> => {
    
    return axios.post(
      `/auth/logout`,undefined,options
    );
  }



export const getPostAuthLogoutMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAuthLogout>>, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postAuthLogout>>, TError,void, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAuthLogout>>, void> = () => {
          

          return  postAuthLogout(axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAuthLogoutMutationResult = NonNullable<Awaited<ReturnType<typeof postAuthLogout>>>
    
    export type PostAuthLogoutMutationError = AxiosError<ErrorResponse>

    /**
 * @deprecated
 * @summary Logout
 */
export const usePostAuthLogout = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAuthLogout>>, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postAuthLogout>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getPostAuthLogoutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @deprecated
 * @summary Refresh token
 */
export const postAuthRefresh = (
    refreshToken: RefreshToken, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<RefreshResponse>> => {
    
    return axios.post(
      `/auth/refresh`,
      refreshToken,options
    );
  }



export const getPostAuthRefreshMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAuthRefresh>>, TError,{data: RefreshToken}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postAuthRefresh>>, TError,{data: RefreshToken}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAuthRefresh>>, {data: RefreshToken}> = (props) => {
          const {data} = props ?? {};

          return  postAuthRefresh(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAuthRefreshMutationResult = NonNullable<Awaited<ReturnType<typeof postAuthRefresh>>>
    export type PostAuthRefreshMutationBody = RefreshToken
    export type PostAuthRefreshMutationError = AxiosError<ErrorResponse>

    /**
 * @deprecated
 * @summary Refresh token
 */
export const usePostAuthRefresh = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAuthRefresh>>, TError,{data: RefreshToken}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postAuthRefresh>>,
        TError,
        {data: RefreshToken},
        TContext
      > => {

      const mutationOptions = getPostAuthRefreshMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary List own Api Clients
 */
export const getListApiclients = (
    params?: GetListApiclientsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiClientList>> => {
    
    return axios.get(
      `/client`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetListApiclientsQueryKey = (params?: GetListApiclientsParams,) => {
    return [`/client`, ...(params ? [params]: [])] as const;
    }

    
export const getGetListApiclientsQueryOptions = <TData = Awaited<ReturnType<typeof getListApiclients>>, TError = AxiosError<unknown>>(params?: GetListApiclientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getListApiclients>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetListApiclientsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getListApiclients>>> = ({ signal }) => getListApiclients(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getListApiclients>>, TError, TData> & { queryKey: QueryKey }
}

export type GetListApiclientsQueryResult = NonNullable<Awaited<ReturnType<typeof getListApiclients>>>
export type GetListApiclientsQueryError = AxiosError<unknown>

/**
 * @summary List own Api Clients
 */
export const useGetListApiclients = <TData = Awaited<ReturnType<typeof getListApiclients>>, TError = AxiosError<unknown>>(
 params?: GetListApiclientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getListApiclients>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetListApiclientsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create ApiClient
 */
export const postCreateApiclient = (
    apiClientCreate: ApiClientCreate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiClientResponse>> => {
    
    return axios.post(
      `/client`,
      apiClientCreate,options
    );
  }



export const getPostCreateApiclientMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postCreateApiclient>>, TError,{data: ApiClientCreate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postCreateApiclient>>, TError,{data: ApiClientCreate}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postCreateApiclient>>, {data: ApiClientCreate}> = (props) => {
          const {data} = props ?? {};

          return  postCreateApiclient(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostCreateApiclientMutationResult = NonNullable<Awaited<ReturnType<typeof postCreateApiclient>>>
    export type PostCreateApiclientMutationBody = ApiClientCreate
    export type PostCreateApiclientMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create ApiClient
 */
export const usePostCreateApiclient = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postCreateApiclient>>, TError,{data: ApiClientCreate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postCreateApiclient>>,
        TError,
        {data: ApiClientCreate},
        TContext
      > => {

      const mutationOptions = getPostCreateApiclientMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get Api Client by ID
 */
export const getApiclient = (
    id: string,
    params?: GetApiclientParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiClientResponse>> => {
    
    return axios.get(
      `/client/${id}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetApiclientQueryKey = (id: string,
    params?: GetApiclientParams,) => {
    return [`/client/${id}`, ...(params ? [params]: [])] as const;
    }

    
export const getGetApiclientQueryOptions = <TData = Awaited<ReturnType<typeof getApiclient>>, TError = AxiosError<ErrorResponse>>(id: string,
    params?: GetApiclientParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiclient>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiclientQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiclient>>> = ({ signal }) => getApiclient(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiclient>>, TError, TData> & { queryKey: QueryKey }
}

export type GetApiclientQueryResult = NonNullable<Awaited<ReturnType<typeof getApiclient>>>
export type GetApiclientQueryError = AxiosError<ErrorResponse>

/**
 * @summary Get Api Client by ID
 */
export const useGetApiclient = <TData = Awaited<ReturnType<typeof getApiclient>>, TError = AxiosError<ErrorResponse>>(
 id: string,
    params?: GetApiclientParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiclient>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetApiclientQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Edit ApiClient
 */
export const postEditApiclient = (
    id: string,
    apiClientEdit: ApiClientEdit, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiClientResponse>> => {
    
    return axios.post(
      `/client/${id}`,
      apiClientEdit,options
    );
  }



export const getPostEditApiclientMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postEditApiclient>>, TError,{id: string;data: ApiClientEdit}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postEditApiclient>>, TError,{id: string;data: ApiClientEdit}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postEditApiclient>>, {id: string;data: ApiClientEdit}> = (props) => {
          const {id,data} = props ?? {};

          return  postEditApiclient(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostEditApiclientMutationResult = NonNullable<Awaited<ReturnType<typeof postEditApiclient>>>
    export type PostEditApiclientMutationBody = ApiClientEdit
    export type PostEditApiclientMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Edit ApiClient
 */
export const usePostEditApiclient = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postEditApiclient>>, TError,{id: string;data: ApiClientEdit}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postEditApiclient>>,
        TError,
        {id: string;data: ApiClientEdit},
        TContext
      > => {

      const mutationOptions = getPostEditApiclientMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete Api Client
 */
export const deleteApiclient = (
    id: string,
    params?: DeleteApiclientParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DeleteApiclient200>> => {
    
    return axios.delete(
      `/client/${id}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getDeleteApiclientMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteApiclient>>, TError,{id: string;params?: DeleteApiclientParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteApiclient>>, TError,{id: string;params?: DeleteApiclientParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteApiclient>>, {id: string;params?: DeleteApiclientParams}> = (props) => {
          const {id,params} = props ?? {};

          return  deleteApiclient(id,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteApiclientMutationResult = NonNullable<Awaited<ReturnType<typeof deleteApiclient>>>
    
    export type DeleteApiclientMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Delete Api Client
 */
export const useDeleteApiclient = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteApiclient>>, TError,{id: string;params?: DeleteApiclientParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteApiclient>>,
        TError,
        {id: string;params?: DeleteApiclientParams},
        TContext
      > => {

      const mutationOptions = getDeleteApiclientMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get Secret for Client by ID
 */
export const getApiclientSecret = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetApiclientSecret200>> => {
    
    return axios.get(
      `/client/${id}/secret`,options
    );
  }


export const getGetApiclientSecretQueryKey = (id: string,) => {
    return [`/client/${id}/secret`] as const;
    }

    
export const getGetApiclientSecretQueryOptions = <TData = Awaited<ReturnType<typeof getApiclientSecret>>, TError = AxiosError<ErrorResponse>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiclientSecret>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiclientSecretQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiclientSecret>>> = ({ signal }) => getApiclientSecret(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiclientSecret>>, TError, TData> & { queryKey: QueryKey }
}

export type GetApiclientSecretQueryResult = NonNullable<Awaited<ReturnType<typeof getApiclientSecret>>>
export type GetApiclientSecretQueryError = AxiosError<ErrorResponse>

/**
 * @summary Get Secret for Client by ID
 */
export const useGetApiclientSecret = <TData = Awaited<ReturnType<typeof getApiclientSecret>>, TError = AxiosError<ErrorResponse>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiclientSecret>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetApiclientSecretQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Regenerate Client Secret
 */
export const postRegenerateApiclientSecret = (
    id: string,
    postRegenerateApiclientSecretBody: PostRegenerateApiclientSecretBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PostRegenerateApiclientSecret200>> => {
    
    return axios.post(
      `/client/${id}/secret`,
      postRegenerateApiclientSecretBody,options
    );
  }



export const getPostRegenerateApiclientSecretMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postRegenerateApiclientSecret>>, TError,{id: string;data: PostRegenerateApiclientSecretBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postRegenerateApiclientSecret>>, TError,{id: string;data: PostRegenerateApiclientSecretBody}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postRegenerateApiclientSecret>>, {id: string;data: PostRegenerateApiclientSecretBody}> = (props) => {
          const {id,data} = props ?? {};

          return  postRegenerateApiclientSecret(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostRegenerateApiclientSecretMutationResult = NonNullable<Awaited<ReturnType<typeof postRegenerateApiclientSecret>>>
    export type PostRegenerateApiclientSecretMutationBody = PostRegenerateApiclientSecretBody
    export type PostRegenerateApiclientSecretMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Regenerate Client Secret
 */
export const usePostRegenerateApiclientSecret = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postRegenerateApiclientSecret>>, TError,{id: string;data: PostRegenerateApiclientSecretBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postRegenerateApiclientSecret>>,
        TError,
        {id: string;data: PostRegenerateApiclientSecretBody},
        TContext
      > => {

      const mutationOptions = getPostRegenerateApiclientSecretMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Scanlation Group list
 */
export const getSearchGroup = (
    params?: GetSearchGroupParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ScanlationGroupList>> => {
    
    return axios.get(
      `/group`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetSearchGroupQueryKey = (params?: GetSearchGroupParams,) => {
    return [`/group`, ...(params ? [params]: [])] as const;
    }

    
export const getGetSearchGroupQueryOptions = <TData = Awaited<ReturnType<typeof getSearchGroup>>, TError = AxiosError<ErrorResponse>>(params?: GetSearchGroupParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSearchGroup>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSearchGroupQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSearchGroup>>> = ({ signal }) => getSearchGroup(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSearchGroup>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSearchGroupQueryResult = NonNullable<Awaited<ReturnType<typeof getSearchGroup>>>
export type GetSearchGroupQueryError = AxiosError<ErrorResponse>

/**
 * @summary Scanlation Group list
 */
export const useGetSearchGroup = <TData = Awaited<ReturnType<typeof getSearchGroup>>, TError = AxiosError<ErrorResponse>>(
 params?: GetSearchGroupParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSearchGroup>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSearchGroupQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create Scanlation Group
 */
export const postGroup = (
    createScanlationGroup: CreateScanlationGroup, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ScanlationGroupResponse>> => {
    
    return axios.post(
      `/group`,
      createScanlationGroup,options
    );
  }



export const getPostGroupMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postGroup>>, TError,{data: CreateScanlationGroup}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postGroup>>, TError,{data: CreateScanlationGroup}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postGroup>>, {data: CreateScanlationGroup}> = (props) => {
          const {data} = props ?? {};

          return  postGroup(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostGroupMutationResult = NonNullable<Awaited<ReturnType<typeof postGroup>>>
    export type PostGroupMutationBody = CreateScanlationGroup
    export type PostGroupMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create Scanlation Group
 */
export const usePostGroup = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postGroup>>, TError,{data: CreateScanlationGroup}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postGroup>>,
        TError,
        {data: CreateScanlationGroup},
        TContext
      > => {

      const mutationOptions = getPostGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get Scanlation Group
 */
export const getGroupId = (
    id: string,
    params?: GetGroupIdParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ScanlationGroupResponse>> => {
    
    return axios.get(
      `/group/${id}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetGroupIdQueryKey = (id: string,
    params?: GetGroupIdParams,) => {
    return [`/group/${id}`, ...(params ? [params]: [])] as const;
    }

    
export const getGetGroupIdQueryOptions = <TData = Awaited<ReturnType<typeof getGroupId>>, TError = AxiosError<ErrorResponse>>(id: string,
    params?: GetGroupIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroupId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGroupIdQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroupId>>> = ({ signal }) => getGroupId(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getGroupId>>, TError, TData> & { queryKey: QueryKey }
}

export type GetGroupIdQueryResult = NonNullable<Awaited<ReturnType<typeof getGroupId>>>
export type GetGroupIdQueryError = AxiosError<ErrorResponse>

/**
 * @summary Get Scanlation Group
 */
export const useGetGroupId = <TData = Awaited<ReturnType<typeof getGroupId>>, TError = AxiosError<ErrorResponse>>(
 id: string,
    params?: GetGroupIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroupId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetGroupIdQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update Scanlation Group
 */
export const putGroupId = (
    id: string,
    scanlationGroupEdit: ScanlationGroupEdit, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ScanlationGroupResponse>> => {
    
    return axios.put(
      `/group/${id}`,
      scanlationGroupEdit,options
    );
  }



export const getPutGroupIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putGroupId>>, TError,{id: string;data: ScanlationGroupEdit}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof putGroupId>>, TError,{id: string;data: ScanlationGroupEdit}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putGroupId>>, {id: string;data: ScanlationGroupEdit}> = (props) => {
          const {id,data} = props ?? {};

          return  putGroupId(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutGroupIdMutationResult = NonNullable<Awaited<ReturnType<typeof putGroupId>>>
    export type PutGroupIdMutationBody = ScanlationGroupEdit
    export type PutGroupIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Update Scanlation Group
 */
export const usePutGroupId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putGroupId>>, TError,{id: string;data: ScanlationGroupEdit}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof putGroupId>>,
        TError,
        {id: string;data: ScanlationGroupEdit},
        TContext
      > => {

      const mutationOptions = getPutGroupIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete Scanlation Group
 */
export const deleteGroupId = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Response>> => {
    
    return axios.delete(
      `/group/${id}`,options
    );
  }



export const getDeleteGroupIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteGroupId>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteGroupId>>, TError,{id: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteGroupId>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteGroupId(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteGroupIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteGroupId>>>
    
    export type DeleteGroupIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Delete Scanlation Group
 */
export const useDeleteGroupId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteGroupId>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteGroupId>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteGroupIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Follow Scanlation Group
 */
export const postGroupIdFollow = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Response>> => {
    
    return axios.post(
      `/group/${id}/follow`,undefined,options
    );
  }



export const getPostGroupIdFollowMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postGroupIdFollow>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postGroupIdFollow>>, TError,{id: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postGroupIdFollow>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  postGroupIdFollow(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostGroupIdFollowMutationResult = NonNullable<Awaited<ReturnType<typeof postGroupIdFollow>>>
    
    export type PostGroupIdFollowMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Follow Scanlation Group
 */
export const usePostGroupIdFollow = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postGroupIdFollow>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postGroupIdFollow>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getPostGroupIdFollowMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Unfollow Scanlation Group
 */
export const deleteGroupIdFollow = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Response>> => {
    
    return axios.delete(
      `/group/${id}/follow`,options
    );
  }



export const getDeleteGroupIdFollowMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteGroupIdFollow>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteGroupIdFollow>>, TError,{id: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteGroupIdFollow>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteGroupIdFollow(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteGroupIdFollowMutationResult = NonNullable<Awaited<ReturnType<typeof deleteGroupIdFollow>>>
    
    export type DeleteGroupIdFollowMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Unfollow Scanlation Group
 */
export const useDeleteGroupIdFollow = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteGroupIdFollow>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteGroupIdFollow>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteGroupIdFollowMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Create CustomList
 */
export const postList = (
    customListCreate: CustomListCreate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CustomListResponse>> => {
    
    return axios.post(
      `/list`,
      customListCreate,options
    );
  }



export const getPostListMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postList>>, TError,{data: CustomListCreate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postList>>, TError,{data: CustomListCreate}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postList>>, {data: CustomListCreate}> = (props) => {
          const {data} = props ?? {};

          return  postList(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostListMutationResult = NonNullable<Awaited<ReturnType<typeof postList>>>
    export type PostListMutationBody = CustomListCreate
    export type PostListMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create CustomList
 */
export const usePostList = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postList>>, TError,{data: CustomListCreate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postList>>,
        TError,
        {data: CustomListCreate},
        TContext
      > => {

      const mutationOptions = getPostListMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get CustomList
 */
export const getListId = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CustomListResponse>> => {
    
    return axios.get(
      `/list/${id}`,options
    );
  }


export const getGetListIdQueryKey = (id: string,) => {
    return [`/list/${id}`] as const;
    }

    
export const getGetListIdQueryOptions = <TData = Awaited<ReturnType<typeof getListId>>, TError = AxiosError<ErrorResponse>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getListId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetListIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getListId>>> = ({ signal }) => getListId(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getListId>>, TError, TData> & { queryKey: QueryKey }
}

export type GetListIdQueryResult = NonNullable<Awaited<ReturnType<typeof getListId>>>
export type GetListIdQueryError = AxiosError<ErrorResponse>

/**
 * @summary Get CustomList
 */
export const useGetListId = <TData = Awaited<ReturnType<typeof getListId>>, TError = AxiosError<ErrorResponse>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getListId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetListIdQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * The size of the body is limited to 8KB.
 * @summary Update CustomList
 */
export const putListId = (
    id: string,
    customListEdit: CustomListEdit, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CustomListResponse>> => {
    
    return axios.put(
      `/list/${id}`,
      customListEdit,options
    );
  }



export const getPutListIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putListId>>, TError,{id: string;data: CustomListEdit}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof putListId>>, TError,{id: string;data: CustomListEdit}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putListId>>, {id: string;data: CustomListEdit}> = (props) => {
          const {id,data} = props ?? {};

          return  putListId(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutListIdMutationResult = NonNullable<Awaited<ReturnType<typeof putListId>>>
    export type PutListIdMutationBody = CustomListEdit
    export type PutListIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Update CustomList
 */
export const usePutListId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putListId>>, TError,{id: string;data: CustomListEdit}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof putListId>>,
        TError,
        {id: string;data: CustomListEdit},
        TContext
      > => {

      const mutationOptions = getPutListIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete CustomList
 */
export const deleteListId = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Response>> => {
    
    return axios.delete(
      `/list/${id}`,options
    );
  }



export const getDeleteListIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteListId>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteListId>>, TError,{id: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteListId>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteListId(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteListIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteListId>>>
    
    export type DeleteListIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Delete CustomList
 */
export const useDeleteListId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteListId>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteListId>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteListIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * The request body is empty
 * @summary Follow CustomList
 */
export const followListId = (
    id: string,
    followListIdBody: FollowListIdBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<FollowListId200>> => {
    
    return axios.post(
      `/list/${id}/follow`,
      followListIdBody,options
    );
  }



export const getFollowListIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof followListId>>, TError,{id: string;data: FollowListIdBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof followListId>>, TError,{id: string;data: FollowListIdBody}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof followListId>>, {id: string;data: FollowListIdBody}> = (props) => {
          const {id,data} = props ?? {};

          return  followListId(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type FollowListIdMutationResult = NonNullable<Awaited<ReturnType<typeof followListId>>>
    export type FollowListIdMutationBody = FollowListIdBody
    export type FollowListIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Follow CustomList
 */
export const useFollowListId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof followListId>>, TError,{id: string;data: FollowListIdBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof followListId>>,
        TError,
        {id: string;data: FollowListIdBody},
        TContext
      > => {

      const mutationOptions = getFollowListIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * The request body is empty
 * @summary Unfollow CustomList
 */
export const unfollowListId = (
    id: string,
    unfollowListIdBody: UnfollowListIdBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UnfollowListId200>> => {
    
    return axios.delete(
      `/list/${id}/follow`,{data:
      unfollowListIdBody, ...options}
    );
  }



export const getUnfollowListIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unfollowListId>>, TError,{id: string;data: UnfollowListIdBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof unfollowListId>>, TError,{id: string;data: UnfollowListIdBody}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof unfollowListId>>, {id: string;data: UnfollowListIdBody}> = (props) => {
          const {id,data} = props ?? {};

          return  unfollowListId(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UnfollowListIdMutationResult = NonNullable<Awaited<ReturnType<typeof unfollowListId>>>
    export type UnfollowListIdMutationBody = UnfollowListIdBody
    export type UnfollowListIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Unfollow CustomList
 */
export const useUnfollowListId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unfollowListId>>, TError,{id: string;data: UnfollowListIdBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof unfollowListId>>,
        TError,
        {id: string;data: UnfollowListIdBody},
        TContext
      > => {

      const mutationOptions = getUnfollowListIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Add Manga in CustomList
 */
export const postMangaIdListListId = (
    id: string,
    listId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Response>> => {
    
    return axios.post(
      `/manga/${id}/list/${listId}`,undefined,options
    );
  }



export const getPostMangaIdListListIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postMangaIdListListId>>, TError,{id: string;listId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postMangaIdListListId>>, TError,{id: string;listId: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postMangaIdListListId>>, {id: string;listId: string}> = (props) => {
          const {id,listId} = props ?? {};

          return  postMangaIdListListId(id,listId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostMangaIdListListIdMutationResult = NonNullable<Awaited<ReturnType<typeof postMangaIdListListId>>>
    
    export type PostMangaIdListListIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Add Manga in CustomList
 */
export const usePostMangaIdListListId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postMangaIdListListId>>, TError,{id: string;listId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postMangaIdListListId>>,
        TError,
        {id: string;listId: string},
        TContext
      > => {

      const mutationOptions = getPostMangaIdListListIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Remove Manga in CustomList
 */
export const deleteMangaIdListListId = (
    id: string,
    listId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Response>> => {
    
    return axios.delete(
      `/manga/${id}/list/${listId}`,options
    );
  }



export const getDeleteMangaIdListListIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteMangaIdListListId>>, TError,{id: string;listId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteMangaIdListListId>>, TError,{id: string;listId: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteMangaIdListListId>>, {id: string;listId: string}> = (props) => {
          const {id,listId} = props ?? {};

          return  deleteMangaIdListListId(id,listId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteMangaIdListListIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteMangaIdListListId>>>
    
    export type DeleteMangaIdListListIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Remove Manga in CustomList
 */
export const useDeleteMangaIdListListId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteMangaIdListListId>>, TError,{id: string;listId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteMangaIdListListId>>,
        TError,
        {id: string;listId: string},
        TContext
      > => {

      const mutationOptions = getDeleteMangaIdListListIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This will list public and private CustomList
 * @summary Get logged User CustomList list
 */
export const getUserList = (
    params?: GetUserListParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CustomListList>> => {
    
    return axios.get(
      `/user/list`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetUserListQueryKey = (params?: GetUserListParams,) => {
    return [`/user/list`, ...(params ? [params]: [])] as const;
    }

    
export const getGetUserListQueryOptions = <TData = Awaited<ReturnType<typeof getUserList>>, TError = AxiosError<unknown>>(params?: GetUserListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserList>>> = ({ signal }) => getUserList(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserList>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserListQueryResult = NonNullable<Awaited<ReturnType<typeof getUserList>>>
export type GetUserListQueryError = AxiosError<unknown>

/**
 * @summary Get logged User CustomList list
 */
export const useGetUserList = <TData = Awaited<ReturnType<typeof getUserList>>, TError = AxiosError<unknown>>(
 params?: GetUserListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserListQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This will list only public CustomList
 * @summary Get User's CustomList list
 */
export const getUserIdList = (
    id: string,
    params?: GetUserIdListParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CustomListList>> => {
    
    return axios.get(
      `/user/${id}/list`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetUserIdListQueryKey = (id: string,
    params?: GetUserIdListParams,) => {
    return [`/user/${id}/list`, ...(params ? [params]: [])] as const;
    }

    
export const getGetUserIdListQueryOptions = <TData = Awaited<ReturnType<typeof getUserIdList>>, TError = AxiosError<unknown>>(id: string,
    params?: GetUserIdListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserIdList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserIdListQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserIdList>>> = ({ signal }) => getUserIdList(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserIdList>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserIdListQueryResult = NonNullable<Awaited<ReturnType<typeof getUserIdList>>>
export type GetUserIdListQueryError = AxiosError<unknown>

/**
 * @summary Get User's CustomList list
 */
export const useGetUserIdList = <TData = Awaited<ReturnType<typeof getUserIdList>>, TError = AxiosError<unknown>>(
 id: string,
    params?: GetUserIdListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserIdList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserIdListQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary User list
 */
export const getUser = (
    params?: GetUserParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserList>> => {
    
    return axios.get(
      `/user`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetUserQueryKey = (params?: GetUserParams,) => {
    return [`/user`, ...(params ? [params]: [])] as const;
    }

    
export const getGetUserQueryOptions = <TData = Awaited<ReturnType<typeof getUser>>, TError = AxiosError<unknown>>(params?: GetUserParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({ signal }) => getUser(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserQueryResult = NonNullable<Awaited<ReturnType<typeof getUser>>>
export type GetUserQueryError = AxiosError<unknown>

/**
 * @summary User list
 */
export const useGetUser = <TData = Awaited<ReturnType<typeof getUser>>, TError = AxiosError<unknown>>(
 params?: GetUserParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get User
 */
export const getUserId = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserResponse>> => {
    
    return axios.get(
      `/user/${id}`,options
    );
  }


export const getGetUserIdQueryKey = (id: string,) => {
    return [`/user/${id}`] as const;
    }

    
export const getGetUserIdQueryOptions = <TData = Awaited<ReturnType<typeof getUserId>>, TError = AxiosError<unknown>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserId>>> = ({ signal }) => getUserId(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserId>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserIdQueryResult = NonNullable<Awaited<ReturnType<typeof getUserId>>>
export type GetUserIdQueryError = AxiosError<unknown>

/**
 * @summary Get User
 */
export const useGetUserId = <TData = Awaited<ReturnType<typeof getUserId>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserIdQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @deprecated
 * @summary Delete User
 */
export const deleteUserId = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Response>> => {
    
    return axios.delete(
      `/user/${id}`,options
    );
  }



export const getDeleteUserIdMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUserId>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteUserId>>, TError,{id: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUserId>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteUserId(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUserIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUserId>>>
    
    export type DeleteUserIdMutationError = AxiosError<unknown>

    /**
 * @deprecated
 * @summary Delete User
 */
export const useDeleteUserId = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUserId>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteUserId>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteUserIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @deprecated
 * @summary Approve User deletion
 */
export const postUserDeleteCode = (
    code: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Response>> => {
    
    return axios.post(
      `/user/delete/${code}`,undefined,options
    );
  }



export const getPostUserDeleteCodeMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postUserDeleteCode>>, TError,{code: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postUserDeleteCode>>, TError,{code: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postUserDeleteCode>>, {code: string}> = (props) => {
          const {code} = props ?? {};

          return  postUserDeleteCode(code,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostUserDeleteCodeMutationResult = NonNullable<Awaited<ReturnType<typeof postUserDeleteCode>>>
    
    export type PostUserDeleteCodeMutationError = AxiosError<unknown>

    /**
 * @deprecated
 * @summary Approve User deletion
 */
export const usePostUserDeleteCode = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postUserDeleteCode>>, TError,{code: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postUserDeleteCode>>,
        TError,
        {code: string},
        TContext
      > => {

      const mutationOptions = getPostUserDeleteCodeMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Chapter list. If you want the Chapters of a given Manga, please check the feed endpoints.
 * @summary Chapter list
 */
export const getChapter = (
    params?: GetChapterParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ChapterList>> => {
    
    return axios.get(
      `/chapter`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetChapterQueryKey = (params?: GetChapterParams,) => {
    return [`/chapter`, ...(params ? [params]: [])] as const;
    }

    
export const getGetChapterQueryOptions = <TData = Awaited<ReturnType<typeof getChapter>>, TError = AxiosError<ErrorResponse>>(params?: GetChapterParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChapter>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetChapterQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getChapter>>> = ({ signal }) => getChapter(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getChapter>>, TError, TData> & { queryKey: QueryKey }
}

export type GetChapterQueryResult = NonNullable<Awaited<ReturnType<typeof getChapter>>>
export type GetChapterQueryError = AxiosError<ErrorResponse>

/**
 * @summary Chapter list
 */
export const useGetChapter = <TData = Awaited<ReturnType<typeof getChapter>>, TError = AxiosError<ErrorResponse>>(
 params?: GetChapterParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChapter>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetChapterQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get Chapter
 */
export const getChapterId = (
    id: string,
    params?: GetChapterIdParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ChapterResponse>> => {
    
    return axios.get(
      `/chapter/${id}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetChapterIdQueryKey = (id: string,
    params?: GetChapterIdParams,) => {
    return [`/chapter/${id}`, ...(params ? [params]: [])] as const;
    }

    
export const getGetChapterIdQueryOptions = <TData = Awaited<ReturnType<typeof getChapterId>>, TError = AxiosError<ErrorResponse>>(id: string,
    params?: GetChapterIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChapterId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetChapterIdQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getChapterId>>> = ({ signal }) => getChapterId(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getChapterId>>, TError, TData> & { queryKey: QueryKey }
}

export type GetChapterIdQueryResult = NonNullable<Awaited<ReturnType<typeof getChapterId>>>
export type GetChapterIdQueryError = AxiosError<ErrorResponse>

/**
 * @summary Get Chapter
 */
export const useGetChapterId = <TData = Awaited<ReturnType<typeof getChapterId>>, TError = AxiosError<ErrorResponse>>(
 id: string,
    params?: GetChapterIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChapterId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetChapterIdQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update Chapter
 */
export const putChapterId = (
    id: string,
    chapterEdit: ChapterEdit, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ChapterResponse>> => {
    
    return axios.put(
      `/chapter/${id}`,
      chapterEdit,options
    );
  }



export const getPutChapterIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putChapterId>>, TError,{id: string;data: ChapterEdit}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof putChapterId>>, TError,{id: string;data: ChapterEdit}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putChapterId>>, {id: string;data: ChapterEdit}> = (props) => {
          const {id,data} = props ?? {};

          return  putChapterId(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutChapterIdMutationResult = NonNullable<Awaited<ReturnType<typeof putChapterId>>>
    export type PutChapterIdMutationBody = ChapterEdit
    export type PutChapterIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Update Chapter
 */
export const usePutChapterId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putChapterId>>, TError,{id: string;data: ChapterEdit}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof putChapterId>>,
        TError,
        {id: string;data: ChapterEdit},
        TContext
      > => {

      const mutationOptions = getPutChapterIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete Chapter
 */
export const deleteChapterId = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Response>> => {
    
    return axios.delete(
      `/chapter/${id}`,options
    );
  }



export const getDeleteChapterIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteChapterId>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteChapterId>>, TError,{id: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteChapterId>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteChapterId(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteChapterIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteChapterId>>>
    
    export type DeleteChapterIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Delete Chapter
 */
export const useDeleteChapterId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteChapterId>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteChapterId>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteChapterIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get logged User followed Manga feed (Chapter list)
 */
export const getUserFollowsMangaFeed = (
    params?: GetUserFollowsMangaFeedParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ChapterList>> => {
    
    return axios.get(
      `/user/follows/manga/feed`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetUserFollowsMangaFeedQueryKey = (params?: GetUserFollowsMangaFeedParams,) => {
    return [`/user/follows/manga/feed`, ...(params ? [params]: [])] as const;
    }

    
export const getGetUserFollowsMangaFeedQueryOptions = <TData = Awaited<ReturnType<typeof getUserFollowsMangaFeed>>, TError = AxiosError<ErrorResponse>>(params?: GetUserFollowsMangaFeedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFollowsMangaFeed>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserFollowsMangaFeedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserFollowsMangaFeed>>> = ({ signal }) => getUserFollowsMangaFeed(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserFollowsMangaFeed>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserFollowsMangaFeedQueryResult = NonNullable<Awaited<ReturnType<typeof getUserFollowsMangaFeed>>>
export type GetUserFollowsMangaFeedQueryError = AxiosError<ErrorResponse>

/**
 * @summary Get logged User followed Manga feed (Chapter list)
 */
export const useGetUserFollowsMangaFeed = <TData = Awaited<ReturnType<typeof getUserFollowsMangaFeed>>, TError = AxiosError<ErrorResponse>>(
 params?: GetUserFollowsMangaFeedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFollowsMangaFeed>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserFollowsMangaFeedQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary CustomList Manga feed
 */
export const getListIdFeed = (
    id: string,
    params?: GetListIdFeedParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ChapterList>> => {
    
    return axios.get(
      `/list/${id}/feed`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetListIdFeedQueryKey = (id: string,
    params?: GetListIdFeedParams,) => {
    return [`/list/${id}/feed`, ...(params ? [params]: [])] as const;
    }

    
export const getGetListIdFeedQueryOptions = <TData = Awaited<ReturnType<typeof getListIdFeed>>, TError = AxiosError<ErrorResponse>>(id: string,
    params?: GetListIdFeedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getListIdFeed>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetListIdFeedQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getListIdFeed>>> = ({ signal }) => getListIdFeed(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getListIdFeed>>, TError, TData> & { queryKey: QueryKey }
}

export type GetListIdFeedQueryResult = NonNullable<Awaited<ReturnType<typeof getListIdFeed>>>
export type GetListIdFeedQueryError = AxiosError<ErrorResponse>

/**
 * @summary CustomList Manga feed
 */
export const useGetListIdFeed = <TData = Awaited<ReturnType<typeof getListIdFeed>>, TError = AxiosError<ErrorResponse>>(
 id: string,
    params?: GetListIdFeedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getListIdFeed>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetListIdFeedQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Unfollow Manga
 */
export const deleteMangaIdFollow = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Response>> => {
    
    return axios.delete(
      `/manga/${id}/follow`,options
    );
  }



export const getDeleteMangaIdFollowMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteMangaIdFollow>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteMangaIdFollow>>, TError,{id: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteMangaIdFollow>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteMangaIdFollow(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteMangaIdFollowMutationResult = NonNullable<Awaited<ReturnType<typeof deleteMangaIdFollow>>>
    
    export type DeleteMangaIdFollowMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Unfollow Manga
 */
export const useDeleteMangaIdFollow = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteMangaIdFollow>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteMangaIdFollow>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteMangaIdFollowMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Follow Manga
 */
export const postMangaIdFollow = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Response>> => {
    
    return axios.post(
      `/manga/${id}/follow`,undefined,options
    );
  }



export const getPostMangaIdFollowMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postMangaIdFollow>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postMangaIdFollow>>, TError,{id: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postMangaIdFollow>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  postMangaIdFollow(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostMangaIdFollowMutationResult = NonNullable<Awaited<ReturnType<typeof postMangaIdFollow>>>
    
    export type PostMangaIdFollowMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Follow Manga
 */
export const usePostMangaIdFollow = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postMangaIdFollow>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postMangaIdFollow>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getPostMangaIdFollowMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary CoverArt list
 */
export const getCover = (
    params?: GetCoverParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CoverList>> => {
    
    return axios.get(
      `/cover`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetCoverQueryKey = (params?: GetCoverParams,) => {
    return [`/cover`, ...(params ? [params]: [])] as const;
    }

    
export const getGetCoverQueryOptions = <TData = Awaited<ReturnType<typeof getCover>>, TError = AxiosError<ErrorResponse>>(params?: GetCoverParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCover>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCoverQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCover>>> = ({ signal }) => getCover(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCover>>, TError, TData> & { queryKey: QueryKey }
}

export type GetCoverQueryResult = NonNullable<Awaited<ReturnType<typeof getCover>>>
export type GetCoverQueryError = AxiosError<ErrorResponse>

/**
 * @summary CoverArt list
 */
export const useGetCover = <TData = Awaited<ReturnType<typeof getCover>>, TError = AxiosError<ErrorResponse>>(
 params?: GetCoverParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCover>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetCoverQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Upload Cover
 */
export const uploadCover = (
    mangaOrCoverId: string,
    uploadCoverBody: UploadCoverBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CoverResponse>> => {const formData = new FormData();
if(uploadCoverBody.file !== undefined) {
 formData.append('file', uploadCoverBody.file)
 }
if(uploadCoverBody.volume !== undefined && uploadCoverBody.volume !== null) {
 formData.append('volume', uploadCoverBody.volume)
 }
if(uploadCoverBody.description !== undefined) {
 formData.append('description', uploadCoverBody.description)
 }
if(uploadCoverBody.locale !== undefined) {
 formData.append('locale', uploadCoverBody.locale)
 }

    
    return axios.post(
      `/cover/${mangaOrCoverId}`,
      formData,options
    );
  }



export const getUploadCoverMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadCover>>, TError,{mangaOrCoverId: string;data: UploadCoverBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof uploadCover>>, TError,{mangaOrCoverId: string;data: UploadCoverBody}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof uploadCover>>, {mangaOrCoverId: string;data: UploadCoverBody}> = (props) => {
          const {mangaOrCoverId,data} = props ?? {};

          return  uploadCover(mangaOrCoverId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UploadCoverMutationResult = NonNullable<Awaited<ReturnType<typeof uploadCover>>>
    export type UploadCoverMutationBody = UploadCoverBody
    export type UploadCoverMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Upload Cover
 */
export const useUploadCover = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadCover>>, TError,{mangaOrCoverId: string;data: UploadCoverBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof uploadCover>>,
        TError,
        {mangaOrCoverId: string;data: UploadCoverBody},
        TContext
      > => {

      const mutationOptions = getUploadCoverMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get Cover
 */
export const getCoverId = (
    mangaOrCoverId: string,
    params?: GetCoverIdParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CoverResponse>> => {
    
    return axios.get(
      `/cover/${mangaOrCoverId}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetCoverIdQueryKey = (mangaOrCoverId: string,
    params?: GetCoverIdParams,) => {
    return [`/cover/${mangaOrCoverId}`, ...(params ? [params]: [])] as const;
    }

    
export const getGetCoverIdQueryOptions = <TData = Awaited<ReturnType<typeof getCoverId>>, TError = AxiosError<ErrorResponse>>(mangaOrCoverId: string,
    params?: GetCoverIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCoverId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCoverIdQueryKey(mangaOrCoverId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCoverId>>> = ({ signal }) => getCoverId(mangaOrCoverId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(mangaOrCoverId),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCoverId>>, TError, TData> & { queryKey: QueryKey }
}

export type GetCoverIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCoverId>>>
export type GetCoverIdQueryError = AxiosError<ErrorResponse>

/**
 * @summary Get Cover
 */
export const useGetCoverId = <TData = Awaited<ReturnType<typeof getCoverId>>, TError = AxiosError<ErrorResponse>>(
 mangaOrCoverId: string,
    params?: GetCoverIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCoverId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetCoverIdQueryOptions(mangaOrCoverId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Edit Cover
 */
export const editCover = (
    mangaOrCoverId: string,
    coverEdit: CoverEdit, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CoverResponse>> => {
    
    return axios.put(
      `/cover/${mangaOrCoverId}`,
      coverEdit,options
    );
  }



export const getEditCoverMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof editCover>>, TError,{mangaOrCoverId: string;data: CoverEdit}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof editCover>>, TError,{mangaOrCoverId: string;data: CoverEdit}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof editCover>>, {mangaOrCoverId: string;data: CoverEdit}> = (props) => {
          const {mangaOrCoverId,data} = props ?? {};

          return  editCover(mangaOrCoverId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EditCoverMutationResult = NonNullable<Awaited<ReturnType<typeof editCover>>>
    export type EditCoverMutationBody = CoverEdit
    export type EditCoverMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Edit Cover
 */
export const useEditCover = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof editCover>>, TError,{mangaOrCoverId: string;data: CoverEdit}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof editCover>>,
        TError,
        {mangaOrCoverId: string;data: CoverEdit},
        TContext
      > => {

      const mutationOptions = getEditCoverMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete Cover
 */
export const deleteCover = (
    mangaOrCoverId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Response>> => {
    
    return axios.delete(
      `/cover/${mangaOrCoverId}`,options
    );
  }



export const getDeleteCoverMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCover>>, TError,{mangaOrCoverId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteCover>>, TError,{mangaOrCoverId: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCover>>, {mangaOrCoverId: string}> = (props) => {
          const {mangaOrCoverId} = props ?? {};

          return  deleteCover(mangaOrCoverId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCoverMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCover>>>
    
    export type DeleteCoverMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Delete Cover
 */
export const useDeleteCover = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCover>>, TError,{mangaOrCoverId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteCover>>,
        TError,
        {mangaOrCoverId: string},
        TContext
      > => {

      const mutationOptions = getDeleteCoverMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Author list
 */
export const getAuthor = (
    params?: GetAuthorParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AuthorList>> => {
    
    return axios.get(
      `/author`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetAuthorQueryKey = (params?: GetAuthorParams,) => {
    return [`/author`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAuthorQueryOptions = <TData = Awaited<ReturnType<typeof getAuthor>>, TError = AxiosError<ErrorResponse>>(params?: GetAuthorParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthor>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAuthorQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuthor>>> = ({ signal }) => getAuthor(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAuthor>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAuthorQueryResult = NonNullable<Awaited<ReturnType<typeof getAuthor>>>
export type GetAuthorQueryError = AxiosError<ErrorResponse>

/**
 * @summary Author list
 */
export const useGetAuthor = <TData = Awaited<ReturnType<typeof getAuthor>>, TError = AxiosError<ErrorResponse>>(
 params?: GetAuthorParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthor>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAuthorQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create Author
 */
export const postAuthor = (
    authorCreate: AuthorCreate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AuthorResponse>> => {
    
    return axios.post(
      `/author`,
      authorCreate,options
    );
  }



export const getPostAuthorMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAuthor>>, TError,{data: AuthorCreate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postAuthor>>, TError,{data: AuthorCreate}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAuthor>>, {data: AuthorCreate}> = (props) => {
          const {data} = props ?? {};

          return  postAuthor(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAuthorMutationResult = NonNullable<Awaited<ReturnType<typeof postAuthor>>>
    export type PostAuthorMutationBody = AuthorCreate
    export type PostAuthorMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create Author
 */
export const usePostAuthor = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAuthor>>, TError,{data: AuthorCreate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postAuthor>>,
        TError,
        {data: AuthorCreate},
        TContext
      > => {

      const mutationOptions = getPostAuthorMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get Author
 */
export const getAuthorId = (
    id: string,
    params?: GetAuthorIdParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AuthorResponse>> => {
    
    return axios.get(
      `/author/${id}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetAuthorIdQueryKey = (id: string,
    params?: GetAuthorIdParams,) => {
    return [`/author/${id}`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAuthorIdQueryOptions = <TData = Awaited<ReturnType<typeof getAuthorId>>, TError = AxiosError<ErrorResponse>>(id: string,
    params?: GetAuthorIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthorId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAuthorIdQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuthorId>>> = ({ signal }) => getAuthorId(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAuthorId>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAuthorIdQueryResult = NonNullable<Awaited<ReturnType<typeof getAuthorId>>>
export type GetAuthorIdQueryError = AxiosError<ErrorResponse>

/**
 * @summary Get Author
 */
export const useGetAuthorId = <TData = Awaited<ReturnType<typeof getAuthorId>>, TError = AxiosError<ErrorResponse>>(
 id: string,
    params?: GetAuthorIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthorId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAuthorIdQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update Author
 */
export const putAuthorId = (
    id: string,
    authorEdit: AuthorEdit, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AuthorResponse>> => {
    
    return axios.put(
      `/author/${id}`,
      authorEdit,options
    );
  }



export const getPutAuthorIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putAuthorId>>, TError,{id: string;data: AuthorEdit}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof putAuthorId>>, TError,{id: string;data: AuthorEdit}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putAuthorId>>, {id: string;data: AuthorEdit}> = (props) => {
          const {id,data} = props ?? {};

          return  putAuthorId(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutAuthorIdMutationResult = NonNullable<Awaited<ReturnType<typeof putAuthorId>>>
    export type PutAuthorIdMutationBody = AuthorEdit
    export type PutAuthorIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Update Author
 */
export const usePutAuthorId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putAuthorId>>, TError,{id: string;data: AuthorEdit}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof putAuthorId>>,
        TError,
        {id: string;data: AuthorEdit},
        TContext
      > => {

      const mutationOptions = getPutAuthorIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete Author
 */
export const deleteAuthorId = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Response>> => {
    
    return axios.delete(
      `/author/${id}`,options
    );
  }



export const getDeleteAuthorIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAuthorId>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteAuthorId>>, TError,{id: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAuthorId>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteAuthorId(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAuthorIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAuthorId>>>
    
    export type DeleteAuthorIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Delete Author
 */
export const useDeleteAuthorId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAuthorId>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteAuthorId>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteAuthorIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Legacy ID mapping
 */
export const postLegacyMapping = (
    mappingIdBody: MappingIdBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MappingIdResponse>> => {
    
    return axios.post(
      `/legacy/mapping`,
      mappingIdBody,options
    );
  }



export const getPostLegacyMappingMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postLegacyMapping>>, TError,{data: MappingIdBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postLegacyMapping>>, TError,{data: MappingIdBody}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postLegacyMapping>>, {data: MappingIdBody}> = (props) => {
          const {data} = props ?? {};

          return  postLegacyMapping(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostLegacyMappingMutationResult = NonNullable<Awaited<ReturnType<typeof postLegacyMapping>>>
    export type PostLegacyMappingMutationBody = MappingIdBody
    export type PostLegacyMappingMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Legacy ID mapping
 */
export const usePostLegacyMapping = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postLegacyMapping>>, TError,{data: MappingIdBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postLegacyMapping>>,
        TError,
        {data: MappingIdBody},
        TContext
      > => {

      const mutationOptions = getPostLegacyMappingMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Manga feed
 */
export const getMangaIdFeed = (
    id: string,
    params?: GetMangaIdFeedParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ChapterList>> => {
    
    return axios.get(
      `/manga/${id}/feed`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetMangaIdFeedQueryKey = (id: string,
    params?: GetMangaIdFeedParams,) => {
    return [`/manga/${id}/feed`, ...(params ? [params]: [])] as const;
    }

    
export const getGetMangaIdFeedQueryOptions = <TData = Awaited<ReturnType<typeof getMangaIdFeed>>, TError = AxiosError<ErrorResponse>>(id: string,
    params?: GetMangaIdFeedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaIdFeed>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMangaIdFeedQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMangaIdFeed>>> = ({ signal }) => getMangaIdFeed(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMangaIdFeed>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMangaIdFeedQueryResult = NonNullable<Awaited<ReturnType<typeof getMangaIdFeed>>>
export type GetMangaIdFeedQueryError = AxiosError<ErrorResponse>

/**
 * @summary Manga feed
 */
export const useGetMangaIdFeed = <TData = Awaited<ReturnType<typeof getMangaIdFeed>>, TError = AxiosError<ErrorResponse>>(
 id: string,
    params?: GetMangaIdFeedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaIdFeed>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMangaIdFeedQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * A list of chapter ids that are marked as read for the specified manga
 * @summary Manga read markers
 */
export const getMangaChapterReadmarkers = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetMangaChapterReadmarkers200>> => {
    
    return axios.get(
      `/manga/${id}/read`,options
    );
  }


export const getGetMangaChapterReadmarkersQueryKey = (id: string,) => {
    return [`/manga/${id}/read`] as const;
    }

    
export const getGetMangaChapterReadmarkersQueryOptions = <TData = Awaited<ReturnType<typeof getMangaChapterReadmarkers>>, TError = AxiosError<unknown>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaChapterReadmarkers>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMangaChapterReadmarkersQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMangaChapterReadmarkers>>> = ({ signal }) => getMangaChapterReadmarkers(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMangaChapterReadmarkers>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMangaChapterReadmarkersQueryResult = NonNullable<Awaited<ReturnType<typeof getMangaChapterReadmarkers>>>
export type GetMangaChapterReadmarkersQueryError = AxiosError<unknown>

/**
 * @summary Manga read markers
 */
export const useGetMangaChapterReadmarkers = <TData = Awaited<ReturnType<typeof getMangaChapterReadmarkers>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaChapterReadmarkers>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMangaChapterReadmarkersQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Send a lot of chapter ids for one manga to mark as read and/or unread
 * @summary Manga read markers batch
 */
export const postMangaChapterReadmarkers = (
    id: string,
    chapterReadMarkerBatch: ChapterReadMarkerBatch,
    params?: PostMangaChapterReadmarkersParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PostMangaChapterReadmarkers200>> => {
    
    return axios.post(
      `/manga/${id}/read`,
      chapterReadMarkerBatch,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getPostMangaChapterReadmarkersMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postMangaChapterReadmarkers>>, TError,{id: string;data: ChapterReadMarkerBatch;params?: PostMangaChapterReadmarkersParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postMangaChapterReadmarkers>>, TError,{id: string;data: ChapterReadMarkerBatch;params?: PostMangaChapterReadmarkersParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postMangaChapterReadmarkers>>, {id: string;data: ChapterReadMarkerBatch;params?: PostMangaChapterReadmarkersParams}> = (props) => {
          const {id,data,params} = props ?? {};

          return  postMangaChapterReadmarkers(id,data,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostMangaChapterReadmarkersMutationResult = NonNullable<Awaited<ReturnType<typeof postMangaChapterReadmarkers>>>
    export type PostMangaChapterReadmarkersMutationBody = ChapterReadMarkerBatch
    export type PostMangaChapterReadmarkersMutationError = AxiosError<unknown>

    /**
 * @summary Manga read markers batch
 */
export const usePostMangaChapterReadmarkers = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postMangaChapterReadmarkers>>, TError,{id: string;data: ChapterReadMarkerBatch;params?: PostMangaChapterReadmarkersParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postMangaChapterReadmarkers>>,
        TError,
        {id: string;data: ChapterReadMarkerBatch;params?: PostMangaChapterReadmarkersParams},
        TContext
      > => {

      const mutationOptions = getPostMangaChapterReadmarkersMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * A list of chapter ids that are marked as read for the given manga ids
 * @summary Manga read markers
 */
export const getMangaChapterReadmarkers2 = (
    params: GetMangaChapterReadmarkers2Params, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetMangaChapterReadmarkers2200>> => {
    
    return axios.get(
      `/manga/read`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetMangaChapterReadmarkers2QueryKey = (params: GetMangaChapterReadmarkers2Params,) => {
    return [`/manga/read`, ...(params ? [params]: [])] as const;
    }

    
export const getGetMangaChapterReadmarkers2QueryOptions = <TData = Awaited<ReturnType<typeof getMangaChapterReadmarkers2>>, TError = AxiosError<unknown>>(params: GetMangaChapterReadmarkers2Params, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaChapterReadmarkers2>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMangaChapterReadmarkers2QueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMangaChapterReadmarkers2>>> = ({ signal }) => getMangaChapterReadmarkers2(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMangaChapterReadmarkers2>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMangaChapterReadmarkers2QueryResult = NonNullable<Awaited<ReturnType<typeof getMangaChapterReadmarkers2>>>
export type GetMangaChapterReadmarkers2QueryError = AxiosError<unknown>

/**
 * @summary Manga read markers
 */
export const useGetMangaChapterReadmarkers2 = <TData = Awaited<ReturnType<typeof getMangaChapterReadmarkers2>>, TError = AxiosError<unknown>>(
 params: GetMangaChapterReadmarkers2Params, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaChapterReadmarkers2>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMangaChapterReadmarkers2QueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get a random Manga
 */
export const getMangaRandom = (
    params?: GetMangaRandomParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MangaResponse>> => {
    
    return axios.get(
      `/manga/random`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetMangaRandomQueryKey = (params?: GetMangaRandomParams,) => {
    return [`/manga/random`, ...(params ? [params]: [])] as const;
    }

    
export const getGetMangaRandomQueryOptions = <TData = Awaited<ReturnType<typeof getMangaRandom>>, TError = AxiosError<unknown>>(params?: GetMangaRandomParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaRandom>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMangaRandomQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMangaRandom>>> = ({ signal }) => getMangaRandom(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMangaRandom>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMangaRandomQueryResult = NonNullable<Awaited<ReturnType<typeof getMangaRandom>>>
export type GetMangaRandomQueryError = AxiosError<unknown>

/**
 * @summary Get a random Manga
 */
export const useGetMangaRandom = <TData = Awaited<ReturnType<typeof getMangaRandom>>, TError = AxiosError<unknown>>(
 params?: GetMangaRandomParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaRandom>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMangaRandomQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get MangaDex@Home server URL
 */
export const getAtHomeServerChapterId = (
    chapterId: string,
    params?: GetAtHomeServerChapterIdParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetAtHomeServerChapterId200>> => {
    
    return axios.get(
      `/at-home/server/${chapterId}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetAtHomeServerChapterIdQueryKey = (chapterId: string,
    params?: GetAtHomeServerChapterIdParams,) => {
    return [`/at-home/server/${chapterId}`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAtHomeServerChapterIdQueryOptions = <TData = Awaited<ReturnType<typeof getAtHomeServerChapterId>>, TError = AxiosError<ErrorResponse>>(chapterId: string,
    params?: GetAtHomeServerChapterIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAtHomeServerChapterId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAtHomeServerChapterIdQueryKey(chapterId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAtHomeServerChapterId>>> = ({ signal }) => getAtHomeServerChapterId(chapterId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(chapterId),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAtHomeServerChapterId>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAtHomeServerChapterIdQueryResult = NonNullable<Awaited<ReturnType<typeof getAtHomeServerChapterId>>>
export type GetAtHomeServerChapterIdQueryError = AxiosError<ErrorResponse>

/**
 * @summary Get MangaDex@Home server URL
 */
export const useGetAtHomeServerChapterId = <TData = Awaited<ReturnType<typeof getAtHomeServerChapterId>>, TError = AxiosError<ErrorResponse>>(
 chapterId: string,
    params?: GetAtHomeServerChapterIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAtHomeServerChapterId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAtHomeServerChapterIdQueryOptions(chapterId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Tag list
 */
export const getMangaTag = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TagResponse>> => {
    
    return axios.get(
      `/manga/tag`,options
    );
  }


export const getGetMangaTagQueryKey = () => {
    return [`/manga/tag`] as const;
    }

    
export const getGetMangaTagQueryOptions = <TData = Awaited<ReturnType<typeof getMangaTag>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaTag>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMangaTagQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMangaTag>>> = ({ signal }) => getMangaTag({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMangaTag>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMangaTagQueryResult = NonNullable<Awaited<ReturnType<typeof getMangaTag>>>
export type GetMangaTagQueryError = AxiosError<unknown>

/**
 * @summary Tag list
 */
export const useGetMangaTag = <TData = Awaited<ReturnType<typeof getMangaTag>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaTag>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMangaTagQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Logged User details
 */
export const getUserMe = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserResponse>> => {
    
    return axios.get(
      `/user/me`,options
    );
  }


export const getGetUserMeQueryKey = () => {
    return [`/user/me`] as const;
    }

    
export const getGetUserMeQueryOptions = <TData = Awaited<ReturnType<typeof getUserMe>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserMe>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserMeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserMe>>> = ({ signal }) => getUserMe({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserMe>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserMeQueryResult = NonNullable<Awaited<ReturnType<typeof getUserMe>>>
export type GetUserMeQueryError = AxiosError<unknown>

/**
 * @summary Logged User details
 */
export const useGetUserMe = <TData = Awaited<ReturnType<typeof getUserMe>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserMe>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserMeQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get logged User followed Groups
 */
export const getUserFollowsGroup = (
    params?: GetUserFollowsGroupParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ScanlationGroupList>> => {
    
    return axios.get(
      `/user/follows/group`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetUserFollowsGroupQueryKey = (params?: GetUserFollowsGroupParams,) => {
    return [`/user/follows/group`, ...(params ? [params]: [])] as const;
    }

    
export const getGetUserFollowsGroupQueryOptions = <TData = Awaited<ReturnType<typeof getUserFollowsGroup>>, TError = AxiosError<unknown>>(params?: GetUserFollowsGroupParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFollowsGroup>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserFollowsGroupQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserFollowsGroup>>> = ({ signal }) => getUserFollowsGroup(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserFollowsGroup>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserFollowsGroupQueryResult = NonNullable<Awaited<ReturnType<typeof getUserFollowsGroup>>>
export type GetUserFollowsGroupQueryError = AxiosError<unknown>

/**
 * @summary Get logged User followed Groups
 */
export const useGetUserFollowsGroup = <TData = Awaited<ReturnType<typeof getUserFollowsGroup>>, TError = AxiosError<unknown>>(
 params?: GetUserFollowsGroupParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFollowsGroup>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserFollowsGroupQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Check if logged User follows a Group
 */
export const getUserFollowsGroupId = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Response>> => {
    
    return axios.get(
      `/user/follows/group/${id}`,options
    );
  }


export const getGetUserFollowsGroupIdQueryKey = (id: string,) => {
    return [`/user/follows/group/${id}`] as const;
    }

    
export const getGetUserFollowsGroupIdQueryOptions = <TData = Awaited<ReturnType<typeof getUserFollowsGroupId>>, TError = AxiosError<Response>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFollowsGroupId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserFollowsGroupIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserFollowsGroupId>>> = ({ signal }) => getUserFollowsGroupId(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserFollowsGroupId>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserFollowsGroupIdQueryResult = NonNullable<Awaited<ReturnType<typeof getUserFollowsGroupId>>>
export type GetUserFollowsGroupIdQueryError = AxiosError<Response>

/**
 * @summary Check if logged User follows a Group
 */
export const useGetUserFollowsGroupId = <TData = Awaited<ReturnType<typeof getUserFollowsGroupId>>, TError = AxiosError<Response>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFollowsGroupId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserFollowsGroupIdQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get logged User followed User list
 */
export const getUserFollowsUser = (
    params?: GetUserFollowsUserParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserList>> => {
    
    return axios.get(
      `/user/follows/user`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetUserFollowsUserQueryKey = (params?: GetUserFollowsUserParams,) => {
    return [`/user/follows/user`, ...(params ? [params]: [])] as const;
    }

    
export const getGetUserFollowsUserQueryOptions = <TData = Awaited<ReturnType<typeof getUserFollowsUser>>, TError = AxiosError<unknown>>(params?: GetUserFollowsUserParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFollowsUser>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserFollowsUserQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserFollowsUser>>> = ({ signal }) => getUserFollowsUser(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserFollowsUser>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserFollowsUserQueryResult = NonNullable<Awaited<ReturnType<typeof getUserFollowsUser>>>
export type GetUserFollowsUserQueryError = AxiosError<unknown>

/**
 * @summary Get logged User followed User list
 */
export const useGetUserFollowsUser = <TData = Awaited<ReturnType<typeof getUserFollowsUser>>, TError = AxiosError<unknown>>(
 params?: GetUserFollowsUserParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFollowsUser>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserFollowsUserQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Check if logged User follows a User
 */
export const getUserFollowsUserId = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Response>> => {
    
    return axios.get(
      `/user/follows/user/${id}`,options
    );
  }


export const getGetUserFollowsUserIdQueryKey = (id: string,) => {
    return [`/user/follows/user/${id}`] as const;
    }

    
export const getGetUserFollowsUserIdQueryOptions = <TData = Awaited<ReturnType<typeof getUserFollowsUserId>>, TError = AxiosError<Response>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFollowsUserId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserFollowsUserIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserFollowsUserId>>> = ({ signal }) => getUserFollowsUserId(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserFollowsUserId>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserFollowsUserIdQueryResult = NonNullable<Awaited<ReturnType<typeof getUserFollowsUserId>>>
export type GetUserFollowsUserIdQueryError = AxiosError<Response>

/**
 * @summary Check if logged User follows a User
 */
export const useGetUserFollowsUserId = <TData = Awaited<ReturnType<typeof getUserFollowsUserId>>, TError = AxiosError<Response>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFollowsUserId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserFollowsUserIdQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get logged User followed Manga list
 */
export const getUserFollowsManga = (
    params?: GetUserFollowsMangaParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MangaList>> => {
    
    return axios.get(
      `/user/follows/manga`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetUserFollowsMangaQueryKey = (params?: GetUserFollowsMangaParams,) => {
    return [`/user/follows/manga`, ...(params ? [params]: [])] as const;
    }

    
export const getGetUserFollowsMangaQueryOptions = <TData = Awaited<ReturnType<typeof getUserFollowsManga>>, TError = AxiosError<unknown>>(params?: GetUserFollowsMangaParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFollowsManga>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserFollowsMangaQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserFollowsManga>>> = ({ signal }) => getUserFollowsManga(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserFollowsManga>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserFollowsMangaQueryResult = NonNullable<Awaited<ReturnType<typeof getUserFollowsManga>>>
export type GetUserFollowsMangaQueryError = AxiosError<unknown>

/**
 * @summary Get logged User followed Manga list
 */
export const useGetUserFollowsManga = <TData = Awaited<ReturnType<typeof getUserFollowsManga>>, TError = AxiosError<unknown>>(
 params?: GetUserFollowsMangaParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFollowsManga>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserFollowsMangaQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Check if logged User follows a Manga
 */
export const getUserFollowsMangaId = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Response>> => {
    
    return axios.get(
      `/user/follows/manga/${id}`,options
    );
  }


export const getGetUserFollowsMangaIdQueryKey = (id: string,) => {
    return [`/user/follows/manga/${id}`] as const;
    }

    
export const getGetUserFollowsMangaIdQueryOptions = <TData = Awaited<ReturnType<typeof getUserFollowsMangaId>>, TError = AxiosError<Response>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFollowsMangaId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserFollowsMangaIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserFollowsMangaId>>> = ({ signal }) => getUserFollowsMangaId(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserFollowsMangaId>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserFollowsMangaIdQueryResult = NonNullable<Awaited<ReturnType<typeof getUserFollowsMangaId>>>
export type GetUserFollowsMangaIdQueryError = AxiosError<Response>

/**
 * @summary Check if logged User follows a Manga
 */
export const useGetUserFollowsMangaId = <TData = Awaited<ReturnType<typeof getUserFollowsMangaId>>, TError = AxiosError<Response>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFollowsMangaId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserFollowsMangaIdQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get logged User followed CustomList list
 */
export const getUserFollowsList = (
    params?: GetUserFollowsListParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CustomListList>> => {
    
    return axios.get(
      `/user/follows/list`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetUserFollowsListQueryKey = (params?: GetUserFollowsListParams,) => {
    return [`/user/follows/list`, ...(params ? [params]: [])] as const;
    }

    
export const getGetUserFollowsListQueryOptions = <TData = Awaited<ReturnType<typeof getUserFollowsList>>, TError = AxiosError<unknown>>(params?: GetUserFollowsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFollowsList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserFollowsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserFollowsList>>> = ({ signal }) => getUserFollowsList(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserFollowsList>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserFollowsListQueryResult = NonNullable<Awaited<ReturnType<typeof getUserFollowsList>>>
export type GetUserFollowsListQueryError = AxiosError<unknown>

/**
 * @summary Get logged User followed CustomList list
 */
export const useGetUserFollowsList = <TData = Awaited<ReturnType<typeof getUserFollowsList>>, TError = AxiosError<unknown>>(
 params?: GetUserFollowsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFollowsList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserFollowsListQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Check if logged User follows a CustomList
 */
export const getUserFollowsListId = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Response>> => {
    
    return axios.get(
      `/user/follows/list/${id}`,options
    );
  }


export const getGetUserFollowsListIdQueryKey = (id: string,) => {
    return [`/user/follows/list/${id}`] as const;
    }

    
export const getGetUserFollowsListIdQueryOptions = <TData = Awaited<ReturnType<typeof getUserFollowsListId>>, TError = AxiosError<Response>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFollowsListId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserFollowsListIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserFollowsListId>>> = ({ signal }) => getUserFollowsListId(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserFollowsListId>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserFollowsListIdQueryResult = NonNullable<Awaited<ReturnType<typeof getUserFollowsListId>>>
export type GetUserFollowsListIdQueryError = AxiosError<Response>

/**
 * @summary Check if logged User follows a CustomList
 */
export const useGetUserFollowsListId = <TData = Awaited<ReturnType<typeof getUserFollowsListId>>, TError = AxiosError<Response>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFollowsListId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserFollowsListIdQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get all Manga reading status for logged User
 */
export const getMangaStatus = (
    params?: GetMangaStatusParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetMangaStatus200>> => {
    
    return axios.get(
      `/manga/status`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetMangaStatusQueryKey = (params?: GetMangaStatusParams,) => {
    return [`/manga/status`, ...(params ? [params]: [])] as const;
    }

    
export const getGetMangaStatusQueryOptions = <TData = Awaited<ReturnType<typeof getMangaStatus>>, TError = AxiosError<unknown>>(params?: GetMangaStatusParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaStatus>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMangaStatusQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMangaStatus>>> = ({ signal }) => getMangaStatus(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMangaStatus>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMangaStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getMangaStatus>>>
export type GetMangaStatusQueryError = AxiosError<unknown>

/**
 * @summary Get all Manga reading status for logged User
 */
export const useGetMangaStatus = <TData = Awaited<ReturnType<typeof getMangaStatus>>, TError = AxiosError<unknown>>(
 params?: GetMangaStatusParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaStatus>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMangaStatusQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get a Manga reading status
 */
export const getMangaIdStatus = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetMangaIdStatus200>> => {
    
    return axios.get(
      `/manga/${id}/status`,options
    );
  }


export const getGetMangaIdStatusQueryKey = (id: string,) => {
    return [`/manga/${id}/status`] as const;
    }

    
export const getGetMangaIdStatusQueryOptions = <TData = Awaited<ReturnType<typeof getMangaIdStatus>>, TError = AxiosError<ErrorResponse>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaIdStatus>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMangaIdStatusQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMangaIdStatus>>> = ({ signal }) => getMangaIdStatus(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMangaIdStatus>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMangaIdStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getMangaIdStatus>>>
export type GetMangaIdStatusQueryError = AxiosError<ErrorResponse>

/**
 * @summary Get a Manga reading status
 */
export const useGetMangaIdStatus = <TData = Awaited<ReturnType<typeof getMangaIdStatus>>, TError = AxiosError<ErrorResponse>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaIdStatus>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMangaIdStatusQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update Manga reading status
 */
export const postMangaIdStatus = (
    id: string,
    updateMangaStatus: UpdateMangaStatus, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Response>> => {
    
    return axios.post(
      `/manga/${id}/status`,
      updateMangaStatus,options
    );
  }



export const getPostMangaIdStatusMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postMangaIdStatus>>, TError,{id: string;data: UpdateMangaStatus}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postMangaIdStatus>>, TError,{id: string;data: UpdateMangaStatus}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postMangaIdStatus>>, {id: string;data: UpdateMangaStatus}> = (props) => {
          const {id,data} = props ?? {};

          return  postMangaIdStatus(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostMangaIdStatusMutationResult = NonNullable<Awaited<ReturnType<typeof postMangaIdStatus>>>
    export type PostMangaIdStatusMutationBody = UpdateMangaStatus
    export type PostMangaIdStatusMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Update Manga reading status
 */
export const usePostMangaIdStatus = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postMangaIdStatus>>, TError,{id: string;data: UpdateMangaStatus}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postMangaIdStatus>>,
        TError,
        {id: string;data: UpdateMangaStatus},
        TContext
      > => {

      const mutationOptions = getPostMangaIdStatusMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get a specific Manga Draft
 */
export const getMangaIdDraft = (
    id: string,
    params?: GetMangaIdDraftParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MangaResponse>> => {
    
    return axios.get(
      `/manga/draft/${id}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetMangaIdDraftQueryKey = (id: string,
    params?: GetMangaIdDraftParams,) => {
    return [`/manga/draft/${id}`, ...(params ? [params]: [])] as const;
    }

    
export const getGetMangaIdDraftQueryOptions = <TData = Awaited<ReturnType<typeof getMangaIdDraft>>, TError = AxiosError<ErrorResponse>>(id: string,
    params?: GetMangaIdDraftParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaIdDraft>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMangaIdDraftQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMangaIdDraft>>> = ({ signal }) => getMangaIdDraft(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMangaIdDraft>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMangaIdDraftQueryResult = NonNullable<Awaited<ReturnType<typeof getMangaIdDraft>>>
export type GetMangaIdDraftQueryError = AxiosError<ErrorResponse>

/**
 * @summary Get a specific Manga Draft
 */
export const useGetMangaIdDraft = <TData = Awaited<ReturnType<typeof getMangaIdDraft>>, TError = AxiosError<ErrorResponse>>(
 id: string,
    params?: GetMangaIdDraftParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaIdDraft>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMangaIdDraftQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Submit a Manga Draft
 */
export const commitMangaDraft = (
    id: string,
    commitMangaDraftBody: CommitMangaDraftBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MangaResponse>> => {
    
    return axios.post(
      `/manga/draft/${id}/commit`,
      commitMangaDraftBody,options
    );
  }



export const getCommitMangaDraftMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof commitMangaDraft>>, TError,{id: string;data: CommitMangaDraftBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof commitMangaDraft>>, TError,{id: string;data: CommitMangaDraftBody}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof commitMangaDraft>>, {id: string;data: CommitMangaDraftBody}> = (props) => {
          const {id,data} = props ?? {};

          return  commitMangaDraft(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CommitMangaDraftMutationResult = NonNullable<Awaited<ReturnType<typeof commitMangaDraft>>>
    export type CommitMangaDraftMutationBody = CommitMangaDraftBody
    export type CommitMangaDraftMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Submit a Manga Draft
 */
export const useCommitMangaDraft = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof commitMangaDraft>>, TError,{id: string;data: CommitMangaDraftBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof commitMangaDraft>>,
        TError,
        {id: string;data: CommitMangaDraftBody},
        TContext
      > => {

      const mutationOptions = getCommitMangaDraftMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get a list of Manga Drafts
 */
export const getMangaDrafts = (
    params?: GetMangaDraftsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MangaResponse>> => {
    
    return axios.get(
      `/manga/draft`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetMangaDraftsQueryKey = (params?: GetMangaDraftsParams,) => {
    return [`/manga/draft`, ...(params ? [params]: [])] as const;
    }

    
export const getGetMangaDraftsQueryOptions = <TData = Awaited<ReturnType<typeof getMangaDrafts>>, TError = AxiosError<ErrorResponse>>(params?: GetMangaDraftsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaDrafts>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMangaDraftsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMangaDrafts>>> = ({ signal }) => getMangaDrafts(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMangaDrafts>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMangaDraftsQueryResult = NonNullable<Awaited<ReturnType<typeof getMangaDrafts>>>
export type GetMangaDraftsQueryError = AxiosError<ErrorResponse>

/**
 * @summary Get a list of Manga Drafts
 */
export const useGetMangaDrafts = <TData = Awaited<ReturnType<typeof getMangaDrafts>>, TError = AxiosError<ErrorResponse>>(
 params?: GetMangaDraftsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaDrafts>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMangaDraftsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Captchas can be solved explicitly through this endpoint, another way is to add a `X-Captcha-Result` header to any request. The same logic will verify the captcha and is probably more convenient because it takes one less request.

Authentication is optional. Captchas are tracked for both the client ip and for the user id, if you are logged in you want to send your session token but that is not required.
 * @summary Solve Captcha
 */
export const postCaptchaSolve = (
    postCaptchaSolveBody: PostCaptchaSolveBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PostCaptchaSolve200>> => {
    
    return axios.post(
      `/captcha/solve`,
      postCaptchaSolveBody,options
    );
  }



export const getPostCaptchaSolveMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postCaptchaSolve>>, TError,{data: PostCaptchaSolveBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postCaptchaSolve>>, TError,{data: PostCaptchaSolveBody}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postCaptchaSolve>>, {data: PostCaptchaSolveBody}> = (props) => {
          const {data} = props ?? {};

          return  postCaptchaSolve(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostCaptchaSolveMutationResult = NonNullable<Awaited<ReturnType<typeof postCaptchaSolve>>>
    export type PostCaptchaSolveMutationBody = PostCaptchaSolveBody
    export type PostCaptchaSolveMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Solve Captcha
 */
export const usePostCaptchaSolve = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postCaptchaSolve>>, TError,{data: PostCaptchaSolveBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postCaptchaSolve>>,
        TError,
        {data: PostCaptchaSolveBody},
        TContext
      > => {

      const mutationOptions = getPostCaptchaSolveMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get a list of report reasons
 */
export const getReportReasonsByCategory = (
    category: 'manga' | 'chapter' | 'scanlation_group' | 'user' | 'author', options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetReportReasonsByCategory200>> => {
    
    return axios.get(
      `/report/reasons/${category}`,options
    );
  }


export const getGetReportReasonsByCategoryQueryKey = (category: 'manga' | 'chapter' | 'scanlation_group' | 'user' | 'author',) => {
    return [`/report/reasons/${category}`] as const;
    }

    
export const getGetReportReasonsByCategoryQueryOptions = <TData = Awaited<ReturnType<typeof getReportReasonsByCategory>>, TError = AxiosError<ErrorResponse>>(category: 'manga' | 'chapter' | 'scanlation_group' | 'user' | 'author', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReportReasonsByCategory>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetReportReasonsByCategoryQueryKey(category);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getReportReasonsByCategory>>> = ({ signal }) => getReportReasonsByCategory(category, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(category),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getReportReasonsByCategory>>, TError, TData> & { queryKey: QueryKey }
}

export type GetReportReasonsByCategoryQueryResult = NonNullable<Awaited<ReturnType<typeof getReportReasonsByCategory>>>
export type GetReportReasonsByCategoryQueryError = AxiosError<ErrorResponse>

/**
 * @summary Get a list of report reasons
 */
export const useGetReportReasonsByCategory = <TData = Awaited<ReturnType<typeof getReportReasonsByCategory>>, TError = AxiosError<ErrorResponse>>(
 category: 'manga' | 'chapter' | 'scanlation_group' | 'user' | 'author', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReportReasonsByCategory>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetReportReasonsByCategoryQueryOptions(category,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get a list of reports by the user
 */
export const getReports = (
    params?: GetReportsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ReportListResponse>> => {
    
    return axios.get(
      `/report`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetReportsQueryKey = (params?: GetReportsParams,) => {
    return [`/report`, ...(params ? [params]: [])] as const;
    }

    
export const getGetReportsQueryOptions = <TData = Awaited<ReturnType<typeof getReports>>, TError = AxiosError<ErrorResponse>>(params?: GetReportsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReports>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetReportsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getReports>>> = ({ signal }) => getReports(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getReports>>, TError, TData> & { queryKey: QueryKey }
}

export type GetReportsQueryResult = NonNullable<Awaited<ReturnType<typeof getReports>>>
export type GetReportsQueryError = AxiosError<ErrorResponse>

/**
 * @summary Get a list of reports by the user
 */
export const useGetReports = <TData = Awaited<ReturnType<typeof getReports>>, TError = AxiosError<ErrorResponse>>(
 params?: GetReportsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReports>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetReportsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a new Report
 */
export const postReport = (
    postReportBody: PostReportBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Response>> => {
    
    return axios.post(
      `/report`,
      postReportBody,options
    );
  }



export const getPostReportMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postReport>>, TError,{data: PostReportBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postReport>>, TError,{data: PostReportBody}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postReport>>, {data: PostReportBody}> = (props) => {
          const {data} = props ?? {};

          return  postReport(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostReportMutationResult = NonNullable<Awaited<ReturnType<typeof postReport>>>
    export type PostReportMutationBody = PostReportBody
    export type PostReportMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create a new Report
 */
export const usePostReport = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postReport>>, TError,{data: PostReportBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postReport>>,
        TError,
        {data: PostReportBody},
        TContext
      > => {

      const mutationOptions = getPostReportMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get the current User upload session
 */
export const getUploadSession = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UploadSession>> => {
    
    return axios.get(
      `/upload`,options
    );
  }


export const getGetUploadSessionQueryKey = () => {
    return [`/upload`] as const;
    }

    
export const getGetUploadSessionQueryOptions = <TData = Awaited<ReturnType<typeof getUploadSession>>, TError = AxiosError<ErrorResponse>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUploadSession>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUploadSessionQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUploadSession>>> = ({ signal }) => getUploadSession({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUploadSession>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUploadSessionQueryResult = NonNullable<Awaited<ReturnType<typeof getUploadSession>>>
export type GetUploadSessionQueryError = AxiosError<ErrorResponse>

/**
 * @summary Get the current User upload session
 */
export const useGetUploadSession = <TData = Awaited<ReturnType<typeof getUploadSession>>, TError = AxiosError<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUploadSession>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUploadSessionQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Start an upload session
 */
export const beginUploadSession = (
    beginUploadSession: BeginUploadSession, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UploadSession>> => {
    
    return axios.post(
      `/upload/begin`,
      beginUploadSession,options
    );
  }



export const getBeginUploadSessionMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof beginUploadSession>>, TError,{data: BeginUploadSession}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof beginUploadSession>>, TError,{data: BeginUploadSession}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof beginUploadSession>>, {data: BeginUploadSession}> = (props) => {
          const {data} = props ?? {};

          return  beginUploadSession(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BeginUploadSessionMutationResult = NonNullable<Awaited<ReturnType<typeof beginUploadSession>>>
    export type BeginUploadSessionMutationBody = BeginUploadSession
    export type BeginUploadSessionMutationError = AxiosError<unknown>

    /**
 * @summary Start an upload session
 */
export const useBeginUploadSession = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof beginUploadSession>>, TError,{data: BeginUploadSession}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof beginUploadSession>>,
        TError,
        {data: BeginUploadSession},
        TContext
      > => {

      const mutationOptions = getBeginUploadSessionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Start an edit chapter session
 */
export const beginEditSession = (
    chapterId: string,
    beginEditSession: BeginEditSession, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UploadSession>> => {
    
    return axios.post(
      `/upload/begin/${chapterId}`,
      beginEditSession,options
    );
  }



export const getBeginEditSessionMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof beginEditSession>>, TError,{chapterId: string;data: BeginEditSession}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof beginEditSession>>, TError,{chapterId: string;data: BeginEditSession}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof beginEditSession>>, {chapterId: string;data: BeginEditSession}> = (props) => {
          const {chapterId,data} = props ?? {};

          return  beginEditSession(chapterId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BeginEditSessionMutationResult = NonNullable<Awaited<ReturnType<typeof beginEditSession>>>
    export type BeginEditSessionMutationBody = BeginEditSession
    export type BeginEditSessionMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Start an edit chapter session
 */
export const useBeginEditSession = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof beginEditSession>>, TError,{chapterId: string;data: BeginEditSession}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof beginEditSession>>,
        TError,
        {chapterId: string;data: BeginEditSession},
        TContext
      > => {

      const mutationOptions = getBeginEditSessionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Upload images to the upload session
 */
export const putUploadSessionFile = (
    uploadSessionId: string,
    putUploadSessionFileBody: PutUploadSessionFileBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PutUploadSessionFile200>> => {const formData = new FormData();
if(putUploadSessionFileBody.file !== undefined) {
 formData.append('file', putUploadSessionFileBody.file)
 }

    
    return axios.post(
      `/upload/${uploadSessionId}`,
      formData,options
    );
  }



export const getPutUploadSessionFileMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putUploadSessionFile>>, TError,{uploadSessionId: string;data: PutUploadSessionFileBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof putUploadSessionFile>>, TError,{uploadSessionId: string;data: PutUploadSessionFileBody}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putUploadSessionFile>>, {uploadSessionId: string;data: PutUploadSessionFileBody}> = (props) => {
          const {uploadSessionId,data} = props ?? {};

          return  putUploadSessionFile(uploadSessionId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutUploadSessionFileMutationResult = NonNullable<Awaited<ReturnType<typeof putUploadSessionFile>>>
    export type PutUploadSessionFileMutationBody = PutUploadSessionFileBody
    export type PutUploadSessionFileMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Upload images to the upload session
 */
export const usePutUploadSessionFile = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putUploadSessionFile>>, TError,{uploadSessionId: string;data: PutUploadSessionFileBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof putUploadSessionFile>>,
        TError,
        {uploadSessionId: string;data: PutUploadSessionFileBody},
        TContext
      > => {

      const mutationOptions = getPutUploadSessionFileMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Abandon upload session
 */
export const abandonUploadSession = (
    uploadSessionId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Response>> => {
    
    return axios.delete(
      `/upload/${uploadSessionId}`,options
    );
  }



export const getAbandonUploadSessionMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof abandonUploadSession>>, TError,{uploadSessionId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof abandonUploadSession>>, TError,{uploadSessionId: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof abandonUploadSession>>, {uploadSessionId: string}> = (props) => {
          const {uploadSessionId} = props ?? {};

          return  abandonUploadSession(uploadSessionId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AbandonUploadSessionMutationResult = NonNullable<Awaited<ReturnType<typeof abandonUploadSession>>>
    
    export type AbandonUploadSessionMutationError = AxiosError<unknown>

    /**
 * @summary Abandon upload session
 */
export const useAbandonUploadSession = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof abandonUploadSession>>, TError,{uploadSessionId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof abandonUploadSession>>,
        TError,
        {uploadSessionId: string},
        TContext
      > => {

      const mutationOptions = getAbandonUploadSessionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Commit the upload session and specify chapter data
 */
export const commitUploadSession = (
    uploadSessionId: string,
    commitUploadSession: CommitUploadSession, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Chapter>> => {
    
    return axios.post(
      `/upload/${uploadSessionId}/commit`,
      commitUploadSession,options
    );
  }



export const getCommitUploadSessionMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof commitUploadSession>>, TError,{uploadSessionId: string;data: CommitUploadSession}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof commitUploadSession>>, TError,{uploadSessionId: string;data: CommitUploadSession}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof commitUploadSession>>, {uploadSessionId: string;data: CommitUploadSession}> = (props) => {
          const {uploadSessionId,data} = props ?? {};

          return  commitUploadSession(uploadSessionId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CommitUploadSessionMutationResult = NonNullable<Awaited<ReturnType<typeof commitUploadSession>>>
    export type CommitUploadSessionMutationBody = CommitUploadSession
    export type CommitUploadSessionMutationError = AxiosError<unknown>

    /**
 * @summary Commit the upload session and specify chapter data
 */
export const useCommitUploadSession = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof commitUploadSession>>, TError,{uploadSessionId: string;data: CommitUploadSession}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof commitUploadSession>>,
        TError,
        {uploadSessionId: string;data: CommitUploadSession},
        TContext
      > => {

      const mutationOptions = getCommitUploadSessionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete an uploaded image from the Upload Session
 */
export const deleteUploadedSessionFile = (
    uploadSessionId: string,
    uploadSessionFileId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Response>> => {
    
    return axios.delete(
      `/upload/${uploadSessionId}/${uploadSessionFileId}`,options
    );
  }



export const getDeleteUploadedSessionFileMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUploadedSessionFile>>, TError,{uploadSessionId: string;uploadSessionFileId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteUploadedSessionFile>>, TError,{uploadSessionId: string;uploadSessionFileId: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUploadedSessionFile>>, {uploadSessionId: string;uploadSessionFileId: string}> = (props) => {
          const {uploadSessionId,uploadSessionFileId} = props ?? {};

          return  deleteUploadedSessionFile(uploadSessionId,uploadSessionFileId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUploadedSessionFileMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUploadedSessionFile>>>
    
    export type DeleteUploadedSessionFileMutationError = AxiosError<unknown>

    /**
 * @summary Delete an uploaded image from the Upload Session
 */
export const useDeleteUploadedSessionFile = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUploadedSessionFile>>, TError,{uploadSessionId: string;uploadSessionFileId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteUploadedSessionFile>>,
        TError,
        {uploadSessionId: string;uploadSessionFileId: string},
        TContext
      > => {

      const mutationOptions = getDeleteUploadedSessionFileMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete a set of uploaded images from the Upload Session
 */
export const deleteUploadedSessionFiles = (
    uploadSessionId: string,
    deleteUploadedSessionFilesBody: string[], options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Response>> => {
    
    return axios.delete(
      `/upload/${uploadSessionId}/batch`,{data:
      deleteUploadedSessionFilesBody, ...options}
    );
  }



export const getDeleteUploadedSessionFilesMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUploadedSessionFiles>>, TError,{uploadSessionId: string;data: string[]}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteUploadedSessionFiles>>, TError,{uploadSessionId: string;data: string[]}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUploadedSessionFiles>>, {uploadSessionId: string;data: string[]}> = (props) => {
          const {uploadSessionId,data} = props ?? {};

          return  deleteUploadedSessionFiles(uploadSessionId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUploadedSessionFilesMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUploadedSessionFiles>>>
    export type DeleteUploadedSessionFilesMutationBody = string[]
    export type DeleteUploadedSessionFilesMutationError = AxiosError<unknown>

    /**
 * @summary Delete a set of uploaded images from the Upload Session
 */
export const useDeleteUploadedSessionFiles = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUploadedSessionFiles>>, TError,{uploadSessionId: string;data: string[]}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteUploadedSessionFiles>>,
        TError,
        {uploadSessionId: string;data: string[]},
        TContext
      > => {

      const mutationOptions = getDeleteUploadedSessionFilesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Check if a given manga / locale for a User needs moderation approval
 */
export const uploadCheckApprovalRequired = (
    uploadCheckApprovalRequiredBody: UploadCheckApprovalRequiredBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UploadCheckApprovalRequired200>> => {
    
    return axios.post(
      `/upload/check-approval-required`,
      uploadCheckApprovalRequiredBody,options
    );
  }



export const getUploadCheckApprovalRequiredMutationOptions = <TError = AxiosError<Response>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadCheckApprovalRequired>>, TError,{data: UploadCheckApprovalRequiredBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof uploadCheckApprovalRequired>>, TError,{data: UploadCheckApprovalRequiredBody}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof uploadCheckApprovalRequired>>, {data: UploadCheckApprovalRequiredBody}> = (props) => {
          const {data} = props ?? {};

          return  uploadCheckApprovalRequired(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UploadCheckApprovalRequiredMutationResult = NonNullable<Awaited<ReturnType<typeof uploadCheckApprovalRequired>>>
    export type UploadCheckApprovalRequiredMutationBody = UploadCheckApprovalRequiredBody
    export type UploadCheckApprovalRequiredMutationError = AxiosError<Response>

    /**
 * @summary Check if a given manga / locale for a User needs moderation approval
 */
export const useUploadCheckApprovalRequired = <TError = AxiosError<Response>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadCheckApprovalRequired>>, TError,{data: UploadCheckApprovalRequiredBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof uploadCheckApprovalRequired>>,
        TError,
        {data: UploadCheckApprovalRequiredBody},
        TContext
      > => {

      const mutationOptions = getUploadCheckApprovalRequiredMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Manga relation list
 */
export const getMangaRelation = (
    mangaId: string,
    params?: GetMangaRelationParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MangaRelationList>> => {
    
    return axios.get(
      `/manga/${mangaId}/relation`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetMangaRelationQueryKey = (mangaId: string,
    params?: GetMangaRelationParams,) => {
    return [`/manga/${mangaId}/relation`, ...(params ? [params]: [])] as const;
    }

    
export const getGetMangaRelationQueryOptions = <TData = Awaited<ReturnType<typeof getMangaRelation>>, TError = AxiosError<ErrorResponse>>(mangaId: string,
    params?: GetMangaRelationParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaRelation>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMangaRelationQueryKey(mangaId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMangaRelation>>> = ({ signal }) => getMangaRelation(mangaId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(mangaId),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMangaRelation>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMangaRelationQueryResult = NonNullable<Awaited<ReturnType<typeof getMangaRelation>>>
export type GetMangaRelationQueryError = AxiosError<ErrorResponse>

/**
 * @summary Manga relation list
 */
export const useGetMangaRelation = <TData = Awaited<ReturnType<typeof getMangaRelation>>, TError = AxiosError<ErrorResponse>>(
 mangaId: string,
    params?: GetMangaRelationParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaRelation>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMangaRelationQueryOptions(mangaId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new Manga relation.
 * @summary Create Manga relation
 */
export const postMangaRelation = (
    mangaId: string,
    mangaRelationCreate: MangaRelationCreate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MangaRelationResponse>> => {
    
    return axios.post(
      `/manga/${mangaId}/relation`,
      mangaRelationCreate,options
    );
  }



export const getPostMangaRelationMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postMangaRelation>>, TError,{mangaId: string;data: MangaRelationCreate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postMangaRelation>>, TError,{mangaId: string;data: MangaRelationCreate}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postMangaRelation>>, {mangaId: string;data: MangaRelationCreate}> = (props) => {
          const {mangaId,data} = props ?? {};

          return  postMangaRelation(mangaId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostMangaRelationMutationResult = NonNullable<Awaited<ReturnType<typeof postMangaRelation>>>
    export type PostMangaRelationMutationBody = MangaRelationCreate
    export type PostMangaRelationMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create Manga relation
 */
export const usePostMangaRelation = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postMangaRelation>>, TError,{mangaId: string;data: MangaRelationCreate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postMangaRelation>>,
        TError,
        {mangaId: string;data: MangaRelationCreate},
        TContext
      > => {

      const mutationOptions = getPostMangaRelationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete Manga relation
 */
export const deleteMangaRelationId = (
    mangaId: string,
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Response>> => {
    
    return axios.delete(
      `/manga/${mangaId}/relation/${id}`,options
    );
  }



export const getDeleteMangaRelationIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteMangaRelationId>>, TError,{mangaId: string;id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteMangaRelationId>>, TError,{mangaId: string;id: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteMangaRelationId>>, {mangaId: string;id: string}> = (props) => {
          const {mangaId,id} = props ?? {};

          return  deleteMangaRelationId(mangaId,id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteMangaRelationIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteMangaRelationId>>>
    
    export type DeleteMangaRelationIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Delete Manga relation
 */
export const useDeleteMangaRelationId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteMangaRelationId>>, TError,{mangaId: string;id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteMangaRelationId>>,
        TError,
        {mangaId: string;id: string},
        TContext
      > => {

      const mutationOptions = getDeleteMangaRelationIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get your ratings
 */
export const getRating = (
    params: GetRatingParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetRating200>> => {
    
    return axios.get(
      `/rating`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetRatingQueryKey = (params: GetRatingParams,) => {
    return [`/rating`, ...(params ? [params]: [])] as const;
    }

    
export const getGetRatingQueryOptions = <TData = Awaited<ReturnType<typeof getRating>>, TError = AxiosError<ErrorResponse>>(params: GetRatingParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRating>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRatingQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRating>>> = ({ signal }) => getRating(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRating>>, TError, TData> & { queryKey: QueryKey }
}

export type GetRatingQueryResult = NonNullable<Awaited<ReturnType<typeof getRating>>>
export type GetRatingQueryError = AxiosError<ErrorResponse>

/**
 * @summary Get your ratings
 */
export const useGetRating = <TData = Awaited<ReturnType<typeof getRating>>, TError = AxiosError<ErrorResponse>>(
 params: GetRatingParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRating>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRatingQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create or update Manga rating
 */
export const postRatingMangaId = (
    mangaId: string,
    postRatingMangaIdBody: PostRatingMangaIdBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Response>> => {
    
    return axios.post(
      `/rating/${mangaId}`,
      postRatingMangaIdBody,options
    );
  }



export const getPostRatingMangaIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postRatingMangaId>>, TError,{mangaId: string;data: PostRatingMangaIdBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postRatingMangaId>>, TError,{mangaId: string;data: PostRatingMangaIdBody}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postRatingMangaId>>, {mangaId: string;data: PostRatingMangaIdBody}> = (props) => {
          const {mangaId,data} = props ?? {};

          return  postRatingMangaId(mangaId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostRatingMangaIdMutationResult = NonNullable<Awaited<ReturnType<typeof postRatingMangaId>>>
    export type PostRatingMangaIdMutationBody = PostRatingMangaIdBody
    export type PostRatingMangaIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create or update Manga rating
 */
export const usePostRatingMangaId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postRatingMangaId>>, TError,{mangaId: string;data: PostRatingMangaIdBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postRatingMangaId>>,
        TError,
        {mangaId: string;data: PostRatingMangaIdBody},
        TContext
      > => {

      const mutationOptions = getPostRatingMangaIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete Manga rating
 */
export const deleteRatingMangaId = (
    mangaId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Response>> => {
    
    return axios.delete(
      `/rating/${mangaId}`,options
    );
  }



export const getDeleteRatingMangaIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRatingMangaId>>, TError,{mangaId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteRatingMangaId>>, TError,{mangaId: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteRatingMangaId>>, {mangaId: string}> = (props) => {
          const {mangaId} = props ?? {};

          return  deleteRatingMangaId(mangaId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteRatingMangaIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteRatingMangaId>>>
    
    export type DeleteRatingMangaIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Delete Manga rating
 */
export const useDeleteRatingMangaId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRatingMangaId>>, TError,{mangaId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteRatingMangaId>>,
        TError,
        {mangaId: string},
        TContext
      > => {

      const mutationOptions = getDeleteRatingMangaIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get statistics about given chapter
 */
export const getStatisticsChapterUuid = (
    uuid: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetStatisticsChapterUuid200>> => {
    
    return axios.get(
      `/statistics/chapter/${uuid}`,options
    );
  }


export const getGetStatisticsChapterUuidQueryKey = (uuid: string,) => {
    return [`/statistics/chapter/${uuid}`] as const;
    }

    
export const getGetStatisticsChapterUuidQueryOptions = <TData = Awaited<ReturnType<typeof getStatisticsChapterUuid>>, TError = AxiosError<unknown>>(uuid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStatisticsChapterUuid>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStatisticsChapterUuidQueryKey(uuid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStatisticsChapterUuid>>> = ({ signal }) => getStatisticsChapterUuid(uuid, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(uuid),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStatisticsChapterUuid>>, TError, TData> & { queryKey: QueryKey }
}

export type GetStatisticsChapterUuidQueryResult = NonNullable<Awaited<ReturnType<typeof getStatisticsChapterUuid>>>
export type GetStatisticsChapterUuidQueryError = AxiosError<unknown>

/**
 * @summary Get statistics about given chapter
 */
export const useGetStatisticsChapterUuid = <TData = Awaited<ReturnType<typeof getStatisticsChapterUuid>>, TError = AxiosError<unknown>>(
 uuid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStatisticsChapterUuid>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetStatisticsChapterUuidQueryOptions(uuid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get statistics about given chapters
 */
export const getStatisticsChapters = (
    params: GetStatisticsChaptersParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetStatisticsChapters200>> => {
    
    return axios.get(
      `/statistics/chapter`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetStatisticsChaptersQueryKey = (params: GetStatisticsChaptersParams,) => {
    return [`/statistics/chapter`, ...(params ? [params]: [])] as const;
    }

    
export const getGetStatisticsChaptersQueryOptions = <TData = Awaited<ReturnType<typeof getStatisticsChapters>>, TError = AxiosError<unknown>>(params: GetStatisticsChaptersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStatisticsChapters>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStatisticsChaptersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStatisticsChapters>>> = ({ signal }) => getStatisticsChapters(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStatisticsChapters>>, TError, TData> & { queryKey: QueryKey }
}

export type GetStatisticsChaptersQueryResult = NonNullable<Awaited<ReturnType<typeof getStatisticsChapters>>>
export type GetStatisticsChaptersQueryError = AxiosError<unknown>

/**
 * @summary Get statistics about given chapters
 */
export const useGetStatisticsChapters = <TData = Awaited<ReturnType<typeof getStatisticsChapters>>, TError = AxiosError<unknown>>(
 params: GetStatisticsChaptersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStatisticsChapters>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetStatisticsChaptersQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get statistics about given scanlation group
 */
export const getStatisticsGroupUuid = (
    uuid: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetStatisticsGroupUuid200>> => {
    
    return axios.get(
      `/statistics/group/${uuid}`,options
    );
  }


export const getGetStatisticsGroupUuidQueryKey = (uuid: string,) => {
    return [`/statistics/group/${uuid}`] as const;
    }

    
export const getGetStatisticsGroupUuidQueryOptions = <TData = Awaited<ReturnType<typeof getStatisticsGroupUuid>>, TError = AxiosError<unknown>>(uuid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStatisticsGroupUuid>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStatisticsGroupUuidQueryKey(uuid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStatisticsGroupUuid>>> = ({ signal }) => getStatisticsGroupUuid(uuid, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(uuid),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStatisticsGroupUuid>>, TError, TData> & { queryKey: QueryKey }
}

export type GetStatisticsGroupUuidQueryResult = NonNullable<Awaited<ReturnType<typeof getStatisticsGroupUuid>>>
export type GetStatisticsGroupUuidQueryError = AxiosError<unknown>

/**
 * @summary Get statistics about given scanlation group
 */
export const useGetStatisticsGroupUuid = <TData = Awaited<ReturnType<typeof getStatisticsGroupUuid>>, TError = AxiosError<unknown>>(
 uuid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStatisticsGroupUuid>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetStatisticsGroupUuidQueryOptions(uuid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get statistics about given groups
 */
export const getStatisticsGroups = (
    params: GetStatisticsGroupsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetStatisticsGroups200>> => {
    
    return axios.get(
      `/statistics/group`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetStatisticsGroupsQueryKey = (params: GetStatisticsGroupsParams,) => {
    return [`/statistics/group`, ...(params ? [params]: [])] as const;
    }

    
export const getGetStatisticsGroupsQueryOptions = <TData = Awaited<ReturnType<typeof getStatisticsGroups>>, TError = AxiosError<unknown>>(params: GetStatisticsGroupsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStatisticsGroups>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStatisticsGroupsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStatisticsGroups>>> = ({ signal }) => getStatisticsGroups(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStatisticsGroups>>, TError, TData> & { queryKey: QueryKey }
}

export type GetStatisticsGroupsQueryResult = NonNullable<Awaited<ReturnType<typeof getStatisticsGroups>>>
export type GetStatisticsGroupsQueryError = AxiosError<unknown>

/**
 * @summary Get statistics about given groups
 */
export const useGetStatisticsGroups = <TData = Awaited<ReturnType<typeof getStatisticsGroups>>, TError = AxiosError<unknown>>(
 params: GetStatisticsGroupsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStatisticsGroups>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetStatisticsGroupsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get statistics about given Manga
 */
export const getStatisticsMangaUuid = (
    uuid: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetStatisticsMangaUuid200>> => {
    
    return axios.get(
      `/statistics/manga/${uuid}`,options
    );
  }


export const getGetStatisticsMangaUuidQueryKey = (uuid: string,) => {
    return [`/statistics/manga/${uuid}`] as const;
    }

    
export const getGetStatisticsMangaUuidQueryOptions = <TData = Awaited<ReturnType<typeof getStatisticsMangaUuid>>, TError = AxiosError<unknown>>(uuid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStatisticsMangaUuid>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStatisticsMangaUuidQueryKey(uuid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStatisticsMangaUuid>>> = ({ signal }) => getStatisticsMangaUuid(uuid, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(uuid),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStatisticsMangaUuid>>, TError, TData> & { queryKey: QueryKey }
}

export type GetStatisticsMangaUuidQueryResult = NonNullable<Awaited<ReturnType<typeof getStatisticsMangaUuid>>>
export type GetStatisticsMangaUuidQueryError = AxiosError<unknown>

/**
 * @summary Get statistics about given Manga
 */
export const useGetStatisticsMangaUuid = <TData = Awaited<ReturnType<typeof getStatisticsMangaUuid>>, TError = AxiosError<unknown>>(
 uuid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStatisticsMangaUuid>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetStatisticsMangaUuidQueryOptions(uuid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Find statistics about given Manga
 */
export const getStatisticsManga = (
    params: GetStatisticsMangaParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetStatisticsManga200>> => {
    
    return axios.get(
      `/statistics/manga`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetStatisticsMangaQueryKey = (params: GetStatisticsMangaParams,) => {
    return [`/statistics/manga`, ...(params ? [params]: [])] as const;
    }

    
export const getGetStatisticsMangaQueryOptions = <TData = Awaited<ReturnType<typeof getStatisticsManga>>, TError = AxiosError<unknown>>(params: GetStatisticsMangaParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStatisticsManga>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStatisticsMangaQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStatisticsManga>>> = ({ signal }) => getStatisticsManga(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStatisticsManga>>, TError, TData> & { queryKey: QueryKey }
}

export type GetStatisticsMangaQueryResult = NonNullable<Awaited<ReturnType<typeof getStatisticsManga>>>
export type GetStatisticsMangaQueryError = AxiosError<unknown>

/**
 * @summary Find statistics about given Manga
 */
export const useGetStatisticsManga = <TData = Awaited<ReturnType<typeof getStatisticsManga>>, TError = AxiosError<unknown>>(
 params: GetStatisticsMangaParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStatisticsManga>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetStatisticsMangaQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get latest Settings template
 */
export const getSettingsTemplate = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetSettingsTemplate200>> => {
    
    return axios.get(
      `/settings/template`,options
    );
  }


export const getGetSettingsTemplateQueryKey = () => {
    return [`/settings/template`] as const;
    }

    
export const getGetSettingsTemplateQueryOptions = <TData = Awaited<ReturnType<typeof getSettingsTemplate>>, TError = AxiosError<ErrorResponse>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSettingsTemplate>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSettingsTemplateQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSettingsTemplate>>> = ({ signal }) => getSettingsTemplate({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSettingsTemplate>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSettingsTemplateQueryResult = NonNullable<Awaited<ReturnType<typeof getSettingsTemplate>>>
export type GetSettingsTemplateQueryError = AxiosError<ErrorResponse>

/**
 * @summary Get latest Settings template
 */
export const useGetSettingsTemplate = <TData = Awaited<ReturnType<typeof getSettingsTemplate>>, TError = AxiosError<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSettingsTemplate>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSettingsTemplateQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create Settings template
 */
export const postSettingsTemplate = (
    postSettingsTemplateBody: PostSettingsTemplateBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PostSettingsTemplate200>> => {
    
    return axios.post(
      `/settings/template`,
      postSettingsTemplateBody,options
    );
  }



export const getPostSettingsTemplateMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postSettingsTemplate>>, TError,{data: PostSettingsTemplateBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postSettingsTemplate>>, TError,{data: PostSettingsTemplateBody}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postSettingsTemplate>>, {data: PostSettingsTemplateBody}> = (props) => {
          const {data} = props ?? {};

          return  postSettingsTemplate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostSettingsTemplateMutationResult = NonNullable<Awaited<ReturnType<typeof postSettingsTemplate>>>
    export type PostSettingsTemplateMutationBody = PostSettingsTemplateBody
    export type PostSettingsTemplateMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create Settings template
 */
export const usePostSettingsTemplate = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postSettingsTemplate>>, TError,{data: PostSettingsTemplateBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postSettingsTemplate>>,
        TError,
        {data: PostSettingsTemplateBody},
        TContext
      > => {

      const mutationOptions = getPostSettingsTemplateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get Settings template by version id
 */
export const getSettingsTemplateVersion = (
    version: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetSettingsTemplateVersion200>> => {
    
    return axios.get(
      `/settings/template/${version}`,options
    );
  }


export const getGetSettingsTemplateVersionQueryKey = (version: string,) => {
    return [`/settings/template/${version}`] as const;
    }

    
export const getGetSettingsTemplateVersionQueryOptions = <TData = Awaited<ReturnType<typeof getSettingsTemplateVersion>>, TError = AxiosError<ErrorResponse>>(version: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSettingsTemplateVersion>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSettingsTemplateVersionQueryKey(version);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSettingsTemplateVersion>>> = ({ signal }) => getSettingsTemplateVersion(version, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(version),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSettingsTemplateVersion>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSettingsTemplateVersionQueryResult = NonNullable<Awaited<ReturnType<typeof getSettingsTemplateVersion>>>
export type GetSettingsTemplateVersionQueryError = AxiosError<ErrorResponse>

/**
 * @summary Get Settings template by version id
 */
export const useGetSettingsTemplateVersion = <TData = Awaited<ReturnType<typeof getSettingsTemplateVersion>>, TError = AxiosError<ErrorResponse>>(
 version: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSettingsTemplateVersion>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSettingsTemplateVersionQueryOptions(version,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get an User Settings
 */
export const getSettings = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetSettings200>> => {
    
    return axios.get(
      `/settings`,options
    );
  }


export const getGetSettingsQueryKey = () => {
    return [`/settings`] as const;
    }

    
export const getGetSettingsQueryOptions = <TData = Awaited<ReturnType<typeof getSettings>>, TError = AxiosError<ErrorResponse>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSettings>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSettingsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSettings>>> = ({ signal }) => getSettings({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSettings>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSettingsQueryResult = NonNullable<Awaited<ReturnType<typeof getSettings>>>
export type GetSettingsQueryError = AxiosError<ErrorResponse>

/**
 * @summary Get an User Settings
 */
export const useGetSettings = <TData = Awaited<ReturnType<typeof getSettings>>, TError = AxiosError<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSettings>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSettingsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create or update an User Settings
 */
export const postSettings = (
    postSettingsBody: PostSettingsBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PostSettings200>> => {
    
    return axios.post(
      `/settings`,
      postSettingsBody,options
    );
  }



export const getPostSettingsMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postSettings>>, TError,{data: PostSettingsBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postSettings>>, TError,{data: PostSettingsBody}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postSettings>>, {data: PostSettingsBody}> = (props) => {
          const {data} = props ?? {};

          return  postSettings(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostSettingsMutationResult = NonNullable<Awaited<ReturnType<typeof postSettings>>>
    export type PostSettingsMutationBody = PostSettingsBody
    export type PostSettingsMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create or update an User Settings
 */
export const usePostSettings = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postSettings>>, TError,{data: PostSettingsBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postSettings>>,
        TError,
        {data: PostSettingsBody},
        TContext
      > => {

      const mutationOptions = getPostSettingsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get users reading history
 */
export const getReadingHistory = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetReadingHistory200>> => {
    
    return axios.get(
      `/user/history`,options
    );
  }


export const getGetReadingHistoryQueryKey = () => {
    return [`/user/history`] as const;
    }

    
export const getGetReadingHistoryQueryOptions = <TData = Awaited<ReturnType<typeof getReadingHistory>>, TError = AxiosError<ErrorResponse>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReadingHistory>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetReadingHistoryQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getReadingHistory>>> = ({ signal }) => getReadingHistory({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getReadingHistory>>, TError, TData> & { queryKey: QueryKey }
}

export type GetReadingHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof getReadingHistory>>>
export type GetReadingHistoryQueryError = AxiosError<ErrorResponse>

/**
 * @summary Get users reading history
 */
export const useGetReadingHistory = <TData = Awaited<ReturnType<typeof getReadingHistory>>, TError = AxiosError<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReadingHistory>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetReadingHistoryQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Creates a thread in the forums for the given resource, which backs the comments functionality.
A thread is only created if it doesn't exist yet; otherwise the preexisting thread is returned.

 * @summary Create forums thread
 */
export const forumsThreadCreate = (
    forumsThreadCreateBody: ForumsThreadCreateBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ForumsThreadResponse>> => {
    
    return axios.post(
      `/forums/thread`,
      forumsThreadCreateBody,options
    );
  }



export const getForumsThreadCreateMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof forumsThreadCreate>>, TError,{data: ForumsThreadCreateBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof forumsThreadCreate>>, TError,{data: ForumsThreadCreateBody}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof forumsThreadCreate>>, {data: ForumsThreadCreateBody}> = (props) => {
          const {data} = props ?? {};

          return  forumsThreadCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ForumsThreadCreateMutationResult = NonNullable<Awaited<ReturnType<typeof forumsThreadCreate>>>
    export type ForumsThreadCreateMutationBody = ForumsThreadCreateBody
    export type ForumsThreadCreateMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create forums thread
 */
export const useForumsThreadCreate = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof forumsThreadCreate>>, TError,{data: ForumsThreadCreateBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof forumsThreadCreate>>,
        TError,
        {data: ForumsThreadCreateBody},
        TContext
      > => {

      const mutationOptions = getForumsThreadCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
