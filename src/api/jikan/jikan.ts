/**
 * Generated by orval v6.31.0 üç∫
 * Do not edit manually.
 * Jikan API
 * [Jikan](https://jikan.moe) is an **Unofficial** MyAnimeList API.
It scrapes the website to satisfy the need for a complete API - which MyAnimeList lacks.

# Information

‚ö° Jikan is powered by its awesome backers - üôè [Become a backer](https://www.patreon.com/jikan)

## Rate Limiting

| Duration | Requests |
|----|----|
| Daily | **Unlimited** |
| Per Minute | 60 requests |
| Per Second | 3 requests |

Note: It's still possible to get rate limited from MyAnimeList.net instead.


## JSON Notes
- Any property (except arrays or objects) whose value does not exist or is undetermined, will be `null`.
- Any array or object property whose value does not exist or is undetermined, will be empty.
- Any `score` property whose value does not exist or is undetermined, will be `0`.
- All dates and timestamps are returned in [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) format and in UTC timezone

## Caching
By **CACHING**, we refer to the data parsed from MyAnimeList which is stored temporarily on our servers to provide better API performance.

All requests are cached for **24 hours**.

The following response headers will detail cache information.

| Header | Remarks |
| ---- | ---- |
| `Expires` | Cache expiry date |
| `Last-Modified` | Cache set date |
| `X-Request-Fingerprint` | Unique request fingerprint (only for cachable requests, not queries) |


Note: `X-Request-Fingerprint` will only be available on single resource requests and their child endpoints. e.g `/anime/1`, `/anime/1/relations`.
They won't be available on pages which perform queries, like /anime, or /top/anime, etc.

## Allowed HTTP(s) requests

**Jikan REST API does not provide authenticated requests for MyAnimeList.** This means you can not use it to update your anime/manga list.
Only GET requests are supported which return READ-ONLY data.

## HTTP Responses

All error responses are accompanied by a JSON Error response.

| Exception | HTTP Status | Remarks |
| ---- | ---- | ---- |
| N/A | `200 - OK` | The request was successful |
| N/A | `304 - Not Modified` | You have the latest data (Cache Validation response) |
| `BadRequestException`,`ValidationException` | `400 - Bad Request` | You've made an invalid request. Recheck documentation |
| `BadResponseException` | `404 - Not Found` | The resource was not found or MyAnimeList responded with a `404` |
| `BadRequestException` | `405 - Method Not Allowed` | Requested Method is not supported for resource. Only `GET` requests are allowed |
| `RateLimitException` | `429 - Too Many Request` | You are being rate limited by Jikan or MyAnimeList is rate-limiting our servers (specified in the error response) |
| `UpstreamException`,`ParserException`,etc. | `500 - Internal Server Error` | Something didn't work. Try again later. If you see an error response with a `report_url` URL, please click on it to open an auto-generated GitHub issue |
| `ServiceUnavailableException` | `503 - Service Unavailable` | In most cases this is intentionally done if the service is down for maintenance. |

## JSON Error Response

```json
 {
     "status": 500,
     "type": "InternalException",
     "message": "Exception Message",
     "error": "Exception Trace",
     "report_url": "https://github.com..."
  }
```

| Property | Remarks |
| ---- | ---- |
| `status` | Returned HTTP Status Code |
| `type` | Thrown Exception |
| `message` | Human-readable error message |
| `error` | Error response and trace from the API |
| `report_url` | Clicking this would redirect you to a generated GitHub issue |


## Cache Validation

- All requests return a `ETag` header which is an MD5 hash of the response
- You can use this hash to verify if there's new or updated content by suppliying it as the value for the `If-None-Match` in your next request header
- You will get a HTTP `304 - Not Modified` response if the content has not changed
- If the content has changed, you'll get a HTTP `200 - OK` response with the updated JSON response

![Cache Validation](https://i.imgur.com/925ozVn.png 'Cache Validation')

## Disclaimer

- Jikan is not affiliated with MyAnimeList.net.
- Jikan is a free, open-source API. Please use it responsibly.

----

By using the API, you are agreeing to Jikan's [terms of use](https://jikan.moe/terms) policy.

[v3 Documentation](https://jikan.docs.apiary.io/) - [Wrappers/SDKs](https://github.com/jikan-me/jikan#wrappers) - [Report an issue](https://github.com/jikan-me/jikan-rest/issues/new) - [Host your own server](https://github.com/jikan-me/jikan-rest)
 * OpenAPI spec version: 4.0.0
 */
import {
  useInfiniteQuery,
  useQuery
} from '@tanstack/react-query'
import type {
  InfiniteData,
  QueryFunction,
  QueryKey,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import axios from 'axios'
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios'
import type {
  AnimeCharacters,
  AnimeEpisodes,
  AnimeNews,
  AnimeReviews,
  AnimeSearch,
  AnimeStaff,
  AnimeStatistics,
  AnimeThemes,
  AnimeUserupdates,
  AnimeVideos,
  AnimeVideosEpisodes,
  CharacterAnime,
  CharacterManga,
  CharacterPictures,
  CharacterVoiceActors,
  CharactersSearch,
  ClubRelations,
  ClubStaff,
  ClubsSearch,
  EntryRecommendations,
  ExternalLinks,
  Forum,
  Genres,
  GetAnimeById200,
  GetAnimeEpisodeById200,
  GetAnimeEpisodesParams,
  GetAnimeForumParams,
  GetAnimeFullById200,
  GetAnimeGenresParams,
  GetAnimeNewsParams,
  GetAnimeRelations200,
  GetAnimeReviewsParams,
  GetAnimeSearchParams,
  GetAnimeUserUpdatesParams,
  GetAnimeVideosEpisodesParams,
  GetCharacterById200,
  GetCharacterFullById200,
  GetCharactersSearchParams,
  GetClubMembers200,
  GetClubMembersParams,
  GetClubsById200,
  GetClubsSearchParams,
  GetMagazinesParams,
  GetMangaById200,
  GetMangaFullById200,
  GetMangaGenresParams,
  GetMangaNewsParams,
  GetMangaRelations200,
  GetMangaReviewsParams,
  GetMangaSearchParams,
  GetMangaTopicsParams,
  GetMangaUserUpdatesParams,
  GetPeopleSearchParams,
  GetPersonById200,
  GetPersonFullById200,
  GetProducerById200,
  GetProducerFullById200,
  GetProducersParams,
  GetRandomAnime200,
  GetRandomCharacters200,
  GetRandomManga200,
  GetRandomPeople200,
  GetRandomUsers200,
  GetRecentAnimeRecommendationsParams,
  GetRecentAnimeReviewsParams,
  GetRecentMangaRecommendationsParams,
  GetRecentMangaReviewsParams,
  GetSchedulesParams,
  GetSeasonNowParams,
  GetSeasonParams,
  GetSeasonUpcomingParams,
  GetTopAnimeParams,
  GetTopCharactersParams,
  GetTopMangaParams,
  GetTopPeopleParams,
  GetTopReviews200,
  GetTopReviewsParams,
  GetUserAnimelistParams,
  GetUserById200,
  GetUserClubsParams,
  GetUserFavorites200,
  GetUserFriendsParams,
  GetUserFullProfile200,
  GetUserHistoryParams,
  GetUserMangaListParams,
  GetUserProfile200,
  GetUserRecommendationsParams,
  GetUserReviews200,
  GetUserReviewsParams,
  GetUsersSearchParams,
  GetWatchRecentPromosParams,
  Magazines,
  MangaCharacters,
  MangaNews,
  MangaPictures,
  MangaReviews,
  MangaSearch,
  MangaStatistics,
  MangaUserupdates,
  Moreinfo,
  PeopleSearch,
  PersonAnime,
  PersonManga,
  PersonPictures,
  PersonVoiceActingRoles,
  PicturesVariants,
  Producers,
  Recommendations,
  Schedules,
  Seasons,
  UserAbout,
  UserClubs,
  UserFriends,
  UserHistory,
  UserStatistics,
  UserUpdates,
  UsersSearch,
  WatchEpisodes,
  WatchPromos
} from './models'




export const getAnimeFullById = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetAnimeFullById200>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/anime/${id}/full`,options
    );
  }


export const getGetAnimeFullByIdQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/anime/${id}/full`] as const;
    }

    
export const getGetAnimeFullByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimeFullById>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeFullById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimeFullByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimeFullById>>> = ({ signal }) => getAnimeFullById(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeFullById>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAnimeFullByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimeFullById>>>
export type GetAnimeFullByIdInfiniteQueryError = AxiosError<void>

export const useGetAnimeFullByIdInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimeFullById>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeFullById>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimeFullByIdInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAnimeFullByIdQueryOptions = <TData = Awaited<ReturnType<typeof getAnimeFullById>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimeFullById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimeFullByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimeFullById>>> = ({ signal }) => getAnimeFullById(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAnimeFullById>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAnimeFullByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimeFullById>>>
export type GetAnimeFullByIdQueryError = AxiosError<void>

export const useGetAnimeFullById = <TData = Awaited<ReturnType<typeof getAnimeFullById>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimeFullById>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimeFullByIdQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAnimeById = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetAnimeById200>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/anime/${id}`,options
    );
  }


export const getGetAnimeByIdQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/anime/${id}`] as const;
    }

    
export const getGetAnimeByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimeById>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimeByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimeById>>> = ({ signal }) => getAnimeById(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeById>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAnimeByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimeById>>>
export type GetAnimeByIdInfiniteQueryError = AxiosError<void>

export const useGetAnimeByIdInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimeById>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeById>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimeByIdInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAnimeByIdQueryOptions = <TData = Awaited<ReturnType<typeof getAnimeById>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimeById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimeByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimeById>>> = ({ signal }) => getAnimeById(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAnimeById>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAnimeByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimeById>>>
export type GetAnimeByIdQueryError = AxiosError<void>

export const useGetAnimeById = <TData = Awaited<ReturnType<typeof getAnimeById>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimeById>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimeByIdQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAnimeCharacters = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AnimeCharacters>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/anime/${id}/characters`,options
    );
  }


export const getGetAnimeCharactersQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/anime/${id}/characters`] as const;
    }

    
export const getGetAnimeCharactersInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimeCharacters>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeCharacters>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimeCharactersQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimeCharacters>>> = ({ signal }) => getAnimeCharacters(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeCharacters>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAnimeCharactersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimeCharacters>>>
export type GetAnimeCharactersInfiniteQueryError = AxiosError<void>

export const useGetAnimeCharactersInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimeCharacters>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeCharacters>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimeCharactersInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAnimeCharactersQueryOptions = <TData = Awaited<ReturnType<typeof getAnimeCharacters>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimeCharacters>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimeCharactersQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimeCharacters>>> = ({ signal }) => getAnimeCharacters(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAnimeCharacters>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAnimeCharactersQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimeCharacters>>>
export type GetAnimeCharactersQueryError = AxiosError<void>

export const useGetAnimeCharacters = <TData = Awaited<ReturnType<typeof getAnimeCharacters>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimeCharacters>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimeCharactersQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAnimeStaff = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AnimeStaff>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/anime/${id}/staff`,options
    );
  }


export const getGetAnimeStaffQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/anime/${id}/staff`] as const;
    }

    
export const getGetAnimeStaffInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimeStaff>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeStaff>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimeStaffQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimeStaff>>> = ({ signal }) => getAnimeStaff(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeStaff>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAnimeStaffInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimeStaff>>>
export type GetAnimeStaffInfiniteQueryError = AxiosError<void>

export const useGetAnimeStaffInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimeStaff>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeStaff>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimeStaffInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAnimeStaffQueryOptions = <TData = Awaited<ReturnType<typeof getAnimeStaff>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimeStaff>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimeStaffQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimeStaff>>> = ({ signal }) => getAnimeStaff(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAnimeStaff>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAnimeStaffQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimeStaff>>>
export type GetAnimeStaffQueryError = AxiosError<void>

export const useGetAnimeStaff = <TData = Awaited<ReturnType<typeof getAnimeStaff>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimeStaff>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimeStaffQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAnimeEpisodes = (
    id: number,
    params?: GetAnimeEpisodesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AnimeEpisodes>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/anime/${id}/episodes`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetAnimeEpisodesQueryKey = (id: number,
    params?: GetAnimeEpisodesParams,) => {
    return [`https://api.jikan.moe/v4/anime/${id}/episodes`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAnimeEpisodesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimeEpisodes>>, GetAnimeEpisodesParams['page']>, TError = AxiosError<void>>(id: number,
    params?: GetAnimeEpisodesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeEpisodes>>, TError, TData, Awaited<ReturnType<typeof getAnimeEpisodes>>, QueryKey, GetAnimeEpisodesParams['page']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimeEpisodesQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimeEpisodes>>, QueryKey, GetAnimeEpisodesParams['page']> = ({ signal, pageParam }) => getAnimeEpisodes(id,{...params, page: pageParam || params?.['page']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeEpisodes>>, TError, TData, Awaited<ReturnType<typeof getAnimeEpisodes>>, QueryKey, GetAnimeEpisodesParams['page']> & { queryKey: QueryKey }
}

export type GetAnimeEpisodesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimeEpisodes>>>
export type GetAnimeEpisodesInfiniteQueryError = AxiosError<void>

export const useGetAnimeEpisodesInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimeEpisodes>>, GetAnimeEpisodesParams['page']>, TError = AxiosError<void>>(
 id: number,
    params?: GetAnimeEpisodesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeEpisodes>>, TError, TData, Awaited<ReturnType<typeof getAnimeEpisodes>>, QueryKey, GetAnimeEpisodesParams['page']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimeEpisodesInfiniteQueryOptions(id,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAnimeEpisodesQueryOptions = <TData = Awaited<ReturnType<typeof getAnimeEpisodes>>, TError = AxiosError<void>>(id: number,
    params?: GetAnimeEpisodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimeEpisodes>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimeEpisodesQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimeEpisodes>>> = ({ signal }) => getAnimeEpisodes(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAnimeEpisodes>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAnimeEpisodesQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimeEpisodes>>>
export type GetAnimeEpisodesQueryError = AxiosError<void>

export const useGetAnimeEpisodes = <TData = Awaited<ReturnType<typeof getAnimeEpisodes>>, TError = AxiosError<void>>(
 id: number,
    params?: GetAnimeEpisodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimeEpisodes>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimeEpisodesQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAnimeEpisodeById = (
    id: number,
    episode: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetAnimeEpisodeById200>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/anime/${id}/episodes/${episode}`,options
    );
  }


export const getGetAnimeEpisodeByIdQueryKey = (id: number,
    episode: number,) => {
    return [`https://api.jikan.moe/v4/anime/${id}/episodes/${episode}`] as const;
    }

    
export const getGetAnimeEpisodeByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimeEpisodeById>>>, TError = AxiosError<void>>(id: number,
    episode: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeEpisodeById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimeEpisodeByIdQueryKey(id,episode);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimeEpisodeById>>> = ({ signal }) => getAnimeEpisodeById(id,episode, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id && episode),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeEpisodeById>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAnimeEpisodeByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimeEpisodeById>>>
export type GetAnimeEpisodeByIdInfiniteQueryError = AxiosError<void>

export const useGetAnimeEpisodeByIdInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimeEpisodeById>>>, TError = AxiosError<void>>(
 id: number,
    episode: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeEpisodeById>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimeEpisodeByIdInfiniteQueryOptions(id,episode,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAnimeEpisodeByIdQueryOptions = <TData = Awaited<ReturnType<typeof getAnimeEpisodeById>>, TError = AxiosError<void>>(id: number,
    episode: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimeEpisodeById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimeEpisodeByIdQueryKey(id,episode);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimeEpisodeById>>> = ({ signal }) => getAnimeEpisodeById(id,episode, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id && episode),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAnimeEpisodeById>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAnimeEpisodeByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimeEpisodeById>>>
export type GetAnimeEpisodeByIdQueryError = AxiosError<void>

export const useGetAnimeEpisodeById = <TData = Awaited<ReturnType<typeof getAnimeEpisodeById>>, TError = AxiosError<void>>(
 id: number,
    episode: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimeEpisodeById>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimeEpisodeByIdQueryOptions(id,episode,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAnimeNews = (
    id: number,
    params?: GetAnimeNewsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AnimeNews>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/anime/${id}/news`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetAnimeNewsQueryKey = (id: number,
    params?: GetAnimeNewsParams,) => {
    return [`https://api.jikan.moe/v4/anime/${id}/news`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAnimeNewsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimeNews>>, GetAnimeNewsParams['page']>, TError = AxiosError<void>>(id: number,
    params?: GetAnimeNewsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeNews>>, TError, TData, Awaited<ReturnType<typeof getAnimeNews>>, QueryKey, GetAnimeNewsParams['page']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimeNewsQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimeNews>>, QueryKey, GetAnimeNewsParams['page']> = ({ signal, pageParam }) => getAnimeNews(id,{...params, page: pageParam || params?.['page']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeNews>>, TError, TData, Awaited<ReturnType<typeof getAnimeNews>>, QueryKey, GetAnimeNewsParams['page']> & { queryKey: QueryKey }
}

export type GetAnimeNewsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimeNews>>>
export type GetAnimeNewsInfiniteQueryError = AxiosError<void>

export const useGetAnimeNewsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimeNews>>, GetAnimeNewsParams['page']>, TError = AxiosError<void>>(
 id: number,
    params?: GetAnimeNewsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeNews>>, TError, TData, Awaited<ReturnType<typeof getAnimeNews>>, QueryKey, GetAnimeNewsParams['page']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimeNewsInfiniteQueryOptions(id,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAnimeNewsQueryOptions = <TData = Awaited<ReturnType<typeof getAnimeNews>>, TError = AxiosError<void>>(id: number,
    params?: GetAnimeNewsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimeNews>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimeNewsQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimeNews>>> = ({ signal }) => getAnimeNews(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAnimeNews>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAnimeNewsQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimeNews>>>
export type GetAnimeNewsQueryError = AxiosError<void>

export const useGetAnimeNews = <TData = Awaited<ReturnType<typeof getAnimeNews>>, TError = AxiosError<void>>(
 id: number,
    params?: GetAnimeNewsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimeNews>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimeNewsQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAnimeForum = (
    id: number,
    params?: GetAnimeForumParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Forum>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/anime/${id}/forum`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getAnimeVideos = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AnimeVideos>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/anime/${id}/videos`,options
    );
  }


export const getGetAnimeVideosQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/anime/${id}/videos`] as const;
    }

    
export const getGetAnimeVideosInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimeVideos>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeVideos>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimeVideosQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimeVideos>>> = ({ signal }) => getAnimeVideos(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeVideos>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAnimeVideosInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimeVideos>>>
export type GetAnimeVideosInfiniteQueryError = AxiosError<void>

export const useGetAnimeVideosInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimeVideos>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeVideos>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimeVideosInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAnimeVideosQueryOptions = <TData = Awaited<ReturnType<typeof getAnimeVideos>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimeVideos>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimeVideosQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimeVideos>>> = ({ signal }) => getAnimeVideos(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAnimeVideos>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAnimeVideosQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimeVideos>>>
export type GetAnimeVideosQueryError = AxiosError<void>

export const useGetAnimeVideos = <TData = Awaited<ReturnType<typeof getAnimeVideos>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimeVideos>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimeVideosQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAnimeVideosEpisodes = (
    id: number,
    params?: GetAnimeVideosEpisodesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AnimeVideosEpisodes>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/anime/${id}/videos/episodes`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetAnimeVideosEpisodesQueryKey = (id: number,
    params?: GetAnimeVideosEpisodesParams,) => {
    return [`https://api.jikan.moe/v4/anime/${id}/videos/episodes`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAnimeVideosEpisodesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimeVideosEpisodes>>, GetAnimeVideosEpisodesParams['page']>, TError = AxiosError<void>>(id: number,
    params?: GetAnimeVideosEpisodesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeVideosEpisodes>>, TError, TData, Awaited<ReturnType<typeof getAnimeVideosEpisodes>>, QueryKey, GetAnimeVideosEpisodesParams['page']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimeVideosEpisodesQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimeVideosEpisodes>>, QueryKey, GetAnimeVideosEpisodesParams['page']> = ({ signal, pageParam }) => getAnimeVideosEpisodes(id,{...params, page: pageParam || params?.['page']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeVideosEpisodes>>, TError, TData, Awaited<ReturnType<typeof getAnimeVideosEpisodes>>, QueryKey, GetAnimeVideosEpisodesParams['page']> & { queryKey: QueryKey }
}

export type GetAnimeVideosEpisodesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimeVideosEpisodes>>>
export type GetAnimeVideosEpisodesInfiniteQueryError = AxiosError<void>

export const useGetAnimeVideosEpisodesInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimeVideosEpisodes>>, GetAnimeVideosEpisodesParams['page']>, TError = AxiosError<void>>(
 id: number,
    params?: GetAnimeVideosEpisodesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeVideosEpisodes>>, TError, TData, Awaited<ReturnType<typeof getAnimeVideosEpisodes>>, QueryKey, GetAnimeVideosEpisodesParams['page']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimeVideosEpisodesInfiniteQueryOptions(id,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAnimeVideosEpisodesQueryOptions = <TData = Awaited<ReturnType<typeof getAnimeVideosEpisodes>>, TError = AxiosError<void>>(id: number,
    params?: GetAnimeVideosEpisodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimeVideosEpisodes>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimeVideosEpisodesQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimeVideosEpisodes>>> = ({ signal }) => getAnimeVideosEpisodes(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAnimeVideosEpisodes>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAnimeVideosEpisodesQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimeVideosEpisodes>>>
export type GetAnimeVideosEpisodesQueryError = AxiosError<void>

export const useGetAnimeVideosEpisodes = <TData = Awaited<ReturnType<typeof getAnimeVideosEpisodes>>, TError = AxiosError<void>>(
 id: number,
    params?: GetAnimeVideosEpisodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimeVideosEpisodes>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimeVideosEpisodesQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAnimePictures = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PicturesVariants>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/anime/${id}/pictures`,options
    );
  }


export const getGetAnimePicturesQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/anime/${id}/pictures`] as const;
    }

    
export const getGetAnimePicturesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimePictures>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimePictures>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimePicturesQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimePictures>>> = ({ signal }) => getAnimePictures(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimePictures>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAnimePicturesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimePictures>>>
export type GetAnimePicturesInfiniteQueryError = AxiosError<void>

export const useGetAnimePicturesInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimePictures>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimePictures>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimePicturesInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAnimePicturesQueryOptions = <TData = Awaited<ReturnType<typeof getAnimePictures>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimePictures>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimePicturesQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimePictures>>> = ({ signal }) => getAnimePictures(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAnimePictures>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAnimePicturesQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimePictures>>>
export type GetAnimePicturesQueryError = AxiosError<void>

export const useGetAnimePictures = <TData = Awaited<ReturnType<typeof getAnimePictures>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimePictures>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimePicturesQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAnimeStatistics = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AnimeStatistics>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/anime/${id}/statistics`,options
    );
  }


export const getGetAnimeStatisticsQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/anime/${id}/statistics`] as const;
    }

    
export const getGetAnimeStatisticsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimeStatistics>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeStatistics>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimeStatisticsQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimeStatistics>>> = ({ signal }) => getAnimeStatistics(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeStatistics>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAnimeStatisticsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimeStatistics>>>
export type GetAnimeStatisticsInfiniteQueryError = AxiosError<void>

export const useGetAnimeStatisticsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimeStatistics>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeStatistics>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimeStatisticsInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAnimeStatisticsQueryOptions = <TData = Awaited<ReturnType<typeof getAnimeStatistics>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimeStatistics>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimeStatisticsQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimeStatistics>>> = ({ signal }) => getAnimeStatistics(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAnimeStatistics>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAnimeStatisticsQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimeStatistics>>>
export type GetAnimeStatisticsQueryError = AxiosError<void>

export const useGetAnimeStatistics = <TData = Awaited<ReturnType<typeof getAnimeStatistics>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimeStatistics>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimeStatisticsQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAnimeMoreInfo = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Moreinfo>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/anime/${id}/moreinfo`,options
    );
  }


export const getGetAnimeMoreInfoQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/anime/${id}/moreinfo`] as const;
    }

    
export const getGetAnimeMoreInfoInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimeMoreInfo>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeMoreInfo>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimeMoreInfoQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimeMoreInfo>>> = ({ signal }) => getAnimeMoreInfo(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeMoreInfo>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAnimeMoreInfoInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimeMoreInfo>>>
export type GetAnimeMoreInfoInfiniteQueryError = AxiosError<void>

export const useGetAnimeMoreInfoInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimeMoreInfo>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeMoreInfo>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimeMoreInfoInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAnimeMoreInfoQueryOptions = <TData = Awaited<ReturnType<typeof getAnimeMoreInfo>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimeMoreInfo>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimeMoreInfoQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimeMoreInfo>>> = ({ signal }) => getAnimeMoreInfo(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAnimeMoreInfo>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAnimeMoreInfoQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimeMoreInfo>>>
export type GetAnimeMoreInfoQueryError = AxiosError<void>

export const useGetAnimeMoreInfo = <TData = Awaited<ReturnType<typeof getAnimeMoreInfo>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimeMoreInfo>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimeMoreInfoQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAnimeRecommendations = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EntryRecommendations>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/anime/${id}/recommendations`,options
    );
  }


export const getGetAnimeRecommendationsQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/anime/${id}/recommendations`] as const;
    }

    
export const getGetAnimeRecommendationsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimeRecommendations>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeRecommendations>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimeRecommendationsQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimeRecommendations>>> = ({ signal }) => getAnimeRecommendations(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeRecommendations>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAnimeRecommendationsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimeRecommendations>>>
export type GetAnimeRecommendationsInfiniteQueryError = AxiosError<void>

export const useGetAnimeRecommendationsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimeRecommendations>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeRecommendations>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimeRecommendationsInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAnimeRecommendationsQueryOptions = <TData = Awaited<ReturnType<typeof getAnimeRecommendations>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimeRecommendations>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimeRecommendationsQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimeRecommendations>>> = ({ signal }) => getAnimeRecommendations(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAnimeRecommendations>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAnimeRecommendationsQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimeRecommendations>>>
export type GetAnimeRecommendationsQueryError = AxiosError<void>

export const useGetAnimeRecommendations = <TData = Awaited<ReturnType<typeof getAnimeRecommendations>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimeRecommendations>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimeRecommendationsQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAnimeUserUpdates = (
    id: number,
    params?: GetAnimeUserUpdatesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AnimeUserupdates>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/anime/${id}/userupdates`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetAnimeUserUpdatesQueryKey = (id: number,
    params?: GetAnimeUserUpdatesParams,) => {
    return [`https://api.jikan.moe/v4/anime/${id}/userupdates`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAnimeUserUpdatesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimeUserUpdates>>, GetAnimeUserUpdatesParams['page']>, TError = AxiosError<void>>(id: number,
    params?: GetAnimeUserUpdatesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeUserUpdates>>, TError, TData, Awaited<ReturnType<typeof getAnimeUserUpdates>>, QueryKey, GetAnimeUserUpdatesParams['page']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimeUserUpdatesQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimeUserUpdates>>, QueryKey, GetAnimeUserUpdatesParams['page']> = ({ signal, pageParam }) => getAnimeUserUpdates(id,{...params, page: pageParam || params?.['page']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeUserUpdates>>, TError, TData, Awaited<ReturnType<typeof getAnimeUserUpdates>>, QueryKey, GetAnimeUserUpdatesParams['page']> & { queryKey: QueryKey }
}

export type GetAnimeUserUpdatesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimeUserUpdates>>>
export type GetAnimeUserUpdatesInfiniteQueryError = AxiosError<void>

export const useGetAnimeUserUpdatesInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimeUserUpdates>>, GetAnimeUserUpdatesParams['page']>, TError = AxiosError<void>>(
 id: number,
    params?: GetAnimeUserUpdatesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeUserUpdates>>, TError, TData, Awaited<ReturnType<typeof getAnimeUserUpdates>>, QueryKey, GetAnimeUserUpdatesParams['page']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimeUserUpdatesInfiniteQueryOptions(id,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAnimeUserUpdatesQueryOptions = <TData = Awaited<ReturnType<typeof getAnimeUserUpdates>>, TError = AxiosError<void>>(id: number,
    params?: GetAnimeUserUpdatesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimeUserUpdates>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimeUserUpdatesQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimeUserUpdates>>> = ({ signal }) => getAnimeUserUpdates(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAnimeUserUpdates>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAnimeUserUpdatesQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimeUserUpdates>>>
export type GetAnimeUserUpdatesQueryError = AxiosError<void>

export const useGetAnimeUserUpdates = <TData = Awaited<ReturnType<typeof getAnimeUserUpdates>>, TError = AxiosError<void>>(
 id: number,
    params?: GetAnimeUserUpdatesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimeUserUpdates>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimeUserUpdatesQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAnimeReviews = (
    id: number,
    params?: GetAnimeReviewsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AnimeReviews>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/anime/${id}/reviews`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetAnimeReviewsQueryKey = (id: number,
    params?: GetAnimeReviewsParams,) => {
    return [`https://api.jikan.moe/v4/anime/${id}/reviews`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAnimeReviewsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimeReviews>>, GetAnimeReviewsParams['page']>, TError = AxiosError<void>>(id: number,
    params?: GetAnimeReviewsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeReviews>>, TError, TData, Awaited<ReturnType<typeof getAnimeReviews>>, QueryKey, GetAnimeReviewsParams['page']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimeReviewsQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimeReviews>>, QueryKey, GetAnimeReviewsParams['page']> = ({ signal, pageParam }) => getAnimeReviews(id,{...params, page: pageParam || params?.['page']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeReviews>>, TError, TData, Awaited<ReturnType<typeof getAnimeReviews>>, QueryKey, GetAnimeReviewsParams['page']> & { queryKey: QueryKey }
}

export type GetAnimeReviewsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimeReviews>>>
export type GetAnimeReviewsInfiniteQueryError = AxiosError<void>

export const useGetAnimeReviewsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimeReviews>>, GetAnimeReviewsParams['page']>, TError = AxiosError<void>>(
 id: number,
    params?: GetAnimeReviewsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeReviews>>, TError, TData, Awaited<ReturnType<typeof getAnimeReviews>>, QueryKey, GetAnimeReviewsParams['page']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimeReviewsInfiniteQueryOptions(id,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAnimeReviewsQueryOptions = <TData = Awaited<ReturnType<typeof getAnimeReviews>>, TError = AxiosError<void>>(id: number,
    params?: GetAnimeReviewsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimeReviews>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimeReviewsQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimeReviews>>> = ({ signal }) => getAnimeReviews(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAnimeReviews>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAnimeReviewsQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimeReviews>>>
export type GetAnimeReviewsQueryError = AxiosError<void>

export const useGetAnimeReviews = <TData = Awaited<ReturnType<typeof getAnimeReviews>>, TError = AxiosError<void>>(
 id: number,
    params?: GetAnimeReviewsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimeReviews>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimeReviewsQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAnimeRelations = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetAnimeRelations200>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/anime/${id}/relations`,options
    );
  }


export const getGetAnimeRelationsQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/anime/${id}/relations`] as const;
    }

    
export const getGetAnimeRelationsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimeRelations>>>, TError = AxiosError<unknown>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeRelations>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimeRelationsQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimeRelations>>> = ({ signal }) => getAnimeRelations(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeRelations>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAnimeRelationsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimeRelations>>>
export type GetAnimeRelationsInfiniteQueryError = AxiosError<unknown>

export const useGetAnimeRelationsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimeRelations>>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeRelations>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimeRelationsInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAnimeRelationsQueryOptions = <TData = Awaited<ReturnType<typeof getAnimeRelations>>, TError = AxiosError<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimeRelations>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimeRelationsQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimeRelations>>> = ({ signal }) => getAnimeRelations(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAnimeRelations>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAnimeRelationsQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimeRelations>>>
export type GetAnimeRelationsQueryError = AxiosError<unknown>

export const useGetAnimeRelations = <TData = Awaited<ReturnType<typeof getAnimeRelations>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimeRelations>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimeRelationsQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAnimeThemes = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AnimeThemes>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/anime/${id}/themes`,options
    );
  }


export const getGetAnimeThemesQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/anime/${id}/themes`] as const;
    }

    
export const getGetAnimeThemesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimeThemes>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeThemes>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimeThemesQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimeThemes>>> = ({ signal }) => getAnimeThemes(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeThemes>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAnimeThemesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimeThemes>>>
export type GetAnimeThemesInfiniteQueryError = AxiosError<void>

export const useGetAnimeThemesInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimeThemes>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeThemes>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimeThemesInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAnimeThemesQueryOptions = <TData = Awaited<ReturnType<typeof getAnimeThemes>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimeThemes>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimeThemesQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimeThemes>>> = ({ signal }) => getAnimeThemes(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAnimeThemes>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAnimeThemesQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimeThemes>>>
export type GetAnimeThemesQueryError = AxiosError<void>

export const useGetAnimeThemes = <TData = Awaited<ReturnType<typeof getAnimeThemes>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimeThemes>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimeThemesQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAnimeExternal = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ExternalLinks>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/anime/${id}/external`,options
    );
  }


export const getGetAnimeExternalQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/anime/${id}/external`] as const;
    }

    
export const getGetAnimeExternalInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimeExternal>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeExternal>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimeExternalQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimeExternal>>> = ({ signal }) => getAnimeExternal(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeExternal>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAnimeExternalInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimeExternal>>>
export type GetAnimeExternalInfiniteQueryError = AxiosError<void>

export const useGetAnimeExternalInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimeExternal>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeExternal>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimeExternalInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAnimeExternalQueryOptions = <TData = Awaited<ReturnType<typeof getAnimeExternal>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimeExternal>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimeExternalQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimeExternal>>> = ({ signal }) => getAnimeExternal(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAnimeExternal>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAnimeExternalQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimeExternal>>>
export type GetAnimeExternalQueryError = AxiosError<void>

export const useGetAnimeExternal = <TData = Awaited<ReturnType<typeof getAnimeExternal>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimeExternal>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimeExternalQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAnimeStreaming = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ExternalLinks>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/anime/${id}/streaming`,options
    );
  }


export const getGetAnimeStreamingQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/anime/${id}/streaming`] as const;
    }

    
export const getGetAnimeStreamingInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimeStreaming>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeStreaming>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimeStreamingQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimeStreaming>>> = ({ signal }) => getAnimeStreaming(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeStreaming>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAnimeStreamingInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimeStreaming>>>
export type GetAnimeStreamingInfiniteQueryError = AxiosError<void>

export const useGetAnimeStreamingInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimeStreaming>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeStreaming>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimeStreamingInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAnimeStreamingQueryOptions = <TData = Awaited<ReturnType<typeof getAnimeStreaming>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimeStreaming>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimeStreamingQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimeStreaming>>> = ({ signal }) => getAnimeStreaming(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAnimeStreaming>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAnimeStreamingQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimeStreaming>>>
export type GetAnimeStreamingQueryError = AxiosError<void>

export const useGetAnimeStreaming = <TData = Awaited<ReturnType<typeof getAnimeStreaming>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimeStreaming>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimeStreamingQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getCharacterFullById = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetCharacterFullById200>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/characters/${id}/full`,options
    );
  }


export const getGetCharacterFullByIdQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/characters/${id}/full`] as const;
    }

    
export const getGetCharacterFullByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCharacterFullById>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCharacterFullById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCharacterFullByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCharacterFullById>>> = ({ signal }) => getCharacterFullById(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCharacterFullById>>, TError, TData> & { queryKey: QueryKey }
}

export type GetCharacterFullByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCharacterFullById>>>
export type GetCharacterFullByIdInfiniteQueryError = AxiosError<void>

export const useGetCharacterFullByIdInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getCharacterFullById>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCharacterFullById>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetCharacterFullByIdInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCharacterFullByIdQueryOptions = <TData = Awaited<ReturnType<typeof getCharacterFullById>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCharacterFullById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCharacterFullByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCharacterFullById>>> = ({ signal }) => getCharacterFullById(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCharacterFullById>>, TError, TData> & { queryKey: QueryKey }
}

export type GetCharacterFullByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCharacterFullById>>>
export type GetCharacterFullByIdQueryError = AxiosError<void>

export const useGetCharacterFullById = <TData = Awaited<ReturnType<typeof getCharacterFullById>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCharacterFullById>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetCharacterFullByIdQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getCharacterById = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetCharacterById200>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/characters/${id}`,options
    );
  }


export const getGetCharacterByIdQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/characters/${id}`] as const;
    }

    
export const getGetCharacterByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCharacterById>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCharacterById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCharacterByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCharacterById>>> = ({ signal }) => getCharacterById(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCharacterById>>, TError, TData> & { queryKey: QueryKey }
}

export type GetCharacterByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCharacterById>>>
export type GetCharacterByIdInfiniteQueryError = AxiosError<void>

export const useGetCharacterByIdInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getCharacterById>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCharacterById>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetCharacterByIdInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCharacterByIdQueryOptions = <TData = Awaited<ReturnType<typeof getCharacterById>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCharacterById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCharacterByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCharacterById>>> = ({ signal }) => getCharacterById(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCharacterById>>, TError, TData> & { queryKey: QueryKey }
}

export type GetCharacterByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCharacterById>>>
export type GetCharacterByIdQueryError = AxiosError<void>

export const useGetCharacterById = <TData = Awaited<ReturnType<typeof getCharacterById>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCharacterById>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetCharacterByIdQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getCharacterAnime = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CharacterAnime>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/characters/${id}/anime`,options
    );
  }


export const getGetCharacterAnimeQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/characters/${id}/anime`] as const;
    }

    
export const getGetCharacterAnimeInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCharacterAnime>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCharacterAnime>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCharacterAnimeQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCharacterAnime>>> = ({ signal }) => getCharacterAnime(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCharacterAnime>>, TError, TData> & { queryKey: QueryKey }
}

export type GetCharacterAnimeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCharacterAnime>>>
export type GetCharacterAnimeInfiniteQueryError = AxiosError<void>

export const useGetCharacterAnimeInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getCharacterAnime>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCharacterAnime>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetCharacterAnimeInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCharacterAnimeQueryOptions = <TData = Awaited<ReturnType<typeof getCharacterAnime>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCharacterAnime>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCharacterAnimeQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCharacterAnime>>> = ({ signal }) => getCharacterAnime(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCharacterAnime>>, TError, TData> & { queryKey: QueryKey }
}

export type GetCharacterAnimeQueryResult = NonNullable<Awaited<ReturnType<typeof getCharacterAnime>>>
export type GetCharacterAnimeQueryError = AxiosError<void>

export const useGetCharacterAnime = <TData = Awaited<ReturnType<typeof getCharacterAnime>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCharacterAnime>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetCharacterAnimeQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getCharacterManga = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CharacterManga>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/characters/${id}/manga`,options
    );
  }


export const getGetCharacterMangaQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/characters/${id}/manga`] as const;
    }

    
export const getGetCharacterMangaInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCharacterManga>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCharacterManga>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCharacterMangaQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCharacterManga>>> = ({ signal }) => getCharacterManga(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCharacterManga>>, TError, TData> & { queryKey: QueryKey }
}

export type GetCharacterMangaInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCharacterManga>>>
export type GetCharacterMangaInfiniteQueryError = AxiosError<void>

export const useGetCharacterMangaInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getCharacterManga>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCharacterManga>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetCharacterMangaInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCharacterMangaQueryOptions = <TData = Awaited<ReturnType<typeof getCharacterManga>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCharacterManga>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCharacterMangaQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCharacterManga>>> = ({ signal }) => getCharacterManga(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCharacterManga>>, TError, TData> & { queryKey: QueryKey }
}

export type GetCharacterMangaQueryResult = NonNullable<Awaited<ReturnType<typeof getCharacterManga>>>
export type GetCharacterMangaQueryError = AxiosError<void>

export const useGetCharacterManga = <TData = Awaited<ReturnType<typeof getCharacterManga>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCharacterManga>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetCharacterMangaQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getCharacterVoiceActors = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CharacterVoiceActors>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/characters/${id}/voices`,options
    );
  }


export const getGetCharacterVoiceActorsQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/characters/${id}/voices`] as const;
    }

    
export const getGetCharacterVoiceActorsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCharacterVoiceActors>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCharacterVoiceActors>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCharacterVoiceActorsQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCharacterVoiceActors>>> = ({ signal }) => getCharacterVoiceActors(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCharacterVoiceActors>>, TError, TData> & { queryKey: QueryKey }
}

export type GetCharacterVoiceActorsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCharacterVoiceActors>>>
export type GetCharacterVoiceActorsInfiniteQueryError = AxiosError<void>

export const useGetCharacterVoiceActorsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getCharacterVoiceActors>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCharacterVoiceActors>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetCharacterVoiceActorsInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCharacterVoiceActorsQueryOptions = <TData = Awaited<ReturnType<typeof getCharacterVoiceActors>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCharacterVoiceActors>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCharacterVoiceActorsQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCharacterVoiceActors>>> = ({ signal }) => getCharacterVoiceActors(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCharacterVoiceActors>>, TError, TData> & { queryKey: QueryKey }
}

export type GetCharacterVoiceActorsQueryResult = NonNullable<Awaited<ReturnType<typeof getCharacterVoiceActors>>>
export type GetCharacterVoiceActorsQueryError = AxiosError<void>

export const useGetCharacterVoiceActors = <TData = Awaited<ReturnType<typeof getCharacterVoiceActors>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCharacterVoiceActors>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetCharacterVoiceActorsQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getCharacterPictures = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CharacterPictures>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/characters/${id}/pictures`,options
    );
  }


export const getGetCharacterPicturesQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/characters/${id}/pictures`] as const;
    }

    
export const getGetCharacterPicturesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCharacterPictures>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCharacterPictures>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCharacterPicturesQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCharacterPictures>>> = ({ signal }) => getCharacterPictures(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCharacterPictures>>, TError, TData> & { queryKey: QueryKey }
}

export type GetCharacterPicturesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCharacterPictures>>>
export type GetCharacterPicturesInfiniteQueryError = AxiosError<void>

export const useGetCharacterPicturesInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getCharacterPictures>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCharacterPictures>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetCharacterPicturesInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCharacterPicturesQueryOptions = <TData = Awaited<ReturnType<typeof getCharacterPictures>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCharacterPictures>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCharacterPicturesQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCharacterPictures>>> = ({ signal }) => getCharacterPictures(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCharacterPictures>>, TError, TData> & { queryKey: QueryKey }
}

export type GetCharacterPicturesQueryResult = NonNullable<Awaited<ReturnType<typeof getCharacterPictures>>>
export type GetCharacterPicturesQueryError = AxiosError<void>

export const useGetCharacterPictures = <TData = Awaited<ReturnType<typeof getCharacterPictures>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCharacterPictures>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetCharacterPicturesQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getClubsById = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetClubsById200>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/clubs/${id}`,options
    );
  }


export const getGetClubsByIdQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/clubs/${id}`] as const;
    }

    
export const getGetClubsByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getClubsById>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getClubsById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetClubsByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getClubsById>>> = ({ signal }) => getClubsById(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getClubsById>>, TError, TData> & { queryKey: QueryKey }
}

export type GetClubsByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getClubsById>>>
export type GetClubsByIdInfiniteQueryError = AxiosError<void>

export const useGetClubsByIdInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getClubsById>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getClubsById>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetClubsByIdInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetClubsByIdQueryOptions = <TData = Awaited<ReturnType<typeof getClubsById>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClubsById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetClubsByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getClubsById>>> = ({ signal }) => getClubsById(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getClubsById>>, TError, TData> & { queryKey: QueryKey }
}

export type GetClubsByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getClubsById>>>
export type GetClubsByIdQueryError = AxiosError<void>

export const useGetClubsById = <TData = Awaited<ReturnType<typeof getClubsById>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClubsById>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetClubsByIdQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getClubMembers = (
    id: number,
    params?: GetClubMembersParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetClubMembers200>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/clubs/${id}/members`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetClubMembersQueryKey = (id: number,
    params?: GetClubMembersParams,) => {
    return [`https://api.jikan.moe/v4/clubs/${id}/members`, ...(params ? [params]: [])] as const;
    }

    
export const getGetClubMembersInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getClubMembers>>, GetClubMembersParams['page']>, TError = AxiosError<void>>(id: number,
    params?: GetClubMembersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getClubMembers>>, TError, TData, Awaited<ReturnType<typeof getClubMembers>>, QueryKey, GetClubMembersParams['page']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetClubMembersQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getClubMembers>>, QueryKey, GetClubMembersParams['page']> = ({ signal, pageParam }) => getClubMembers(id,{...params, page: pageParam || params?.['page']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getClubMembers>>, TError, TData, Awaited<ReturnType<typeof getClubMembers>>, QueryKey, GetClubMembersParams['page']> & { queryKey: QueryKey }
}

export type GetClubMembersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getClubMembers>>>
export type GetClubMembersInfiniteQueryError = AxiosError<void>

export const useGetClubMembersInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getClubMembers>>, GetClubMembersParams['page']>, TError = AxiosError<void>>(
 id: number,
    params?: GetClubMembersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getClubMembers>>, TError, TData, Awaited<ReturnType<typeof getClubMembers>>, QueryKey, GetClubMembersParams['page']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetClubMembersInfiniteQueryOptions(id,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetClubMembersQueryOptions = <TData = Awaited<ReturnType<typeof getClubMembers>>, TError = AxiosError<void>>(id: number,
    params?: GetClubMembersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClubMembers>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetClubMembersQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getClubMembers>>> = ({ signal }) => getClubMembers(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getClubMembers>>, TError, TData> & { queryKey: QueryKey }
}

export type GetClubMembersQueryResult = NonNullable<Awaited<ReturnType<typeof getClubMembers>>>
export type GetClubMembersQueryError = AxiosError<void>

export const useGetClubMembers = <TData = Awaited<ReturnType<typeof getClubMembers>>, TError = AxiosError<void>>(
 id: number,
    params?: GetClubMembersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClubMembers>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetClubMembersQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getClubStaff = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ClubStaff>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/clubs/${id}/staff`,options
    );
  }


export const getGetClubStaffQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/clubs/${id}/staff`] as const;
    }

    
export const getGetClubStaffInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getClubStaff>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getClubStaff>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetClubStaffQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getClubStaff>>> = ({ signal }) => getClubStaff(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getClubStaff>>, TError, TData> & { queryKey: QueryKey }
}

export type GetClubStaffInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getClubStaff>>>
export type GetClubStaffInfiniteQueryError = AxiosError<void>

export const useGetClubStaffInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getClubStaff>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getClubStaff>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetClubStaffInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetClubStaffQueryOptions = <TData = Awaited<ReturnType<typeof getClubStaff>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClubStaff>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetClubStaffQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getClubStaff>>> = ({ signal }) => getClubStaff(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getClubStaff>>, TError, TData> & { queryKey: QueryKey }
}

export type GetClubStaffQueryResult = NonNullable<Awaited<ReturnType<typeof getClubStaff>>>
export type GetClubStaffQueryError = AxiosError<void>

export const useGetClubStaff = <TData = Awaited<ReturnType<typeof getClubStaff>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClubStaff>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetClubStaffQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getClubRelations = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ClubRelations>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/clubs/${id}/relations`,options
    );
  }


export const getGetClubRelationsQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/clubs/${id}/relations`] as const;
    }

    
export const getGetClubRelationsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getClubRelations>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getClubRelations>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetClubRelationsQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getClubRelations>>> = ({ signal }) => getClubRelations(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getClubRelations>>, TError, TData> & { queryKey: QueryKey }
}

export type GetClubRelationsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getClubRelations>>>
export type GetClubRelationsInfiniteQueryError = AxiosError<void>

export const useGetClubRelationsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getClubRelations>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getClubRelations>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetClubRelationsInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetClubRelationsQueryOptions = <TData = Awaited<ReturnType<typeof getClubRelations>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClubRelations>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetClubRelationsQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getClubRelations>>> = ({ signal }) => getClubRelations(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getClubRelations>>, TError, TData> & { queryKey: QueryKey }
}

export type GetClubRelationsQueryResult = NonNullable<Awaited<ReturnType<typeof getClubRelations>>>
export type GetClubRelationsQueryError = AxiosError<void>

export const useGetClubRelations = <TData = Awaited<ReturnType<typeof getClubRelations>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClubRelations>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetClubRelationsQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAnimeGenres = (
    params?: GetAnimeGenresParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Genres>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/genres/anime`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getMangaGenres = (
    params?: GetMangaGenresParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Genres>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/genres/manga`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getMagazines = (
    params?: GetMagazinesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Magazines>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/magazines`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetMagazinesQueryKey = (params?: GetMagazinesParams,) => {
    return [`https://api.jikan.moe/v4/magazines`, ...(params ? [params]: [])] as const;
    }

    
export const getGetMagazinesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getMagazines>>, GetMagazinesParams['page']>, TError = AxiosError<void>>(params?: GetMagazinesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMagazines>>, TError, TData, Awaited<ReturnType<typeof getMagazines>>, QueryKey, GetMagazinesParams['page']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMagazinesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMagazines>>, QueryKey, GetMagazinesParams['page']> = ({ signal, pageParam }) => getMagazines({...params, page: pageParam || params?.['page']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMagazines>>, TError, TData, Awaited<ReturnType<typeof getMagazines>>, QueryKey, GetMagazinesParams['page']> & { queryKey: QueryKey }
}

export type GetMagazinesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMagazines>>>
export type GetMagazinesInfiniteQueryError = AxiosError<void>

export const useGetMagazinesInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getMagazines>>, GetMagazinesParams['page']>, TError = AxiosError<void>>(
 params?: GetMagazinesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMagazines>>, TError, TData, Awaited<ReturnType<typeof getMagazines>>, QueryKey, GetMagazinesParams['page']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMagazinesInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetMagazinesQueryOptions = <TData = Awaited<ReturnType<typeof getMagazines>>, TError = AxiosError<void>>(params?: GetMagazinesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMagazines>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMagazinesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMagazines>>> = ({ signal }) => getMagazines(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMagazines>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMagazinesQueryResult = NonNullable<Awaited<ReturnType<typeof getMagazines>>>
export type GetMagazinesQueryError = AxiosError<void>

export const useGetMagazines = <TData = Awaited<ReturnType<typeof getMagazines>>, TError = AxiosError<void>>(
 params?: GetMagazinesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMagazines>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMagazinesQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getMangaFullById = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetMangaFullById200>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/manga/${id}/full`,options
    );
  }


export const getGetMangaFullByIdQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/manga/${id}/full`] as const;
    }

    
export const getGetMangaFullByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getMangaFullById>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMangaFullById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMangaFullByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMangaFullById>>> = ({ signal }) => getMangaFullById(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMangaFullById>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMangaFullByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMangaFullById>>>
export type GetMangaFullByIdInfiniteQueryError = AxiosError<void>

export const useGetMangaFullByIdInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getMangaFullById>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMangaFullById>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMangaFullByIdInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetMangaFullByIdQueryOptions = <TData = Awaited<ReturnType<typeof getMangaFullById>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaFullById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMangaFullByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMangaFullById>>> = ({ signal }) => getMangaFullById(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMangaFullById>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMangaFullByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getMangaFullById>>>
export type GetMangaFullByIdQueryError = AxiosError<void>

export const useGetMangaFullById = <TData = Awaited<ReturnType<typeof getMangaFullById>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaFullById>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMangaFullByIdQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getMangaById = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetMangaById200>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/manga/${id}`,options
    );
  }


export const getGetMangaByIdQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/manga/${id}`] as const;
    }

    
export const getGetMangaByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getMangaById>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMangaById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMangaByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMangaById>>> = ({ signal }) => getMangaById(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMangaById>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMangaByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMangaById>>>
export type GetMangaByIdInfiniteQueryError = AxiosError<void>

export const useGetMangaByIdInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getMangaById>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMangaById>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMangaByIdInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetMangaByIdQueryOptions = <TData = Awaited<ReturnType<typeof getMangaById>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMangaByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMangaById>>> = ({ signal }) => getMangaById(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMangaById>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMangaByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getMangaById>>>
export type GetMangaByIdQueryError = AxiosError<void>

export const useGetMangaById = <TData = Awaited<ReturnType<typeof getMangaById>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaById>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMangaByIdQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getMangaCharacters = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MangaCharacters>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/manga/${id}/characters`,options
    );
  }


export const getGetMangaCharactersQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/manga/${id}/characters`] as const;
    }

    
export const getGetMangaCharactersInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getMangaCharacters>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMangaCharacters>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMangaCharactersQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMangaCharacters>>> = ({ signal }) => getMangaCharacters(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMangaCharacters>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMangaCharactersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMangaCharacters>>>
export type GetMangaCharactersInfiniteQueryError = AxiosError<void>

export const useGetMangaCharactersInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getMangaCharacters>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMangaCharacters>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMangaCharactersInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetMangaCharactersQueryOptions = <TData = Awaited<ReturnType<typeof getMangaCharacters>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaCharacters>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMangaCharactersQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMangaCharacters>>> = ({ signal }) => getMangaCharacters(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMangaCharacters>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMangaCharactersQueryResult = NonNullable<Awaited<ReturnType<typeof getMangaCharacters>>>
export type GetMangaCharactersQueryError = AxiosError<void>

export const useGetMangaCharacters = <TData = Awaited<ReturnType<typeof getMangaCharacters>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaCharacters>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMangaCharactersQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getMangaNews = (
    id: number,
    params?: GetMangaNewsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MangaNews>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/manga/${id}/news`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetMangaNewsQueryKey = (id: number,
    params?: GetMangaNewsParams,) => {
    return [`https://api.jikan.moe/v4/manga/${id}/news`, ...(params ? [params]: [])] as const;
    }

    
export const getGetMangaNewsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getMangaNews>>, GetMangaNewsParams['page']>, TError = AxiosError<void>>(id: number,
    params?: GetMangaNewsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMangaNews>>, TError, TData, Awaited<ReturnType<typeof getMangaNews>>, QueryKey, GetMangaNewsParams['page']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMangaNewsQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMangaNews>>, QueryKey, GetMangaNewsParams['page']> = ({ signal, pageParam }) => getMangaNews(id,{...params, page: pageParam || params?.['page']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMangaNews>>, TError, TData, Awaited<ReturnType<typeof getMangaNews>>, QueryKey, GetMangaNewsParams['page']> & { queryKey: QueryKey }
}

export type GetMangaNewsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMangaNews>>>
export type GetMangaNewsInfiniteQueryError = AxiosError<void>

export const useGetMangaNewsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getMangaNews>>, GetMangaNewsParams['page']>, TError = AxiosError<void>>(
 id: number,
    params?: GetMangaNewsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMangaNews>>, TError, TData, Awaited<ReturnType<typeof getMangaNews>>, QueryKey, GetMangaNewsParams['page']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMangaNewsInfiniteQueryOptions(id,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetMangaNewsQueryOptions = <TData = Awaited<ReturnType<typeof getMangaNews>>, TError = AxiosError<void>>(id: number,
    params?: GetMangaNewsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaNews>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMangaNewsQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMangaNews>>> = ({ signal }) => getMangaNews(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMangaNews>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMangaNewsQueryResult = NonNullable<Awaited<ReturnType<typeof getMangaNews>>>
export type GetMangaNewsQueryError = AxiosError<void>

export const useGetMangaNews = <TData = Awaited<ReturnType<typeof getMangaNews>>, TError = AxiosError<void>>(
 id: number,
    params?: GetMangaNewsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaNews>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMangaNewsQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getMangaTopics = (
    id: number,
    params?: GetMangaTopicsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Forum>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/manga/${id}/forum`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getMangaPictures = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MangaPictures>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/manga/${id}/pictures`,options
    );
  }


export const getGetMangaPicturesQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/manga/${id}/pictures`] as const;
    }

    
export const getGetMangaPicturesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getMangaPictures>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMangaPictures>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMangaPicturesQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMangaPictures>>> = ({ signal }) => getMangaPictures(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMangaPictures>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMangaPicturesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMangaPictures>>>
export type GetMangaPicturesInfiniteQueryError = AxiosError<void>

export const useGetMangaPicturesInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getMangaPictures>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMangaPictures>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMangaPicturesInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetMangaPicturesQueryOptions = <TData = Awaited<ReturnType<typeof getMangaPictures>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaPictures>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMangaPicturesQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMangaPictures>>> = ({ signal }) => getMangaPictures(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMangaPictures>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMangaPicturesQueryResult = NonNullable<Awaited<ReturnType<typeof getMangaPictures>>>
export type GetMangaPicturesQueryError = AxiosError<void>

export const useGetMangaPictures = <TData = Awaited<ReturnType<typeof getMangaPictures>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaPictures>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMangaPicturesQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getMangaStatistics = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MangaStatistics>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/manga/${id}/statistics`,options
    );
  }


export const getGetMangaStatisticsQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/manga/${id}/statistics`] as const;
    }

    
export const getGetMangaStatisticsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getMangaStatistics>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMangaStatistics>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMangaStatisticsQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMangaStatistics>>> = ({ signal }) => getMangaStatistics(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMangaStatistics>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMangaStatisticsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMangaStatistics>>>
export type GetMangaStatisticsInfiniteQueryError = AxiosError<void>

export const useGetMangaStatisticsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getMangaStatistics>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMangaStatistics>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMangaStatisticsInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetMangaStatisticsQueryOptions = <TData = Awaited<ReturnType<typeof getMangaStatistics>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaStatistics>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMangaStatisticsQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMangaStatistics>>> = ({ signal }) => getMangaStatistics(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMangaStatistics>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMangaStatisticsQueryResult = NonNullable<Awaited<ReturnType<typeof getMangaStatistics>>>
export type GetMangaStatisticsQueryError = AxiosError<void>

export const useGetMangaStatistics = <TData = Awaited<ReturnType<typeof getMangaStatistics>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaStatistics>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMangaStatisticsQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getMangaMoreInfo = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Moreinfo>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/manga/${id}/moreinfo`,options
    );
  }


export const getGetMangaMoreInfoQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/manga/${id}/moreinfo`] as const;
    }

    
export const getGetMangaMoreInfoInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getMangaMoreInfo>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMangaMoreInfo>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMangaMoreInfoQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMangaMoreInfo>>> = ({ signal }) => getMangaMoreInfo(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMangaMoreInfo>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMangaMoreInfoInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMangaMoreInfo>>>
export type GetMangaMoreInfoInfiniteQueryError = AxiosError<void>

export const useGetMangaMoreInfoInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getMangaMoreInfo>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMangaMoreInfo>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMangaMoreInfoInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetMangaMoreInfoQueryOptions = <TData = Awaited<ReturnType<typeof getMangaMoreInfo>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaMoreInfo>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMangaMoreInfoQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMangaMoreInfo>>> = ({ signal }) => getMangaMoreInfo(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMangaMoreInfo>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMangaMoreInfoQueryResult = NonNullable<Awaited<ReturnType<typeof getMangaMoreInfo>>>
export type GetMangaMoreInfoQueryError = AxiosError<void>

export const useGetMangaMoreInfo = <TData = Awaited<ReturnType<typeof getMangaMoreInfo>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaMoreInfo>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMangaMoreInfoQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getMangaRecommendations = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EntryRecommendations>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/manga/${id}/recommendations`,options
    );
  }


export const getGetMangaRecommendationsQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/manga/${id}/recommendations`] as const;
    }

    
export const getGetMangaRecommendationsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getMangaRecommendations>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMangaRecommendations>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMangaRecommendationsQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMangaRecommendations>>> = ({ signal }) => getMangaRecommendations(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMangaRecommendations>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMangaRecommendationsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMangaRecommendations>>>
export type GetMangaRecommendationsInfiniteQueryError = AxiosError<void>

export const useGetMangaRecommendationsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getMangaRecommendations>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMangaRecommendations>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMangaRecommendationsInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetMangaRecommendationsQueryOptions = <TData = Awaited<ReturnType<typeof getMangaRecommendations>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaRecommendations>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMangaRecommendationsQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMangaRecommendations>>> = ({ signal }) => getMangaRecommendations(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMangaRecommendations>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMangaRecommendationsQueryResult = NonNullable<Awaited<ReturnType<typeof getMangaRecommendations>>>
export type GetMangaRecommendationsQueryError = AxiosError<void>

export const useGetMangaRecommendations = <TData = Awaited<ReturnType<typeof getMangaRecommendations>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaRecommendations>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMangaRecommendationsQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getMangaUserUpdates = (
    id: number,
    params?: GetMangaUserUpdatesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MangaUserupdates>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/manga/${id}/userupdates`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetMangaUserUpdatesQueryKey = (id: number,
    params?: GetMangaUserUpdatesParams,) => {
    return [`https://api.jikan.moe/v4/manga/${id}/userupdates`, ...(params ? [params]: [])] as const;
    }

    
export const getGetMangaUserUpdatesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getMangaUserUpdates>>, GetMangaUserUpdatesParams['page']>, TError = AxiosError<void>>(id: number,
    params?: GetMangaUserUpdatesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMangaUserUpdates>>, TError, TData, Awaited<ReturnType<typeof getMangaUserUpdates>>, QueryKey, GetMangaUserUpdatesParams['page']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMangaUserUpdatesQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMangaUserUpdates>>, QueryKey, GetMangaUserUpdatesParams['page']> = ({ signal, pageParam }) => getMangaUserUpdates(id,{...params, page: pageParam || params?.['page']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMangaUserUpdates>>, TError, TData, Awaited<ReturnType<typeof getMangaUserUpdates>>, QueryKey, GetMangaUserUpdatesParams['page']> & { queryKey: QueryKey }
}

export type GetMangaUserUpdatesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMangaUserUpdates>>>
export type GetMangaUserUpdatesInfiniteQueryError = AxiosError<void>

export const useGetMangaUserUpdatesInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getMangaUserUpdates>>, GetMangaUserUpdatesParams['page']>, TError = AxiosError<void>>(
 id: number,
    params?: GetMangaUserUpdatesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMangaUserUpdates>>, TError, TData, Awaited<ReturnType<typeof getMangaUserUpdates>>, QueryKey, GetMangaUserUpdatesParams['page']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMangaUserUpdatesInfiniteQueryOptions(id,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetMangaUserUpdatesQueryOptions = <TData = Awaited<ReturnType<typeof getMangaUserUpdates>>, TError = AxiosError<void>>(id: number,
    params?: GetMangaUserUpdatesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaUserUpdates>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMangaUserUpdatesQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMangaUserUpdates>>> = ({ signal }) => getMangaUserUpdates(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMangaUserUpdates>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMangaUserUpdatesQueryResult = NonNullable<Awaited<ReturnType<typeof getMangaUserUpdates>>>
export type GetMangaUserUpdatesQueryError = AxiosError<void>

export const useGetMangaUserUpdates = <TData = Awaited<ReturnType<typeof getMangaUserUpdates>>, TError = AxiosError<void>>(
 id: number,
    params?: GetMangaUserUpdatesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaUserUpdates>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMangaUserUpdatesQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getMangaReviews = (
    id: number,
    params?: GetMangaReviewsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MangaReviews>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/manga/${id}/reviews`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetMangaReviewsQueryKey = (id: number,
    params?: GetMangaReviewsParams,) => {
    return [`https://api.jikan.moe/v4/manga/${id}/reviews`, ...(params ? [params]: [])] as const;
    }

    
export const getGetMangaReviewsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getMangaReviews>>, GetMangaReviewsParams['page']>, TError = AxiosError<void>>(id: number,
    params?: GetMangaReviewsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMangaReviews>>, TError, TData, Awaited<ReturnType<typeof getMangaReviews>>, QueryKey, GetMangaReviewsParams['page']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMangaReviewsQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMangaReviews>>, QueryKey, GetMangaReviewsParams['page']> = ({ signal, pageParam }) => getMangaReviews(id,{...params, page: pageParam || params?.['page']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMangaReviews>>, TError, TData, Awaited<ReturnType<typeof getMangaReviews>>, QueryKey, GetMangaReviewsParams['page']> & { queryKey: QueryKey }
}

export type GetMangaReviewsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMangaReviews>>>
export type GetMangaReviewsInfiniteQueryError = AxiosError<void>

export const useGetMangaReviewsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getMangaReviews>>, GetMangaReviewsParams['page']>, TError = AxiosError<void>>(
 id: number,
    params?: GetMangaReviewsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMangaReviews>>, TError, TData, Awaited<ReturnType<typeof getMangaReviews>>, QueryKey, GetMangaReviewsParams['page']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMangaReviewsInfiniteQueryOptions(id,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetMangaReviewsQueryOptions = <TData = Awaited<ReturnType<typeof getMangaReviews>>, TError = AxiosError<void>>(id: number,
    params?: GetMangaReviewsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaReviews>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMangaReviewsQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMangaReviews>>> = ({ signal }) => getMangaReviews(id,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMangaReviews>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMangaReviewsQueryResult = NonNullable<Awaited<ReturnType<typeof getMangaReviews>>>
export type GetMangaReviewsQueryError = AxiosError<void>

export const useGetMangaReviews = <TData = Awaited<ReturnType<typeof getMangaReviews>>, TError = AxiosError<void>>(
 id: number,
    params?: GetMangaReviewsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaReviews>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMangaReviewsQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getMangaRelations = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetMangaRelations200>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/manga/${id}/relations`,options
    );
  }


export const getGetMangaRelationsQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/manga/${id}/relations`] as const;
    }

    
export const getGetMangaRelationsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getMangaRelations>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMangaRelations>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMangaRelationsQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMangaRelations>>> = ({ signal }) => getMangaRelations(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMangaRelations>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMangaRelationsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMangaRelations>>>
export type GetMangaRelationsInfiniteQueryError = AxiosError<void>

export const useGetMangaRelationsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getMangaRelations>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMangaRelations>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMangaRelationsInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetMangaRelationsQueryOptions = <TData = Awaited<ReturnType<typeof getMangaRelations>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaRelations>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMangaRelationsQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMangaRelations>>> = ({ signal }) => getMangaRelations(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMangaRelations>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMangaRelationsQueryResult = NonNullable<Awaited<ReturnType<typeof getMangaRelations>>>
export type GetMangaRelationsQueryError = AxiosError<void>

export const useGetMangaRelations = <TData = Awaited<ReturnType<typeof getMangaRelations>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaRelations>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMangaRelationsQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getMangaExternal = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ExternalLinks>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/manga/${id}/external`,options
    );
  }


export const getGetMangaExternalQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/manga/${id}/external`] as const;
    }

    
export const getGetMangaExternalInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getMangaExternal>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMangaExternal>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMangaExternalQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMangaExternal>>> = ({ signal }) => getMangaExternal(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMangaExternal>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMangaExternalInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMangaExternal>>>
export type GetMangaExternalInfiniteQueryError = AxiosError<void>

export const useGetMangaExternalInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getMangaExternal>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMangaExternal>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMangaExternalInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetMangaExternalQueryOptions = <TData = Awaited<ReturnType<typeof getMangaExternal>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaExternal>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMangaExternalQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMangaExternal>>> = ({ signal }) => getMangaExternal(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMangaExternal>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMangaExternalQueryResult = NonNullable<Awaited<ReturnType<typeof getMangaExternal>>>
export type GetMangaExternalQueryError = AxiosError<void>

export const useGetMangaExternal = <TData = Awaited<ReturnType<typeof getMangaExternal>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaExternal>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMangaExternalQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getPersonFullById = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetPersonFullById200>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/people/${id}/full`,options
    );
  }


export const getGetPersonFullByIdQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/people/${id}/full`] as const;
    }

    
export const getGetPersonFullByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getPersonFullById>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPersonFullById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPersonFullByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPersonFullById>>> = ({ signal }) => getPersonFullById(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPersonFullById>>, TError, TData> & { queryKey: QueryKey }
}

export type GetPersonFullByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getPersonFullById>>>
export type GetPersonFullByIdInfiniteQueryError = AxiosError<void>

export const useGetPersonFullByIdInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getPersonFullById>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPersonFullById>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetPersonFullByIdInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetPersonFullByIdQueryOptions = <TData = Awaited<ReturnType<typeof getPersonFullById>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPersonFullById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPersonFullByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPersonFullById>>> = ({ signal }) => getPersonFullById(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPersonFullById>>, TError, TData> & { queryKey: QueryKey }
}

export type GetPersonFullByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getPersonFullById>>>
export type GetPersonFullByIdQueryError = AxiosError<void>

export const useGetPersonFullById = <TData = Awaited<ReturnType<typeof getPersonFullById>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPersonFullById>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetPersonFullByIdQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getPersonById = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetPersonById200>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/people/${id}`,options
    );
  }


export const getGetPersonByIdQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/people/${id}`] as const;
    }

    
export const getGetPersonByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getPersonById>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPersonById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPersonByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPersonById>>> = ({ signal }) => getPersonById(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPersonById>>, TError, TData> & { queryKey: QueryKey }
}

export type GetPersonByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getPersonById>>>
export type GetPersonByIdInfiniteQueryError = AxiosError<void>

export const useGetPersonByIdInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getPersonById>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPersonById>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetPersonByIdInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetPersonByIdQueryOptions = <TData = Awaited<ReturnType<typeof getPersonById>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPersonById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPersonByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPersonById>>> = ({ signal }) => getPersonById(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPersonById>>, TError, TData> & { queryKey: QueryKey }
}

export type GetPersonByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getPersonById>>>
export type GetPersonByIdQueryError = AxiosError<void>

export const useGetPersonById = <TData = Awaited<ReturnType<typeof getPersonById>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPersonById>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetPersonByIdQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getPersonAnime = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PersonAnime>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/people/${id}/anime`,options
    );
  }


export const getGetPersonAnimeQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/people/${id}/anime`] as const;
    }

    
export const getGetPersonAnimeInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getPersonAnime>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPersonAnime>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPersonAnimeQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPersonAnime>>> = ({ signal }) => getPersonAnime(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPersonAnime>>, TError, TData> & { queryKey: QueryKey }
}

export type GetPersonAnimeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getPersonAnime>>>
export type GetPersonAnimeInfiniteQueryError = AxiosError<void>

export const useGetPersonAnimeInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getPersonAnime>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPersonAnime>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetPersonAnimeInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetPersonAnimeQueryOptions = <TData = Awaited<ReturnType<typeof getPersonAnime>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPersonAnime>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPersonAnimeQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPersonAnime>>> = ({ signal }) => getPersonAnime(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPersonAnime>>, TError, TData> & { queryKey: QueryKey }
}

export type GetPersonAnimeQueryResult = NonNullable<Awaited<ReturnType<typeof getPersonAnime>>>
export type GetPersonAnimeQueryError = AxiosError<void>

export const useGetPersonAnime = <TData = Awaited<ReturnType<typeof getPersonAnime>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPersonAnime>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetPersonAnimeQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getPersonVoices = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PersonVoiceActingRoles>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/people/${id}/voices`,options
    );
  }


export const getGetPersonVoicesQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/people/${id}/voices`] as const;
    }

    
export const getGetPersonVoicesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getPersonVoices>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPersonVoices>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPersonVoicesQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPersonVoices>>> = ({ signal }) => getPersonVoices(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPersonVoices>>, TError, TData> & { queryKey: QueryKey }
}

export type GetPersonVoicesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getPersonVoices>>>
export type GetPersonVoicesInfiniteQueryError = AxiosError<void>

export const useGetPersonVoicesInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getPersonVoices>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPersonVoices>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetPersonVoicesInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetPersonVoicesQueryOptions = <TData = Awaited<ReturnType<typeof getPersonVoices>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPersonVoices>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPersonVoicesQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPersonVoices>>> = ({ signal }) => getPersonVoices(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPersonVoices>>, TError, TData> & { queryKey: QueryKey }
}

export type GetPersonVoicesQueryResult = NonNullable<Awaited<ReturnType<typeof getPersonVoices>>>
export type GetPersonVoicesQueryError = AxiosError<void>

export const useGetPersonVoices = <TData = Awaited<ReturnType<typeof getPersonVoices>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPersonVoices>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetPersonVoicesQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getPersonManga = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PersonManga>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/people/${id}/manga`,options
    );
  }


export const getGetPersonMangaQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/people/${id}/manga`] as const;
    }

    
export const getGetPersonMangaInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getPersonManga>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPersonManga>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPersonMangaQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPersonManga>>> = ({ signal }) => getPersonManga(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPersonManga>>, TError, TData> & { queryKey: QueryKey }
}

export type GetPersonMangaInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getPersonManga>>>
export type GetPersonMangaInfiniteQueryError = AxiosError<void>

export const useGetPersonMangaInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getPersonManga>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPersonManga>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetPersonMangaInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetPersonMangaQueryOptions = <TData = Awaited<ReturnType<typeof getPersonManga>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPersonManga>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPersonMangaQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPersonManga>>> = ({ signal }) => getPersonManga(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPersonManga>>, TError, TData> & { queryKey: QueryKey }
}

export type GetPersonMangaQueryResult = NonNullable<Awaited<ReturnType<typeof getPersonManga>>>
export type GetPersonMangaQueryError = AxiosError<void>

export const useGetPersonManga = <TData = Awaited<ReturnType<typeof getPersonManga>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPersonManga>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetPersonMangaQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getPersonPictures = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PersonPictures>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/people/${id}/pictures`,options
    );
  }


export const getGetPersonPicturesQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/people/${id}/pictures`] as const;
    }

    
export const getGetPersonPicturesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getPersonPictures>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPersonPictures>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPersonPicturesQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPersonPictures>>> = ({ signal }) => getPersonPictures(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPersonPictures>>, TError, TData> & { queryKey: QueryKey }
}

export type GetPersonPicturesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getPersonPictures>>>
export type GetPersonPicturesInfiniteQueryError = AxiosError<void>

export const useGetPersonPicturesInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getPersonPictures>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPersonPictures>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetPersonPicturesInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetPersonPicturesQueryOptions = <TData = Awaited<ReturnType<typeof getPersonPictures>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPersonPictures>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPersonPicturesQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPersonPictures>>> = ({ signal }) => getPersonPictures(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPersonPictures>>, TError, TData> & { queryKey: QueryKey }
}

export type GetPersonPicturesQueryResult = NonNullable<Awaited<ReturnType<typeof getPersonPictures>>>
export type GetPersonPicturesQueryError = AxiosError<void>

export const useGetPersonPictures = <TData = Awaited<ReturnType<typeof getPersonPictures>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPersonPictures>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetPersonPicturesQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getProducerById = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetProducerById200>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/producers/${id}`,options
    );
  }


export const getGetProducerByIdQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/producers/${id}`] as const;
    }

    
export const getGetProducerByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getProducerById>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProducerById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProducerByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProducerById>>> = ({ signal }) => getProducerById(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProducerById>>, TError, TData> & { queryKey: QueryKey }
}

export type GetProducerByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getProducerById>>>
export type GetProducerByIdInfiniteQueryError = AxiosError<void>

export const useGetProducerByIdInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getProducerById>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProducerById>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetProducerByIdInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetProducerByIdQueryOptions = <TData = Awaited<ReturnType<typeof getProducerById>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProducerById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProducerByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProducerById>>> = ({ signal }) => getProducerById(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProducerById>>, TError, TData> & { queryKey: QueryKey }
}

export type GetProducerByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getProducerById>>>
export type GetProducerByIdQueryError = AxiosError<void>

export const useGetProducerById = <TData = Awaited<ReturnType<typeof getProducerById>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProducerById>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetProducerByIdQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getProducerFullById = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetProducerFullById200>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/producers/${id}/full`,options
    );
  }


export const getGetProducerFullByIdQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/producers/${id}/full`] as const;
    }

    
export const getGetProducerFullByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getProducerFullById>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProducerFullById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProducerFullByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProducerFullById>>> = ({ signal }) => getProducerFullById(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProducerFullById>>, TError, TData> & { queryKey: QueryKey }
}

export type GetProducerFullByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getProducerFullById>>>
export type GetProducerFullByIdInfiniteQueryError = AxiosError<void>

export const useGetProducerFullByIdInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getProducerFullById>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProducerFullById>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetProducerFullByIdInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetProducerFullByIdQueryOptions = <TData = Awaited<ReturnType<typeof getProducerFullById>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProducerFullById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProducerFullByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProducerFullById>>> = ({ signal }) => getProducerFullById(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProducerFullById>>, TError, TData> & { queryKey: QueryKey }
}

export type GetProducerFullByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getProducerFullById>>>
export type GetProducerFullByIdQueryError = AxiosError<void>

export const useGetProducerFullById = <TData = Awaited<ReturnType<typeof getProducerFullById>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProducerFullById>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetProducerFullByIdQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getProducerExternal = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ExternalLinks>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/producers/${id}/external`,options
    );
  }


export const getGetProducerExternalQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/producers/${id}/external`] as const;
    }

    
export const getGetProducerExternalInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getProducerExternal>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProducerExternal>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProducerExternalQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProducerExternal>>> = ({ signal }) => getProducerExternal(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProducerExternal>>, TError, TData> & { queryKey: QueryKey }
}

export type GetProducerExternalInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getProducerExternal>>>
export type GetProducerExternalInfiniteQueryError = AxiosError<void>

export const useGetProducerExternalInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getProducerExternal>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProducerExternal>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetProducerExternalInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetProducerExternalQueryOptions = <TData = Awaited<ReturnType<typeof getProducerExternal>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProducerExternal>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProducerExternalQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProducerExternal>>> = ({ signal }) => getProducerExternal(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProducerExternal>>, TError, TData> & { queryKey: QueryKey }
}

export type GetProducerExternalQueryResult = NonNullable<Awaited<ReturnType<typeof getProducerExternal>>>
export type GetProducerExternalQueryError = AxiosError<void>

export const useGetProducerExternal = <TData = Awaited<ReturnType<typeof getProducerExternal>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProducerExternal>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetProducerExternalQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getRandomAnime = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetRandomAnime200>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/random/anime`,options
    );
  }


export const getGetRandomAnimeQueryKey = () => {
    return [`https://api.jikan.moe/v4/random/anime`] as const;
    }

    
export const getGetRandomAnimeInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRandomAnime>>>, TError = AxiosError<void>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRandomAnime>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRandomAnimeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRandomAnime>>> = ({ signal }) => getRandomAnime({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRandomAnime>>, TError, TData> & { queryKey: QueryKey }
}

export type GetRandomAnimeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRandomAnime>>>
export type GetRandomAnimeInfiniteQueryError = AxiosError<void>

export const useGetRandomAnimeInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getRandomAnime>>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRandomAnime>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRandomAnimeInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRandomAnimeQueryOptions = <TData = Awaited<ReturnType<typeof getRandomAnime>>, TError = AxiosError<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRandomAnime>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRandomAnimeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRandomAnime>>> = ({ signal }) => getRandomAnime({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRandomAnime>>, TError, TData> & { queryKey: QueryKey }
}

export type GetRandomAnimeQueryResult = NonNullable<Awaited<ReturnType<typeof getRandomAnime>>>
export type GetRandomAnimeQueryError = AxiosError<void>

export const useGetRandomAnime = <TData = Awaited<ReturnType<typeof getRandomAnime>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRandomAnime>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRandomAnimeQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getRandomManga = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetRandomManga200>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/random/manga`,options
    );
  }


export const getGetRandomMangaQueryKey = () => {
    return [`https://api.jikan.moe/v4/random/manga`] as const;
    }

    
export const getGetRandomMangaInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRandomManga>>>, TError = AxiosError<void>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRandomManga>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRandomMangaQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRandomManga>>> = ({ signal }) => getRandomManga({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRandomManga>>, TError, TData> & { queryKey: QueryKey }
}

export type GetRandomMangaInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRandomManga>>>
export type GetRandomMangaInfiniteQueryError = AxiosError<void>

export const useGetRandomMangaInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getRandomManga>>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRandomManga>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRandomMangaInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRandomMangaQueryOptions = <TData = Awaited<ReturnType<typeof getRandomManga>>, TError = AxiosError<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRandomManga>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRandomMangaQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRandomManga>>> = ({ signal }) => getRandomManga({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRandomManga>>, TError, TData> & { queryKey: QueryKey }
}

export type GetRandomMangaQueryResult = NonNullable<Awaited<ReturnType<typeof getRandomManga>>>
export type GetRandomMangaQueryError = AxiosError<void>

export const useGetRandomManga = <TData = Awaited<ReturnType<typeof getRandomManga>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRandomManga>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRandomMangaQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getRandomCharacters = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetRandomCharacters200>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/random/characters`,options
    );
  }


export const getGetRandomCharactersQueryKey = () => {
    return [`https://api.jikan.moe/v4/random/characters`] as const;
    }

    
export const getGetRandomCharactersInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRandomCharacters>>>, TError = AxiosError<void>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRandomCharacters>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRandomCharactersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRandomCharacters>>> = ({ signal }) => getRandomCharacters({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRandomCharacters>>, TError, TData> & { queryKey: QueryKey }
}

export type GetRandomCharactersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRandomCharacters>>>
export type GetRandomCharactersInfiniteQueryError = AxiosError<void>

export const useGetRandomCharactersInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getRandomCharacters>>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRandomCharacters>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRandomCharactersInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRandomCharactersQueryOptions = <TData = Awaited<ReturnType<typeof getRandomCharacters>>, TError = AxiosError<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRandomCharacters>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRandomCharactersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRandomCharacters>>> = ({ signal }) => getRandomCharacters({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRandomCharacters>>, TError, TData> & { queryKey: QueryKey }
}

export type GetRandomCharactersQueryResult = NonNullable<Awaited<ReturnType<typeof getRandomCharacters>>>
export type GetRandomCharactersQueryError = AxiosError<void>

export const useGetRandomCharacters = <TData = Awaited<ReturnType<typeof getRandomCharacters>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRandomCharacters>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRandomCharactersQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getRandomPeople = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetRandomPeople200>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/random/people`,options
    );
  }


export const getGetRandomPeopleQueryKey = () => {
    return [`https://api.jikan.moe/v4/random/people`] as const;
    }

    
export const getGetRandomPeopleInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRandomPeople>>>, TError = AxiosError<void>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRandomPeople>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRandomPeopleQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRandomPeople>>> = ({ signal }) => getRandomPeople({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRandomPeople>>, TError, TData> & { queryKey: QueryKey }
}

export type GetRandomPeopleInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRandomPeople>>>
export type GetRandomPeopleInfiniteQueryError = AxiosError<void>

export const useGetRandomPeopleInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getRandomPeople>>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRandomPeople>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRandomPeopleInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRandomPeopleQueryOptions = <TData = Awaited<ReturnType<typeof getRandomPeople>>, TError = AxiosError<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRandomPeople>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRandomPeopleQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRandomPeople>>> = ({ signal }) => getRandomPeople({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRandomPeople>>, TError, TData> & { queryKey: QueryKey }
}

export type GetRandomPeopleQueryResult = NonNullable<Awaited<ReturnType<typeof getRandomPeople>>>
export type GetRandomPeopleQueryError = AxiosError<void>

export const useGetRandomPeople = <TData = Awaited<ReturnType<typeof getRandomPeople>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRandomPeople>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRandomPeopleQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getRandomUsers = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetRandomUsers200>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/random/users`,options
    );
  }


export const getGetRandomUsersQueryKey = () => {
    return [`https://api.jikan.moe/v4/random/users`] as const;
    }

    
export const getGetRandomUsersInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRandomUsers>>>, TError = AxiosError<void>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRandomUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRandomUsersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRandomUsers>>> = ({ signal }) => getRandomUsers({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRandomUsers>>, TError, TData> & { queryKey: QueryKey }
}

export type GetRandomUsersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRandomUsers>>>
export type GetRandomUsersInfiniteQueryError = AxiosError<void>

export const useGetRandomUsersInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getRandomUsers>>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRandomUsers>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRandomUsersInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRandomUsersQueryOptions = <TData = Awaited<ReturnType<typeof getRandomUsers>>, TError = AxiosError<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRandomUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRandomUsersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRandomUsers>>> = ({ signal }) => getRandomUsers({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRandomUsers>>, TError, TData> & { queryKey: QueryKey }
}

export type GetRandomUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getRandomUsers>>>
export type GetRandomUsersQueryError = AxiosError<void>

export const useGetRandomUsers = <TData = Awaited<ReturnType<typeof getRandomUsers>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRandomUsers>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRandomUsersQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getRecentAnimeRecommendations = (
    params?: GetRecentAnimeRecommendationsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Recommendations>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/recommendations/anime`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetRecentAnimeRecommendationsQueryKey = (params?: GetRecentAnimeRecommendationsParams,) => {
    return [`https://api.jikan.moe/v4/recommendations/anime`, ...(params ? [params]: [])] as const;
    }

    
export const getGetRecentAnimeRecommendationsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRecentAnimeRecommendations>>, GetRecentAnimeRecommendationsParams['page']>, TError = AxiosError<void>>(params?: GetRecentAnimeRecommendationsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecentAnimeRecommendations>>, TError, TData, Awaited<ReturnType<typeof getRecentAnimeRecommendations>>, QueryKey, GetRecentAnimeRecommendationsParams['page']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecentAnimeRecommendationsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecentAnimeRecommendations>>, QueryKey, GetRecentAnimeRecommendationsParams['page']> = ({ signal, pageParam }) => getRecentAnimeRecommendations({...params, page: pageParam || params?.['page']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecentAnimeRecommendations>>, TError, TData, Awaited<ReturnType<typeof getRecentAnimeRecommendations>>, QueryKey, GetRecentAnimeRecommendationsParams['page']> & { queryKey: QueryKey }
}

export type GetRecentAnimeRecommendationsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRecentAnimeRecommendations>>>
export type GetRecentAnimeRecommendationsInfiniteQueryError = AxiosError<void>

export const useGetRecentAnimeRecommendationsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getRecentAnimeRecommendations>>, GetRecentAnimeRecommendationsParams['page']>, TError = AxiosError<void>>(
 params?: GetRecentAnimeRecommendationsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecentAnimeRecommendations>>, TError, TData, Awaited<ReturnType<typeof getRecentAnimeRecommendations>>, QueryKey, GetRecentAnimeRecommendationsParams['page']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRecentAnimeRecommendationsInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRecentAnimeRecommendationsQueryOptions = <TData = Awaited<ReturnType<typeof getRecentAnimeRecommendations>>, TError = AxiosError<void>>(params?: GetRecentAnimeRecommendationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentAnimeRecommendations>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecentAnimeRecommendationsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecentAnimeRecommendations>>> = ({ signal }) => getRecentAnimeRecommendations(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRecentAnimeRecommendations>>, TError, TData> & { queryKey: QueryKey }
}

export type GetRecentAnimeRecommendationsQueryResult = NonNullable<Awaited<ReturnType<typeof getRecentAnimeRecommendations>>>
export type GetRecentAnimeRecommendationsQueryError = AxiosError<void>

export const useGetRecentAnimeRecommendations = <TData = Awaited<ReturnType<typeof getRecentAnimeRecommendations>>, TError = AxiosError<void>>(
 params?: GetRecentAnimeRecommendationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentAnimeRecommendations>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRecentAnimeRecommendationsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getRecentMangaRecommendations = (
    params?: GetRecentMangaRecommendationsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Recommendations>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/recommendations/manga`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetRecentMangaRecommendationsQueryKey = (params?: GetRecentMangaRecommendationsParams,) => {
    return [`https://api.jikan.moe/v4/recommendations/manga`, ...(params ? [params]: [])] as const;
    }

    
export const getGetRecentMangaRecommendationsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRecentMangaRecommendations>>, GetRecentMangaRecommendationsParams['page']>, TError = AxiosError<void>>(params?: GetRecentMangaRecommendationsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecentMangaRecommendations>>, TError, TData, Awaited<ReturnType<typeof getRecentMangaRecommendations>>, QueryKey, GetRecentMangaRecommendationsParams['page']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecentMangaRecommendationsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecentMangaRecommendations>>, QueryKey, GetRecentMangaRecommendationsParams['page']> = ({ signal, pageParam }) => getRecentMangaRecommendations({...params, page: pageParam || params?.['page']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecentMangaRecommendations>>, TError, TData, Awaited<ReturnType<typeof getRecentMangaRecommendations>>, QueryKey, GetRecentMangaRecommendationsParams['page']> & { queryKey: QueryKey }
}

export type GetRecentMangaRecommendationsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRecentMangaRecommendations>>>
export type GetRecentMangaRecommendationsInfiniteQueryError = AxiosError<void>

export const useGetRecentMangaRecommendationsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getRecentMangaRecommendations>>, GetRecentMangaRecommendationsParams['page']>, TError = AxiosError<void>>(
 params?: GetRecentMangaRecommendationsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecentMangaRecommendations>>, TError, TData, Awaited<ReturnType<typeof getRecentMangaRecommendations>>, QueryKey, GetRecentMangaRecommendationsParams['page']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRecentMangaRecommendationsInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRecentMangaRecommendationsQueryOptions = <TData = Awaited<ReturnType<typeof getRecentMangaRecommendations>>, TError = AxiosError<void>>(params?: GetRecentMangaRecommendationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentMangaRecommendations>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecentMangaRecommendationsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecentMangaRecommendations>>> = ({ signal }) => getRecentMangaRecommendations(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRecentMangaRecommendations>>, TError, TData> & { queryKey: QueryKey }
}

export type GetRecentMangaRecommendationsQueryResult = NonNullable<Awaited<ReturnType<typeof getRecentMangaRecommendations>>>
export type GetRecentMangaRecommendationsQueryError = AxiosError<void>

export const useGetRecentMangaRecommendations = <TData = Awaited<ReturnType<typeof getRecentMangaRecommendations>>, TError = AxiosError<void>>(
 params?: GetRecentMangaRecommendationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentMangaRecommendations>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRecentMangaRecommendationsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getRecentAnimeReviews = (
    params?: GetRecentAnimeReviewsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/reviews/anime`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetRecentAnimeReviewsQueryKey = (params?: GetRecentAnimeReviewsParams,) => {
    return [`https://api.jikan.moe/v4/reviews/anime`, ...(params ? [params]: [])] as const;
    }

    
export const getGetRecentAnimeReviewsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRecentAnimeReviews>>, GetRecentAnimeReviewsParams['page']>, TError = AxiosError<void>>(params?: GetRecentAnimeReviewsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecentAnimeReviews>>, TError, TData, Awaited<ReturnType<typeof getRecentAnimeReviews>>, QueryKey, GetRecentAnimeReviewsParams['page']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecentAnimeReviewsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecentAnimeReviews>>, QueryKey, GetRecentAnimeReviewsParams['page']> = ({ signal, pageParam }) => getRecentAnimeReviews({...params, page: pageParam || params?.['page']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecentAnimeReviews>>, TError, TData, Awaited<ReturnType<typeof getRecentAnimeReviews>>, QueryKey, GetRecentAnimeReviewsParams['page']> & { queryKey: QueryKey }
}

export type GetRecentAnimeReviewsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRecentAnimeReviews>>>
export type GetRecentAnimeReviewsInfiniteQueryError = AxiosError<void>

export const useGetRecentAnimeReviewsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getRecentAnimeReviews>>, GetRecentAnimeReviewsParams['page']>, TError = AxiosError<void>>(
 params?: GetRecentAnimeReviewsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecentAnimeReviews>>, TError, TData, Awaited<ReturnType<typeof getRecentAnimeReviews>>, QueryKey, GetRecentAnimeReviewsParams['page']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRecentAnimeReviewsInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRecentAnimeReviewsQueryOptions = <TData = Awaited<ReturnType<typeof getRecentAnimeReviews>>, TError = AxiosError<void>>(params?: GetRecentAnimeReviewsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentAnimeReviews>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecentAnimeReviewsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecentAnimeReviews>>> = ({ signal }) => getRecentAnimeReviews(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRecentAnimeReviews>>, TError, TData> & { queryKey: QueryKey }
}

export type GetRecentAnimeReviewsQueryResult = NonNullable<Awaited<ReturnType<typeof getRecentAnimeReviews>>>
export type GetRecentAnimeReviewsQueryError = AxiosError<void>

export const useGetRecentAnimeReviews = <TData = Awaited<ReturnType<typeof getRecentAnimeReviews>>, TError = AxiosError<void>>(
 params?: GetRecentAnimeReviewsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentAnimeReviews>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRecentAnimeReviewsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getRecentMangaReviews = (
    params?: GetRecentMangaReviewsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/reviews/manga`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetRecentMangaReviewsQueryKey = (params?: GetRecentMangaReviewsParams,) => {
    return [`https://api.jikan.moe/v4/reviews/manga`, ...(params ? [params]: [])] as const;
    }

    
export const getGetRecentMangaReviewsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRecentMangaReviews>>, GetRecentMangaReviewsParams['page']>, TError = AxiosError<void>>(params?: GetRecentMangaReviewsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecentMangaReviews>>, TError, TData, Awaited<ReturnType<typeof getRecentMangaReviews>>, QueryKey, GetRecentMangaReviewsParams['page']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecentMangaReviewsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecentMangaReviews>>, QueryKey, GetRecentMangaReviewsParams['page']> = ({ signal, pageParam }) => getRecentMangaReviews({...params, page: pageParam || params?.['page']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecentMangaReviews>>, TError, TData, Awaited<ReturnType<typeof getRecentMangaReviews>>, QueryKey, GetRecentMangaReviewsParams['page']> & { queryKey: QueryKey }
}

export type GetRecentMangaReviewsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRecentMangaReviews>>>
export type GetRecentMangaReviewsInfiniteQueryError = AxiosError<void>

export const useGetRecentMangaReviewsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getRecentMangaReviews>>, GetRecentMangaReviewsParams['page']>, TError = AxiosError<void>>(
 params?: GetRecentMangaReviewsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecentMangaReviews>>, TError, TData, Awaited<ReturnType<typeof getRecentMangaReviews>>, QueryKey, GetRecentMangaReviewsParams['page']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRecentMangaReviewsInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRecentMangaReviewsQueryOptions = <TData = Awaited<ReturnType<typeof getRecentMangaReviews>>, TError = AxiosError<void>>(params?: GetRecentMangaReviewsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentMangaReviews>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecentMangaReviewsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecentMangaReviews>>> = ({ signal }) => getRecentMangaReviews(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRecentMangaReviews>>, TError, TData> & { queryKey: QueryKey }
}

export type GetRecentMangaReviewsQueryResult = NonNullable<Awaited<ReturnType<typeof getRecentMangaReviews>>>
export type GetRecentMangaReviewsQueryError = AxiosError<void>

export const useGetRecentMangaReviews = <TData = Awaited<ReturnType<typeof getRecentMangaReviews>>, TError = AxiosError<void>>(
 params?: GetRecentMangaReviewsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentMangaReviews>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRecentMangaReviewsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getSchedules = (
    params?: GetSchedulesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Schedules>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/schedules`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetSchedulesQueryKey = (params?: GetSchedulesParams,) => {
    return [`https://api.jikan.moe/v4/schedules`, ...(params ? [params]: [])] as const;
    }

    
export const getGetSchedulesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSchedules>>, GetSchedulesParams['page']>, TError = AxiosError<void>>(params?: GetSchedulesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSchedules>>, TError, TData, Awaited<ReturnType<typeof getSchedules>>, QueryKey, GetSchedulesParams['page']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSchedulesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSchedules>>, QueryKey, GetSchedulesParams['page']> = ({ signal, pageParam }) => getSchedules({...params, page: pageParam || params?.['page']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSchedules>>, TError, TData, Awaited<ReturnType<typeof getSchedules>>, QueryKey, GetSchedulesParams['page']> & { queryKey: QueryKey }
}

export type GetSchedulesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSchedules>>>
export type GetSchedulesInfiniteQueryError = AxiosError<void>

export const useGetSchedulesInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getSchedules>>, GetSchedulesParams['page']>, TError = AxiosError<void>>(
 params?: GetSchedulesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSchedules>>, TError, TData, Awaited<ReturnType<typeof getSchedules>>, QueryKey, GetSchedulesParams['page']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSchedulesInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSchedulesQueryOptions = <TData = Awaited<ReturnType<typeof getSchedules>>, TError = AxiosError<void>>(params?: GetSchedulesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSchedules>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSchedulesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSchedules>>> = ({ signal }) => getSchedules(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSchedules>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSchedulesQueryResult = NonNullable<Awaited<ReturnType<typeof getSchedules>>>
export type GetSchedulesQueryError = AxiosError<void>

export const useGetSchedules = <TData = Awaited<ReturnType<typeof getSchedules>>, TError = AxiosError<void>>(
 params?: GetSchedulesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSchedules>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSchedulesQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAnimeSearch = (
    params?: GetAnimeSearchParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AnimeSearch>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/anime`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetAnimeSearchQueryKey = (params?: GetAnimeSearchParams,) => {
    return [`https://api.jikan.moe/v4/anime`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAnimeSearchInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimeSearch>>, GetAnimeSearchParams['page']>, TError = AxiosError<void>>(params?: GetAnimeSearchParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeSearch>>, TError, TData, Awaited<ReturnType<typeof getAnimeSearch>>, QueryKey, GetAnimeSearchParams['page']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimeSearchQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimeSearch>>, QueryKey, GetAnimeSearchParams['page']> = ({ signal, pageParam }) => getAnimeSearch({...params, page: pageParam || params?.['page']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeSearch>>, TError, TData, Awaited<ReturnType<typeof getAnimeSearch>>, QueryKey, GetAnimeSearchParams['page']> & { queryKey: QueryKey }
}

export type GetAnimeSearchInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimeSearch>>>
export type GetAnimeSearchInfiniteQueryError = AxiosError<void>

export const useGetAnimeSearchInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getAnimeSearch>>, GetAnimeSearchParams['page']>, TError = AxiosError<void>>(
 params?: GetAnimeSearchParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAnimeSearch>>, TError, TData, Awaited<ReturnType<typeof getAnimeSearch>>, QueryKey, GetAnimeSearchParams['page']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimeSearchInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAnimeSearchQueryOptions = <TData = Awaited<ReturnType<typeof getAnimeSearch>>, TError = AxiosError<void>>(params?: GetAnimeSearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimeSearch>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimeSearchQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimeSearch>>> = ({ signal }) => getAnimeSearch(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAnimeSearch>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAnimeSearchQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimeSearch>>>
export type GetAnimeSearchQueryError = AxiosError<void>

export const useGetAnimeSearch = <TData = Awaited<ReturnType<typeof getAnimeSearch>>, TError = AxiosError<void>>(
 params?: GetAnimeSearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimeSearch>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnimeSearchQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getMangaSearch = (
    params?: GetMangaSearchParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MangaSearch>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/manga`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetMangaSearchQueryKey = (params?: GetMangaSearchParams,) => {
    return [`https://api.jikan.moe/v4/manga`, ...(params ? [params]: [])] as const;
    }

    
export const getGetMangaSearchInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getMangaSearch>>, GetMangaSearchParams['page']>, TError = AxiosError<void>>(params?: GetMangaSearchParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMangaSearch>>, TError, TData, Awaited<ReturnType<typeof getMangaSearch>>, QueryKey, GetMangaSearchParams['page']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMangaSearchQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMangaSearch>>, QueryKey, GetMangaSearchParams['page']> = ({ signal, pageParam }) => getMangaSearch({...params, page: pageParam || params?.['page']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMangaSearch>>, TError, TData, Awaited<ReturnType<typeof getMangaSearch>>, QueryKey, GetMangaSearchParams['page']> & { queryKey: QueryKey }
}

export type GetMangaSearchInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMangaSearch>>>
export type GetMangaSearchInfiniteQueryError = AxiosError<void>

export const useGetMangaSearchInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getMangaSearch>>, GetMangaSearchParams['page']>, TError = AxiosError<void>>(
 params?: GetMangaSearchParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMangaSearch>>, TError, TData, Awaited<ReturnType<typeof getMangaSearch>>, QueryKey, GetMangaSearchParams['page']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMangaSearchInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetMangaSearchQueryOptions = <TData = Awaited<ReturnType<typeof getMangaSearch>>, TError = AxiosError<void>>(params?: GetMangaSearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaSearch>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMangaSearchQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMangaSearch>>> = ({ signal }) => getMangaSearch(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMangaSearch>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMangaSearchQueryResult = NonNullable<Awaited<ReturnType<typeof getMangaSearch>>>
export type GetMangaSearchQueryError = AxiosError<void>

export const useGetMangaSearch = <TData = Awaited<ReturnType<typeof getMangaSearch>>, TError = AxiosError<void>>(
 params?: GetMangaSearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMangaSearch>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMangaSearchQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getPeopleSearch = (
    params?: GetPeopleSearchParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PeopleSearch>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/people`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetPeopleSearchQueryKey = (params?: GetPeopleSearchParams,) => {
    return [`https://api.jikan.moe/v4/people`, ...(params ? [params]: [])] as const;
    }

    
export const getGetPeopleSearchInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getPeopleSearch>>, GetPeopleSearchParams['page']>, TError = AxiosError<void>>(params?: GetPeopleSearchParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPeopleSearch>>, TError, TData, Awaited<ReturnType<typeof getPeopleSearch>>, QueryKey, GetPeopleSearchParams['page']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPeopleSearchQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPeopleSearch>>, QueryKey, GetPeopleSearchParams['page']> = ({ signal, pageParam }) => getPeopleSearch({...params, page: pageParam || params?.['page']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPeopleSearch>>, TError, TData, Awaited<ReturnType<typeof getPeopleSearch>>, QueryKey, GetPeopleSearchParams['page']> & { queryKey: QueryKey }
}

export type GetPeopleSearchInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getPeopleSearch>>>
export type GetPeopleSearchInfiniteQueryError = AxiosError<void>

export const useGetPeopleSearchInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getPeopleSearch>>, GetPeopleSearchParams['page']>, TError = AxiosError<void>>(
 params?: GetPeopleSearchParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPeopleSearch>>, TError, TData, Awaited<ReturnType<typeof getPeopleSearch>>, QueryKey, GetPeopleSearchParams['page']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetPeopleSearchInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetPeopleSearchQueryOptions = <TData = Awaited<ReturnType<typeof getPeopleSearch>>, TError = AxiosError<void>>(params?: GetPeopleSearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPeopleSearch>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPeopleSearchQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPeopleSearch>>> = ({ signal }) => getPeopleSearch(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPeopleSearch>>, TError, TData> & { queryKey: QueryKey }
}

export type GetPeopleSearchQueryResult = NonNullable<Awaited<ReturnType<typeof getPeopleSearch>>>
export type GetPeopleSearchQueryError = AxiosError<void>

export const useGetPeopleSearch = <TData = Awaited<ReturnType<typeof getPeopleSearch>>, TError = AxiosError<void>>(
 params?: GetPeopleSearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPeopleSearch>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetPeopleSearchQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getCharactersSearch = (
    params?: GetCharactersSearchParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CharactersSearch>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/characters`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetCharactersSearchQueryKey = (params?: GetCharactersSearchParams,) => {
    return [`https://api.jikan.moe/v4/characters`, ...(params ? [params]: [])] as const;
    }

    
export const getGetCharactersSearchInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCharactersSearch>>, GetCharactersSearchParams['page']>, TError = AxiosError<void>>(params?: GetCharactersSearchParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCharactersSearch>>, TError, TData, Awaited<ReturnType<typeof getCharactersSearch>>, QueryKey, GetCharactersSearchParams['page']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCharactersSearchQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCharactersSearch>>, QueryKey, GetCharactersSearchParams['page']> = ({ signal, pageParam }) => getCharactersSearch({...params, page: pageParam || params?.['page']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCharactersSearch>>, TError, TData, Awaited<ReturnType<typeof getCharactersSearch>>, QueryKey, GetCharactersSearchParams['page']> & { queryKey: QueryKey }
}

export type GetCharactersSearchInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCharactersSearch>>>
export type GetCharactersSearchInfiniteQueryError = AxiosError<void>

export const useGetCharactersSearchInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getCharactersSearch>>, GetCharactersSearchParams['page']>, TError = AxiosError<void>>(
 params?: GetCharactersSearchParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCharactersSearch>>, TError, TData, Awaited<ReturnType<typeof getCharactersSearch>>, QueryKey, GetCharactersSearchParams['page']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetCharactersSearchInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCharactersSearchQueryOptions = <TData = Awaited<ReturnType<typeof getCharactersSearch>>, TError = AxiosError<void>>(params?: GetCharactersSearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCharactersSearch>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCharactersSearchQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCharactersSearch>>> = ({ signal }) => getCharactersSearch(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCharactersSearch>>, TError, TData> & { queryKey: QueryKey }
}

export type GetCharactersSearchQueryResult = NonNullable<Awaited<ReturnType<typeof getCharactersSearch>>>
export type GetCharactersSearchQueryError = AxiosError<void>

export const useGetCharactersSearch = <TData = Awaited<ReturnType<typeof getCharactersSearch>>, TError = AxiosError<void>>(
 params?: GetCharactersSearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCharactersSearch>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetCharactersSearchQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getUsersSearch = (
    params?: GetUsersSearchParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UsersSearch>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/users`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetUsersSearchQueryKey = (params?: GetUsersSearchParams,) => {
    return [`https://api.jikan.moe/v4/users`, ...(params ? [params]: [])] as const;
    }

    
export const getGetUsersSearchInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getUsersSearch>>, GetUsersSearchParams['page']>, TError = AxiosError<void>>(params?: GetUsersSearchParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUsersSearch>>, TError, TData, Awaited<ReturnType<typeof getUsersSearch>>, QueryKey, GetUsersSearchParams['page']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersSearchQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersSearch>>, QueryKey, GetUsersSearchParams['page']> = ({ signal, pageParam }) => getUsersSearch({...params, page: pageParam || params?.['page']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUsersSearch>>, TError, TData, Awaited<ReturnType<typeof getUsersSearch>>, QueryKey, GetUsersSearchParams['page']> & { queryKey: QueryKey }
}

export type GetUsersSearchInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getUsersSearch>>>
export type GetUsersSearchInfiniteQueryError = AxiosError<void>

export const useGetUsersSearchInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getUsersSearch>>, GetUsersSearchParams['page']>, TError = AxiosError<void>>(
 params?: GetUsersSearchParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUsersSearch>>, TError, TData, Awaited<ReturnType<typeof getUsersSearch>>, QueryKey, GetUsersSearchParams['page']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUsersSearchInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetUsersSearchQueryOptions = <TData = Awaited<ReturnType<typeof getUsersSearch>>, TError = AxiosError<void>>(params?: GetUsersSearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersSearch>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersSearchQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersSearch>>> = ({ signal }) => getUsersSearch(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUsersSearch>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUsersSearchQueryResult = NonNullable<Awaited<ReturnType<typeof getUsersSearch>>>
export type GetUsersSearchQueryError = AxiosError<void>

export const useGetUsersSearch = <TData = Awaited<ReturnType<typeof getUsersSearch>>, TError = AxiosError<void>>(
 params?: GetUsersSearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersSearch>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUsersSearchQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getUserById = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetUserById200>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/users/userbyid/${id}`,options
    );
  }


export const getGetUserByIdQueryKey = (id: number,) => {
    return [`https://api.jikan.moe/v4/users/userbyid/${id}`] as const;
    }

    
export const getGetUserByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getUserById>>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserById>>> = ({ signal }) => getUserById(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getUserById>>>
export type GetUserByIdInfiniteQueryError = AxiosError<void>

export const useGetUserByIdInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getUserById>>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserByIdInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetUserByIdQueryOptions = <TData = Awaited<ReturnType<typeof getUserById>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserById>>> = ({ signal }) => getUserById(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getUserById>>>
export type GetUserByIdQueryError = AxiosError<void>

export const useGetUserById = <TData = Awaited<ReturnType<typeof getUserById>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserByIdQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getClubsSearch = (
    params?: GetClubsSearchParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ClubsSearch>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/clubs`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetClubsSearchQueryKey = (params?: GetClubsSearchParams,) => {
    return [`https://api.jikan.moe/v4/clubs`, ...(params ? [params]: [])] as const;
    }

    
export const getGetClubsSearchInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getClubsSearch>>, GetClubsSearchParams['page']>, TError = AxiosError<void>>(params?: GetClubsSearchParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getClubsSearch>>, TError, TData, Awaited<ReturnType<typeof getClubsSearch>>, QueryKey, GetClubsSearchParams['page']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetClubsSearchQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getClubsSearch>>, QueryKey, GetClubsSearchParams['page']> = ({ signal, pageParam }) => getClubsSearch({...params, page: pageParam || params?.['page']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getClubsSearch>>, TError, TData, Awaited<ReturnType<typeof getClubsSearch>>, QueryKey, GetClubsSearchParams['page']> & { queryKey: QueryKey }
}

export type GetClubsSearchInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getClubsSearch>>>
export type GetClubsSearchInfiniteQueryError = AxiosError<void>

export const useGetClubsSearchInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getClubsSearch>>, GetClubsSearchParams['page']>, TError = AxiosError<void>>(
 params?: GetClubsSearchParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getClubsSearch>>, TError, TData, Awaited<ReturnType<typeof getClubsSearch>>, QueryKey, GetClubsSearchParams['page']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetClubsSearchInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetClubsSearchQueryOptions = <TData = Awaited<ReturnType<typeof getClubsSearch>>, TError = AxiosError<void>>(params?: GetClubsSearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClubsSearch>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetClubsSearchQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getClubsSearch>>> = ({ signal }) => getClubsSearch(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getClubsSearch>>, TError, TData> & { queryKey: QueryKey }
}

export type GetClubsSearchQueryResult = NonNullable<Awaited<ReturnType<typeof getClubsSearch>>>
export type GetClubsSearchQueryError = AxiosError<void>

export const useGetClubsSearch = <TData = Awaited<ReturnType<typeof getClubsSearch>>, TError = AxiosError<void>>(
 params?: GetClubsSearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClubsSearch>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetClubsSearchQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getProducers = (
    params?: GetProducersParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Producers>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/producers`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetProducersQueryKey = (params?: GetProducersParams,) => {
    return [`https://api.jikan.moe/v4/producers`, ...(params ? [params]: [])] as const;
    }

    
export const getGetProducersInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getProducers>>, GetProducersParams['page']>, TError = AxiosError<void>>(params?: GetProducersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProducers>>, TError, TData, Awaited<ReturnType<typeof getProducers>>, QueryKey, GetProducersParams['page']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProducersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProducers>>, QueryKey, GetProducersParams['page']> = ({ signal, pageParam }) => getProducers({...params, page: pageParam || params?.['page']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProducers>>, TError, TData, Awaited<ReturnType<typeof getProducers>>, QueryKey, GetProducersParams['page']> & { queryKey: QueryKey }
}

export type GetProducersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getProducers>>>
export type GetProducersInfiniteQueryError = AxiosError<void>

export const useGetProducersInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getProducers>>, GetProducersParams['page']>, TError = AxiosError<void>>(
 params?: GetProducersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProducers>>, TError, TData, Awaited<ReturnType<typeof getProducers>>, QueryKey, GetProducersParams['page']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetProducersInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetProducersQueryOptions = <TData = Awaited<ReturnType<typeof getProducers>>, TError = AxiosError<void>>(params?: GetProducersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProducers>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProducersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProducers>>> = ({ signal }) => getProducers(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProducers>>, TError, TData> & { queryKey: QueryKey }
}

export type GetProducersQueryResult = NonNullable<Awaited<ReturnType<typeof getProducers>>>
export type GetProducersQueryError = AxiosError<void>

export const useGetProducers = <TData = Awaited<ReturnType<typeof getProducers>>, TError = AxiosError<void>>(
 params?: GetProducersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProducers>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetProducersQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getSeasonNow = (
    params?: GetSeasonNowParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AnimeSearch>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/seasons/now`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetSeasonNowQueryKey = (params?: GetSeasonNowParams,) => {
    return [`https://api.jikan.moe/v4/seasons/now`, ...(params ? [params]: [])] as const;
    }

    
export const getGetSeasonNowInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSeasonNow>>, GetSeasonNowParams['page']>, TError = AxiosError<void>>(params?: GetSeasonNowParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSeasonNow>>, TError, TData, Awaited<ReturnType<typeof getSeasonNow>>, QueryKey, GetSeasonNowParams['page']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSeasonNowQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSeasonNow>>, QueryKey, GetSeasonNowParams['page']> = ({ signal, pageParam }) => getSeasonNow({...params, page: pageParam || params?.['page']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSeasonNow>>, TError, TData, Awaited<ReturnType<typeof getSeasonNow>>, QueryKey, GetSeasonNowParams['page']> & { queryKey: QueryKey }
}

export type GetSeasonNowInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSeasonNow>>>
export type GetSeasonNowInfiniteQueryError = AxiosError<void>

export const useGetSeasonNowInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getSeasonNow>>, GetSeasonNowParams['page']>, TError = AxiosError<void>>(
 params?: GetSeasonNowParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSeasonNow>>, TError, TData, Awaited<ReturnType<typeof getSeasonNow>>, QueryKey, GetSeasonNowParams['page']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSeasonNowInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSeasonNowQueryOptions = <TData = Awaited<ReturnType<typeof getSeasonNow>>, TError = AxiosError<void>>(params?: GetSeasonNowParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSeasonNow>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSeasonNowQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSeasonNow>>> = ({ signal }) => getSeasonNow(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSeasonNow>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSeasonNowQueryResult = NonNullable<Awaited<ReturnType<typeof getSeasonNow>>>
export type GetSeasonNowQueryError = AxiosError<void>

export const useGetSeasonNow = <TData = Awaited<ReturnType<typeof getSeasonNow>>, TError = AxiosError<void>>(
 params?: GetSeasonNowParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSeasonNow>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSeasonNowQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getSeason = (
    year: number,
    season: string,
    params?: GetSeasonParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AnimeSearch>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/seasons/${year}/${season}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetSeasonQueryKey = (year: number,
    season: string,
    params?: GetSeasonParams,) => {
    return [`https://api.jikan.moe/v4/seasons/${year}/${season}`, ...(params ? [params]: [])] as const;
    }

    
export const getGetSeasonInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSeason>>, GetSeasonParams['page']>, TError = AxiosError<void>>(year: number,
    season: string,
    params?: GetSeasonParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSeason>>, TError, TData, Awaited<ReturnType<typeof getSeason>>, QueryKey, GetSeasonParams['page']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSeasonQueryKey(year,season,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSeason>>, QueryKey, GetSeasonParams['page']> = ({ signal, pageParam }) => getSeason(year,season,{...params, page: pageParam || params?.['page']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(year && season),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSeason>>, TError, TData, Awaited<ReturnType<typeof getSeason>>, QueryKey, GetSeasonParams['page']> & { queryKey: QueryKey }
}

export type GetSeasonInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSeason>>>
export type GetSeasonInfiniteQueryError = AxiosError<void>

export const useGetSeasonInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getSeason>>, GetSeasonParams['page']>, TError = AxiosError<void>>(
 year: number,
    season: string,
    params?: GetSeasonParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSeason>>, TError, TData, Awaited<ReturnType<typeof getSeason>>, QueryKey, GetSeasonParams['page']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSeasonInfiniteQueryOptions(year,season,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSeasonQueryOptions = <TData = Awaited<ReturnType<typeof getSeason>>, TError = AxiosError<void>>(year: number,
    season: string,
    params?: GetSeasonParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSeason>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSeasonQueryKey(year,season,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSeason>>> = ({ signal }) => getSeason(year,season,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(year && season),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSeason>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSeasonQueryResult = NonNullable<Awaited<ReturnType<typeof getSeason>>>
export type GetSeasonQueryError = AxiosError<void>

export const useGetSeason = <TData = Awaited<ReturnType<typeof getSeason>>, TError = AxiosError<void>>(
 year: number,
    season: string,
    params?: GetSeasonParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSeason>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSeasonQueryOptions(year,season,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getSeasonsList = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Seasons>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/seasons`,options
    );
  }


export const getGetSeasonsListQueryKey = () => {
    return [`https://api.jikan.moe/v4/seasons`] as const;
    }

    
export const getGetSeasonsListInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSeasonsList>>>, TError = AxiosError<void>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSeasonsList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSeasonsListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSeasonsList>>> = ({ signal }) => getSeasonsList({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSeasonsList>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSeasonsListInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSeasonsList>>>
export type GetSeasonsListInfiniteQueryError = AxiosError<void>

export const useGetSeasonsListInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getSeasonsList>>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSeasonsList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSeasonsListInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSeasonsListQueryOptions = <TData = Awaited<ReturnType<typeof getSeasonsList>>, TError = AxiosError<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSeasonsList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSeasonsListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSeasonsList>>> = ({ signal }) => getSeasonsList({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSeasonsList>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSeasonsListQueryResult = NonNullable<Awaited<ReturnType<typeof getSeasonsList>>>
export type GetSeasonsListQueryError = AxiosError<void>

export const useGetSeasonsList = <TData = Awaited<ReturnType<typeof getSeasonsList>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSeasonsList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSeasonsListQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getSeasonUpcoming = (
    params?: GetSeasonUpcomingParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AnimeSearch>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/seasons/upcoming`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetSeasonUpcomingQueryKey = (params?: GetSeasonUpcomingParams,) => {
    return [`https://api.jikan.moe/v4/seasons/upcoming`, ...(params ? [params]: [])] as const;
    }

    
export const getGetSeasonUpcomingInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSeasonUpcoming>>, GetSeasonUpcomingParams['page']>, TError = AxiosError<void>>(params?: GetSeasonUpcomingParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSeasonUpcoming>>, TError, TData, Awaited<ReturnType<typeof getSeasonUpcoming>>, QueryKey, GetSeasonUpcomingParams['page']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSeasonUpcomingQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSeasonUpcoming>>, QueryKey, GetSeasonUpcomingParams['page']> = ({ signal, pageParam }) => getSeasonUpcoming({...params, page: pageParam || params?.['page']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSeasonUpcoming>>, TError, TData, Awaited<ReturnType<typeof getSeasonUpcoming>>, QueryKey, GetSeasonUpcomingParams['page']> & { queryKey: QueryKey }
}

export type GetSeasonUpcomingInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSeasonUpcoming>>>
export type GetSeasonUpcomingInfiniteQueryError = AxiosError<void>

export const useGetSeasonUpcomingInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getSeasonUpcoming>>, GetSeasonUpcomingParams['page']>, TError = AxiosError<void>>(
 params?: GetSeasonUpcomingParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSeasonUpcoming>>, TError, TData, Awaited<ReturnType<typeof getSeasonUpcoming>>, QueryKey, GetSeasonUpcomingParams['page']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSeasonUpcomingInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSeasonUpcomingQueryOptions = <TData = Awaited<ReturnType<typeof getSeasonUpcoming>>, TError = AxiosError<void>>(params?: GetSeasonUpcomingParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSeasonUpcoming>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSeasonUpcomingQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSeasonUpcoming>>> = ({ signal }) => getSeasonUpcoming(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSeasonUpcoming>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSeasonUpcomingQueryResult = NonNullable<Awaited<ReturnType<typeof getSeasonUpcoming>>>
export type GetSeasonUpcomingQueryError = AxiosError<void>

export const useGetSeasonUpcoming = <TData = Awaited<ReturnType<typeof getSeasonUpcoming>>, TError = AxiosError<void>>(
 params?: GetSeasonUpcomingParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSeasonUpcoming>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSeasonUpcomingQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getTopAnime = (
    params?: GetTopAnimeParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AnimeSearch>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/top/anime`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetTopAnimeQueryKey = (params?: GetTopAnimeParams,) => {
    return [`https://api.jikan.moe/v4/top/anime`, ...(params ? [params]: [])] as const;
    }

    
export const getGetTopAnimeInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getTopAnime>>, GetTopAnimeParams['page']>, TError = AxiosError<void>>(params?: GetTopAnimeParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTopAnime>>, TError, TData, Awaited<ReturnType<typeof getTopAnime>>, QueryKey, GetTopAnimeParams['page']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTopAnimeQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTopAnime>>, QueryKey, GetTopAnimeParams['page']> = ({ signal, pageParam }) => getTopAnime({...params, page: pageParam || params?.['page']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTopAnime>>, TError, TData, Awaited<ReturnType<typeof getTopAnime>>, QueryKey, GetTopAnimeParams['page']> & { queryKey: QueryKey }
}

export type GetTopAnimeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getTopAnime>>>
export type GetTopAnimeInfiniteQueryError = AxiosError<void>

export const useGetTopAnimeInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getTopAnime>>, GetTopAnimeParams['page']>, TError = AxiosError<void>>(
 params?: GetTopAnimeParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTopAnime>>, TError, TData, Awaited<ReturnType<typeof getTopAnime>>, QueryKey, GetTopAnimeParams['page']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetTopAnimeInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTopAnimeQueryOptions = <TData = Awaited<ReturnType<typeof getTopAnime>>, TError = AxiosError<void>>(params?: GetTopAnimeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTopAnime>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTopAnimeQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTopAnime>>> = ({ signal }) => getTopAnime(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTopAnime>>, TError, TData> & { queryKey: QueryKey }
}

export type GetTopAnimeQueryResult = NonNullable<Awaited<ReturnType<typeof getTopAnime>>>
export type GetTopAnimeQueryError = AxiosError<void>

export const useGetTopAnime = <TData = Awaited<ReturnType<typeof getTopAnime>>, TError = AxiosError<void>>(
 params?: GetTopAnimeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTopAnime>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetTopAnimeQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getTopManga = (
    params?: GetTopMangaParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MangaSearch>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/top/manga`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetTopMangaQueryKey = (params?: GetTopMangaParams,) => {
    return [`https://api.jikan.moe/v4/top/manga`, ...(params ? [params]: [])] as const;
    }

    
export const getGetTopMangaInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getTopManga>>, GetTopMangaParams['page']>, TError = AxiosError<void>>(params?: GetTopMangaParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTopManga>>, TError, TData, Awaited<ReturnType<typeof getTopManga>>, QueryKey, GetTopMangaParams['page']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTopMangaQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTopManga>>, QueryKey, GetTopMangaParams['page']> = ({ signal, pageParam }) => getTopManga({...params, page: pageParam || params?.['page']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTopManga>>, TError, TData, Awaited<ReturnType<typeof getTopManga>>, QueryKey, GetTopMangaParams['page']> & { queryKey: QueryKey }
}

export type GetTopMangaInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getTopManga>>>
export type GetTopMangaInfiniteQueryError = AxiosError<void>

export const useGetTopMangaInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getTopManga>>, GetTopMangaParams['page']>, TError = AxiosError<void>>(
 params?: GetTopMangaParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTopManga>>, TError, TData, Awaited<ReturnType<typeof getTopManga>>, QueryKey, GetTopMangaParams['page']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetTopMangaInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTopMangaQueryOptions = <TData = Awaited<ReturnType<typeof getTopManga>>, TError = AxiosError<void>>(params?: GetTopMangaParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTopManga>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTopMangaQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTopManga>>> = ({ signal }) => getTopManga(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTopManga>>, TError, TData> & { queryKey: QueryKey }
}

export type GetTopMangaQueryResult = NonNullable<Awaited<ReturnType<typeof getTopManga>>>
export type GetTopMangaQueryError = AxiosError<void>

export const useGetTopManga = <TData = Awaited<ReturnType<typeof getTopManga>>, TError = AxiosError<void>>(
 params?: GetTopMangaParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTopManga>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetTopMangaQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getTopPeople = (
    params?: GetTopPeopleParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PeopleSearch>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/top/people`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetTopPeopleQueryKey = (params?: GetTopPeopleParams,) => {
    return [`https://api.jikan.moe/v4/top/people`, ...(params ? [params]: [])] as const;
    }

    
export const getGetTopPeopleInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getTopPeople>>, GetTopPeopleParams['page']>, TError = AxiosError<void>>(params?: GetTopPeopleParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTopPeople>>, TError, TData, Awaited<ReturnType<typeof getTopPeople>>, QueryKey, GetTopPeopleParams['page']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTopPeopleQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTopPeople>>, QueryKey, GetTopPeopleParams['page']> = ({ signal, pageParam }) => getTopPeople({...params, page: pageParam || params?.['page']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTopPeople>>, TError, TData, Awaited<ReturnType<typeof getTopPeople>>, QueryKey, GetTopPeopleParams['page']> & { queryKey: QueryKey }
}

export type GetTopPeopleInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getTopPeople>>>
export type GetTopPeopleInfiniteQueryError = AxiosError<void>

export const useGetTopPeopleInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getTopPeople>>, GetTopPeopleParams['page']>, TError = AxiosError<void>>(
 params?: GetTopPeopleParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTopPeople>>, TError, TData, Awaited<ReturnType<typeof getTopPeople>>, QueryKey, GetTopPeopleParams['page']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetTopPeopleInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTopPeopleQueryOptions = <TData = Awaited<ReturnType<typeof getTopPeople>>, TError = AxiosError<void>>(params?: GetTopPeopleParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTopPeople>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTopPeopleQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTopPeople>>> = ({ signal }) => getTopPeople(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTopPeople>>, TError, TData> & { queryKey: QueryKey }
}

export type GetTopPeopleQueryResult = NonNullable<Awaited<ReturnType<typeof getTopPeople>>>
export type GetTopPeopleQueryError = AxiosError<void>

export const useGetTopPeople = <TData = Awaited<ReturnType<typeof getTopPeople>>, TError = AxiosError<void>>(
 params?: GetTopPeopleParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTopPeople>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetTopPeopleQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getTopCharacters = (
    params?: GetTopCharactersParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CharactersSearch>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/top/characters`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetTopCharactersQueryKey = (params?: GetTopCharactersParams,) => {
    return [`https://api.jikan.moe/v4/top/characters`, ...(params ? [params]: [])] as const;
    }

    
export const getGetTopCharactersInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getTopCharacters>>, GetTopCharactersParams['page']>, TError = AxiosError<void>>(params?: GetTopCharactersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTopCharacters>>, TError, TData, Awaited<ReturnType<typeof getTopCharacters>>, QueryKey, GetTopCharactersParams['page']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTopCharactersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTopCharacters>>, QueryKey, GetTopCharactersParams['page']> = ({ signal, pageParam }) => getTopCharacters({...params, page: pageParam || params?.['page']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTopCharacters>>, TError, TData, Awaited<ReturnType<typeof getTopCharacters>>, QueryKey, GetTopCharactersParams['page']> & { queryKey: QueryKey }
}

export type GetTopCharactersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getTopCharacters>>>
export type GetTopCharactersInfiniteQueryError = AxiosError<void>

export const useGetTopCharactersInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getTopCharacters>>, GetTopCharactersParams['page']>, TError = AxiosError<void>>(
 params?: GetTopCharactersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTopCharacters>>, TError, TData, Awaited<ReturnType<typeof getTopCharacters>>, QueryKey, GetTopCharactersParams['page']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetTopCharactersInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTopCharactersQueryOptions = <TData = Awaited<ReturnType<typeof getTopCharacters>>, TError = AxiosError<void>>(params?: GetTopCharactersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTopCharacters>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTopCharactersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTopCharacters>>> = ({ signal }) => getTopCharacters(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTopCharacters>>, TError, TData> & { queryKey: QueryKey }
}

export type GetTopCharactersQueryResult = NonNullable<Awaited<ReturnType<typeof getTopCharacters>>>
export type GetTopCharactersQueryError = AxiosError<void>

export const useGetTopCharacters = <TData = Awaited<ReturnType<typeof getTopCharacters>>, TError = AxiosError<void>>(
 params?: GetTopCharactersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTopCharacters>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetTopCharactersQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getTopReviews = (
    params?: GetTopReviewsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetTopReviews200>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/top/reviews`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetTopReviewsQueryKey = (params?: GetTopReviewsParams,) => {
    return [`https://api.jikan.moe/v4/top/reviews`, ...(params ? [params]: [])] as const;
    }

    
export const getGetTopReviewsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getTopReviews>>, GetTopReviewsParams['page']>, TError = AxiosError<void>>(params?: GetTopReviewsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTopReviews>>, TError, TData, Awaited<ReturnType<typeof getTopReviews>>, QueryKey, GetTopReviewsParams['page']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTopReviewsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTopReviews>>, QueryKey, GetTopReviewsParams['page']> = ({ signal, pageParam }) => getTopReviews({...params, page: pageParam || params?.['page']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTopReviews>>, TError, TData, Awaited<ReturnType<typeof getTopReviews>>, QueryKey, GetTopReviewsParams['page']> & { queryKey: QueryKey }
}

export type GetTopReviewsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getTopReviews>>>
export type GetTopReviewsInfiniteQueryError = AxiosError<void>

export const useGetTopReviewsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getTopReviews>>, GetTopReviewsParams['page']>, TError = AxiosError<void>>(
 params?: GetTopReviewsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTopReviews>>, TError, TData, Awaited<ReturnType<typeof getTopReviews>>, QueryKey, GetTopReviewsParams['page']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetTopReviewsInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTopReviewsQueryOptions = <TData = Awaited<ReturnType<typeof getTopReviews>>, TError = AxiosError<void>>(params?: GetTopReviewsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTopReviews>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTopReviewsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTopReviews>>> = ({ signal }) => getTopReviews(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTopReviews>>, TError, TData> & { queryKey: QueryKey }
}

export type GetTopReviewsQueryResult = NonNullable<Awaited<ReturnType<typeof getTopReviews>>>
export type GetTopReviewsQueryError = AxiosError<void>

export const useGetTopReviews = <TData = Awaited<ReturnType<typeof getTopReviews>>, TError = AxiosError<void>>(
 params?: GetTopReviewsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTopReviews>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetTopReviewsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getUserFullProfile = (
    username: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetUserFullProfile200>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/users/${username}/full`,options
    );
  }


export const getGetUserFullProfileQueryKey = (username: string,) => {
    return [`https://api.jikan.moe/v4/users/${username}/full`] as const;
    }

    
export const getGetUserFullProfileInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getUserFullProfile>>>, TError = AxiosError<void>>(username: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserFullProfile>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserFullProfileQueryKey(username);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserFullProfile>>> = ({ signal }) => getUserFullProfile(username, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(username),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserFullProfile>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserFullProfileInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getUserFullProfile>>>
export type GetUserFullProfileInfiniteQueryError = AxiosError<void>

export const useGetUserFullProfileInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getUserFullProfile>>>, TError = AxiosError<void>>(
 username: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserFullProfile>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserFullProfileInfiniteQueryOptions(username,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetUserFullProfileQueryOptions = <TData = Awaited<ReturnType<typeof getUserFullProfile>>, TError = AxiosError<void>>(username: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFullProfile>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserFullProfileQueryKey(username);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserFullProfile>>> = ({ signal }) => getUserFullProfile(username, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(username),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserFullProfile>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserFullProfileQueryResult = NonNullable<Awaited<ReturnType<typeof getUserFullProfile>>>
export type GetUserFullProfileQueryError = AxiosError<void>

export const useGetUserFullProfile = <TData = Awaited<ReturnType<typeof getUserFullProfile>>, TError = AxiosError<void>>(
 username: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFullProfile>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserFullProfileQueryOptions(username,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getUserProfile = (
    username: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetUserProfile200>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/users/${username}`,options
    );
  }


export const getGetUserProfileQueryKey = (username: string,) => {
    return [`https://api.jikan.moe/v4/users/${username}`] as const;
    }

    
export const getGetUserProfileInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getUserProfile>>>, TError = AxiosError<void>>(username: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserProfile>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserProfileQueryKey(username);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserProfile>>> = ({ signal }) => getUserProfile(username, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(username),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserProfile>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserProfileInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getUserProfile>>>
export type GetUserProfileInfiniteQueryError = AxiosError<void>

export const useGetUserProfileInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getUserProfile>>>, TError = AxiosError<void>>(
 username: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserProfile>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserProfileInfiniteQueryOptions(username,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetUserProfileQueryOptions = <TData = Awaited<ReturnType<typeof getUserProfile>>, TError = AxiosError<void>>(username: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserProfile>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserProfileQueryKey(username);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserProfile>>> = ({ signal }) => getUserProfile(username, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(username),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserProfile>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserProfileQueryResult = NonNullable<Awaited<ReturnType<typeof getUserProfile>>>
export type GetUserProfileQueryError = AxiosError<void>

export const useGetUserProfile = <TData = Awaited<ReturnType<typeof getUserProfile>>, TError = AxiosError<void>>(
 username: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserProfile>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserProfileQueryOptions(username,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getUserStatistics = (
    username: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserStatistics>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/users/${username}/statistics`,options
    );
  }


export const getGetUserStatisticsQueryKey = (username: string,) => {
    return [`https://api.jikan.moe/v4/users/${username}/statistics`] as const;
    }

    
export const getGetUserStatisticsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getUserStatistics>>>, TError = AxiosError<void>>(username: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserStatistics>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserStatisticsQueryKey(username);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserStatistics>>> = ({ signal }) => getUserStatistics(username, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(username),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserStatistics>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserStatisticsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getUserStatistics>>>
export type GetUserStatisticsInfiniteQueryError = AxiosError<void>

export const useGetUserStatisticsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getUserStatistics>>>, TError = AxiosError<void>>(
 username: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserStatistics>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserStatisticsInfiniteQueryOptions(username,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetUserStatisticsQueryOptions = <TData = Awaited<ReturnType<typeof getUserStatistics>>, TError = AxiosError<void>>(username: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserStatistics>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserStatisticsQueryKey(username);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserStatistics>>> = ({ signal }) => getUserStatistics(username, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(username),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserStatistics>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserStatisticsQueryResult = NonNullable<Awaited<ReturnType<typeof getUserStatistics>>>
export type GetUserStatisticsQueryError = AxiosError<void>

export const useGetUserStatistics = <TData = Awaited<ReturnType<typeof getUserStatistics>>, TError = AxiosError<void>>(
 username: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserStatistics>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserStatisticsQueryOptions(username,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getUserFavorites = (
    username: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetUserFavorites200>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/users/${username}/favorites`,options
    );
  }


export const getGetUserFavoritesQueryKey = (username: string,) => {
    return [`https://api.jikan.moe/v4/users/${username}/favorites`] as const;
    }

    
export const getGetUserFavoritesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getUserFavorites>>>, TError = AxiosError<void>>(username: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserFavorites>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserFavoritesQueryKey(username);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserFavorites>>> = ({ signal }) => getUserFavorites(username, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(username),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserFavorites>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserFavoritesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getUserFavorites>>>
export type GetUserFavoritesInfiniteQueryError = AxiosError<void>

export const useGetUserFavoritesInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getUserFavorites>>>, TError = AxiosError<void>>(
 username: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserFavorites>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserFavoritesInfiniteQueryOptions(username,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetUserFavoritesQueryOptions = <TData = Awaited<ReturnType<typeof getUserFavorites>>, TError = AxiosError<void>>(username: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFavorites>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserFavoritesQueryKey(username);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserFavorites>>> = ({ signal }) => getUserFavorites(username, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(username),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserFavorites>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserFavoritesQueryResult = NonNullable<Awaited<ReturnType<typeof getUserFavorites>>>
export type GetUserFavoritesQueryError = AxiosError<void>

export const useGetUserFavorites = <TData = Awaited<ReturnType<typeof getUserFavorites>>, TError = AxiosError<void>>(
 username: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFavorites>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserFavoritesQueryOptions(username,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getUserUpdates = (
    username: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserUpdates>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/users/${username}/userupdates`,options
    );
  }


export const getGetUserUpdatesQueryKey = (username: string,) => {
    return [`https://api.jikan.moe/v4/users/${username}/userupdates`] as const;
    }

    
export const getGetUserUpdatesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getUserUpdates>>>, TError = AxiosError<void>>(username: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserUpdates>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserUpdatesQueryKey(username);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserUpdates>>> = ({ signal }) => getUserUpdates(username, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(username),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserUpdates>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserUpdatesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getUserUpdates>>>
export type GetUserUpdatesInfiniteQueryError = AxiosError<void>

export const useGetUserUpdatesInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getUserUpdates>>>, TError = AxiosError<void>>(
 username: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserUpdates>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserUpdatesInfiniteQueryOptions(username,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetUserUpdatesQueryOptions = <TData = Awaited<ReturnType<typeof getUserUpdates>>, TError = AxiosError<void>>(username: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserUpdates>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserUpdatesQueryKey(username);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserUpdates>>> = ({ signal }) => getUserUpdates(username, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(username),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserUpdates>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserUpdatesQueryResult = NonNullable<Awaited<ReturnType<typeof getUserUpdates>>>
export type GetUserUpdatesQueryError = AxiosError<void>

export const useGetUserUpdates = <TData = Awaited<ReturnType<typeof getUserUpdates>>, TError = AxiosError<void>>(
 username: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserUpdates>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserUpdatesQueryOptions(username,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getUserAbout = (
    username: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserAbout>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/users/${username}/about`,options
    );
  }


export const getGetUserAboutQueryKey = (username: string,) => {
    return [`https://api.jikan.moe/v4/users/${username}/about`] as const;
    }

    
export const getGetUserAboutInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getUserAbout>>>, TError = AxiosError<void>>(username: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserAbout>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserAboutQueryKey(username);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserAbout>>> = ({ signal }) => getUserAbout(username, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(username),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserAbout>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserAboutInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getUserAbout>>>
export type GetUserAboutInfiniteQueryError = AxiosError<void>

export const useGetUserAboutInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getUserAbout>>>, TError = AxiosError<void>>(
 username: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserAbout>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserAboutInfiniteQueryOptions(username,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetUserAboutQueryOptions = <TData = Awaited<ReturnType<typeof getUserAbout>>, TError = AxiosError<void>>(username: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserAbout>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserAboutQueryKey(username);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserAbout>>> = ({ signal }) => getUserAbout(username, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(username),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserAbout>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserAboutQueryResult = NonNullable<Awaited<ReturnType<typeof getUserAbout>>>
export type GetUserAboutQueryError = AxiosError<void>

export const useGetUserAbout = <TData = Awaited<ReturnType<typeof getUserAbout>>, TError = AxiosError<void>>(
 username: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserAbout>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserAboutQueryOptions(username,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getUserHistory = (
    username: string,
    params?: GetUserHistoryParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserHistory>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/users/${username}/history`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getUserFriends = (
    username: string,
    params?: GetUserFriendsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserFriends>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/users/${username}/friends`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetUserFriendsQueryKey = (username: string,
    params?: GetUserFriendsParams,) => {
    return [`https://api.jikan.moe/v4/users/${username}/friends`, ...(params ? [params]: [])] as const;
    }

    
export const getGetUserFriendsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getUserFriends>>, GetUserFriendsParams['page']>, TError = AxiosError<void>>(username: string,
    params?: GetUserFriendsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserFriends>>, TError, TData, Awaited<ReturnType<typeof getUserFriends>>, QueryKey, GetUserFriendsParams['page']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserFriendsQueryKey(username,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserFriends>>, QueryKey, GetUserFriendsParams['page']> = ({ signal, pageParam }) => getUserFriends(username,{...params, page: pageParam || params?.['page']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(username),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserFriends>>, TError, TData, Awaited<ReturnType<typeof getUserFriends>>, QueryKey, GetUserFriendsParams['page']> & { queryKey: QueryKey }
}

export type GetUserFriendsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getUserFriends>>>
export type GetUserFriendsInfiniteQueryError = AxiosError<void>

export const useGetUserFriendsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getUserFriends>>, GetUserFriendsParams['page']>, TError = AxiosError<void>>(
 username: string,
    params?: GetUserFriendsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserFriends>>, TError, TData, Awaited<ReturnType<typeof getUserFriends>>, QueryKey, GetUserFriendsParams['page']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserFriendsInfiniteQueryOptions(username,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetUserFriendsQueryOptions = <TData = Awaited<ReturnType<typeof getUserFriends>>, TError = AxiosError<void>>(username: string,
    params?: GetUserFriendsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFriends>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserFriendsQueryKey(username,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserFriends>>> = ({ signal }) => getUserFriends(username,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(username),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserFriends>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserFriendsQueryResult = NonNullable<Awaited<ReturnType<typeof getUserFriends>>>
export type GetUserFriendsQueryError = AxiosError<void>

export const useGetUserFriends = <TData = Awaited<ReturnType<typeof getUserFriends>>, TError = AxiosError<void>>(
 username: string,
    params?: GetUserFriendsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFriends>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserFriendsQueryOptions(username,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * User Anime lists have been discontinued since May 1st, 2022. <a href='https://docs.google.com/document/d/1-6H-agSnqa8Mfmw802UYfGQrceIEnAaEh4uCXAPiX5A'>Read more</a>
 * @deprecated
 */
export const getUserAnimelist = (
    username: string,
    params?: GetUserAnimelistParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/users/${username}/animelist`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



/**
 * User Manga lists have been discontinued since May 1st, 2022. <a href='https://docs.google.com/document/d/1-6H-agSnqa8Mfmw802UYfGQrceIEnAaEh4uCXAPiX5A'>Read more</a>
 * @deprecated
 */
export const getUserMangaList = (
    username: string,
    params?: GetUserMangaListParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/users/${username}/mangalist`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getUserReviews = (
    username: string,
    params?: GetUserReviewsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetUserReviews200>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/users/${username}/reviews`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetUserReviewsQueryKey = (username: string,
    params?: GetUserReviewsParams,) => {
    return [`https://api.jikan.moe/v4/users/${username}/reviews`, ...(params ? [params]: [])] as const;
    }

    
export const getGetUserReviewsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getUserReviews>>, GetUserReviewsParams['page']>, TError = AxiosError<void>>(username: string,
    params?: GetUserReviewsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserReviews>>, TError, TData, Awaited<ReturnType<typeof getUserReviews>>, QueryKey, GetUserReviewsParams['page']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserReviewsQueryKey(username,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserReviews>>, QueryKey, GetUserReviewsParams['page']> = ({ signal, pageParam }) => getUserReviews(username,{...params, page: pageParam || params?.['page']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(username),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserReviews>>, TError, TData, Awaited<ReturnType<typeof getUserReviews>>, QueryKey, GetUserReviewsParams['page']> & { queryKey: QueryKey }
}

export type GetUserReviewsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getUserReviews>>>
export type GetUserReviewsInfiniteQueryError = AxiosError<void>

export const useGetUserReviewsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getUserReviews>>, GetUserReviewsParams['page']>, TError = AxiosError<void>>(
 username: string,
    params?: GetUserReviewsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserReviews>>, TError, TData, Awaited<ReturnType<typeof getUserReviews>>, QueryKey, GetUserReviewsParams['page']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserReviewsInfiniteQueryOptions(username,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetUserReviewsQueryOptions = <TData = Awaited<ReturnType<typeof getUserReviews>>, TError = AxiosError<void>>(username: string,
    params?: GetUserReviewsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserReviews>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserReviewsQueryKey(username,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserReviews>>> = ({ signal }) => getUserReviews(username,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(username),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserReviews>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserReviewsQueryResult = NonNullable<Awaited<ReturnType<typeof getUserReviews>>>
export type GetUserReviewsQueryError = AxiosError<void>

export const useGetUserReviews = <TData = Awaited<ReturnType<typeof getUserReviews>>, TError = AxiosError<void>>(
 username: string,
    params?: GetUserReviewsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserReviews>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserReviewsQueryOptions(username,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getUserRecommendations = (
    username: string,
    params?: GetUserRecommendationsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Recommendations>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/users/${username}/recommendations`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetUserRecommendationsQueryKey = (username: string,
    params?: GetUserRecommendationsParams,) => {
    return [`https://api.jikan.moe/v4/users/${username}/recommendations`, ...(params ? [params]: [])] as const;
    }

    
export const getGetUserRecommendationsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getUserRecommendations>>, GetUserRecommendationsParams['page']>, TError = AxiosError<void>>(username: string,
    params?: GetUserRecommendationsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserRecommendations>>, TError, TData, Awaited<ReturnType<typeof getUserRecommendations>>, QueryKey, GetUserRecommendationsParams['page']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserRecommendationsQueryKey(username,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserRecommendations>>, QueryKey, GetUserRecommendationsParams['page']> = ({ signal, pageParam }) => getUserRecommendations(username,{...params, page: pageParam || params?.['page']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(username),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserRecommendations>>, TError, TData, Awaited<ReturnType<typeof getUserRecommendations>>, QueryKey, GetUserRecommendationsParams['page']> & { queryKey: QueryKey }
}

export type GetUserRecommendationsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getUserRecommendations>>>
export type GetUserRecommendationsInfiniteQueryError = AxiosError<void>

export const useGetUserRecommendationsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getUserRecommendations>>, GetUserRecommendationsParams['page']>, TError = AxiosError<void>>(
 username: string,
    params?: GetUserRecommendationsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserRecommendations>>, TError, TData, Awaited<ReturnType<typeof getUserRecommendations>>, QueryKey, GetUserRecommendationsParams['page']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserRecommendationsInfiniteQueryOptions(username,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetUserRecommendationsQueryOptions = <TData = Awaited<ReturnType<typeof getUserRecommendations>>, TError = AxiosError<void>>(username: string,
    params?: GetUserRecommendationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserRecommendations>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserRecommendationsQueryKey(username,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserRecommendations>>> = ({ signal }) => getUserRecommendations(username,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(username),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserRecommendations>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserRecommendationsQueryResult = NonNullable<Awaited<ReturnType<typeof getUserRecommendations>>>
export type GetUserRecommendationsQueryError = AxiosError<void>

export const useGetUserRecommendations = <TData = Awaited<ReturnType<typeof getUserRecommendations>>, TError = AxiosError<void>>(
 username: string,
    params?: GetUserRecommendationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserRecommendations>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserRecommendationsQueryOptions(username,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getUserClubs = (
    username: string,
    params?: GetUserClubsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserClubs>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/users/${username}/clubs`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetUserClubsQueryKey = (username: string,
    params?: GetUserClubsParams,) => {
    return [`https://api.jikan.moe/v4/users/${username}/clubs`, ...(params ? [params]: [])] as const;
    }

    
export const getGetUserClubsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getUserClubs>>, GetUserClubsParams['page']>, TError = AxiosError<void>>(username: string,
    params?: GetUserClubsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserClubs>>, TError, TData, Awaited<ReturnType<typeof getUserClubs>>, QueryKey, GetUserClubsParams['page']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserClubsQueryKey(username,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserClubs>>, QueryKey, GetUserClubsParams['page']> = ({ signal, pageParam }) => getUserClubs(username,{...params, page: pageParam || params?.['page']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(username),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserClubs>>, TError, TData, Awaited<ReturnType<typeof getUserClubs>>, QueryKey, GetUserClubsParams['page']> & { queryKey: QueryKey }
}

export type GetUserClubsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getUserClubs>>>
export type GetUserClubsInfiniteQueryError = AxiosError<void>

export const useGetUserClubsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getUserClubs>>, GetUserClubsParams['page']>, TError = AxiosError<void>>(
 username: string,
    params?: GetUserClubsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserClubs>>, TError, TData, Awaited<ReturnType<typeof getUserClubs>>, QueryKey, GetUserClubsParams['page']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserClubsInfiniteQueryOptions(username,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetUserClubsQueryOptions = <TData = Awaited<ReturnType<typeof getUserClubs>>, TError = AxiosError<void>>(username: string,
    params?: GetUserClubsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserClubs>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserClubsQueryKey(username,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserClubs>>> = ({ signal }) => getUserClubs(username,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(username),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserClubs>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserClubsQueryResult = NonNullable<Awaited<ReturnType<typeof getUserClubs>>>
export type GetUserClubsQueryError = AxiosError<void>

export const useGetUserClubs = <TData = Awaited<ReturnType<typeof getUserClubs>>, TError = AxiosError<void>>(
 username: string,
    params?: GetUserClubsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserClubs>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserClubsQueryOptions(username,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getUserExternal = (
    username: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ExternalLinks>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/users/${username}/external`,options
    );
  }


export const getGetUserExternalQueryKey = (username: string,) => {
    return [`https://api.jikan.moe/v4/users/${username}/external`] as const;
    }

    
export const getGetUserExternalInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getUserExternal>>>, TError = AxiosError<void>>(username: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserExternal>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserExternalQueryKey(username);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserExternal>>> = ({ signal }) => getUserExternal(username, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(username),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserExternal>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserExternalInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getUserExternal>>>
export type GetUserExternalInfiniteQueryError = AxiosError<void>

export const useGetUserExternalInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getUserExternal>>>, TError = AxiosError<void>>(
 username: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserExternal>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserExternalInfiniteQueryOptions(username,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetUserExternalQueryOptions = <TData = Awaited<ReturnType<typeof getUserExternal>>, TError = AxiosError<void>>(username: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserExternal>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserExternalQueryKey(username);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserExternal>>> = ({ signal }) => getUserExternal(username, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(username),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserExternal>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserExternalQueryResult = NonNullable<Awaited<ReturnType<typeof getUserExternal>>>
export type GetUserExternalQueryError = AxiosError<void>

export const useGetUserExternal = <TData = Awaited<ReturnType<typeof getUserExternal>>, TError = AxiosError<void>>(
 username: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserExternal>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserExternalQueryOptions(username,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getWatchRecentEpisodes = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<WatchEpisodes>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/watch/episodes`,options
    );
  }


export const getGetWatchRecentEpisodesQueryKey = () => {
    return [`https://api.jikan.moe/v4/watch/episodes`] as const;
    }

    
export const getGetWatchRecentEpisodesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getWatchRecentEpisodes>>>, TError = AxiosError<void>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWatchRecentEpisodes>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWatchRecentEpisodesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWatchRecentEpisodes>>> = ({ signal }) => getWatchRecentEpisodes({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWatchRecentEpisodes>>, TError, TData> & { queryKey: QueryKey }
}

export type GetWatchRecentEpisodesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getWatchRecentEpisodes>>>
export type GetWatchRecentEpisodesInfiniteQueryError = AxiosError<void>

export const useGetWatchRecentEpisodesInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getWatchRecentEpisodes>>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWatchRecentEpisodes>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetWatchRecentEpisodesInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetWatchRecentEpisodesQueryOptions = <TData = Awaited<ReturnType<typeof getWatchRecentEpisodes>>, TError = AxiosError<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWatchRecentEpisodes>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWatchRecentEpisodesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWatchRecentEpisodes>>> = ({ signal }) => getWatchRecentEpisodes({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWatchRecentEpisodes>>, TError, TData> & { queryKey: QueryKey }
}

export type GetWatchRecentEpisodesQueryResult = NonNullable<Awaited<ReturnType<typeof getWatchRecentEpisodes>>>
export type GetWatchRecentEpisodesQueryError = AxiosError<void>

export const useGetWatchRecentEpisodes = <TData = Awaited<ReturnType<typeof getWatchRecentEpisodes>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWatchRecentEpisodes>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetWatchRecentEpisodesQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getWatchPopularEpisodes = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<WatchEpisodes>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/watch/episodes/popular`,options
    );
  }


export const getGetWatchPopularEpisodesQueryKey = () => {
    return [`https://api.jikan.moe/v4/watch/episodes/popular`] as const;
    }

    
export const getGetWatchPopularEpisodesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getWatchPopularEpisodes>>>, TError = AxiosError<void>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWatchPopularEpisodes>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWatchPopularEpisodesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWatchPopularEpisodes>>> = ({ signal }) => getWatchPopularEpisodes({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWatchPopularEpisodes>>, TError, TData> & { queryKey: QueryKey }
}

export type GetWatchPopularEpisodesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getWatchPopularEpisodes>>>
export type GetWatchPopularEpisodesInfiniteQueryError = AxiosError<void>

export const useGetWatchPopularEpisodesInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getWatchPopularEpisodes>>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWatchPopularEpisodes>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetWatchPopularEpisodesInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetWatchPopularEpisodesQueryOptions = <TData = Awaited<ReturnType<typeof getWatchPopularEpisodes>>, TError = AxiosError<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWatchPopularEpisodes>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWatchPopularEpisodesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWatchPopularEpisodes>>> = ({ signal }) => getWatchPopularEpisodes({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWatchPopularEpisodes>>, TError, TData> & { queryKey: QueryKey }
}

export type GetWatchPopularEpisodesQueryResult = NonNullable<Awaited<ReturnType<typeof getWatchPopularEpisodes>>>
export type GetWatchPopularEpisodesQueryError = AxiosError<void>

export const useGetWatchPopularEpisodes = <TData = Awaited<ReturnType<typeof getWatchPopularEpisodes>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWatchPopularEpisodes>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetWatchPopularEpisodesQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getWatchRecentPromos = (
    params?: GetWatchRecentPromosParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<WatchPromos>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/watch/promos`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetWatchRecentPromosQueryKey = (params?: GetWatchRecentPromosParams,) => {
    return [`https://api.jikan.moe/v4/watch/promos`, ...(params ? [params]: [])] as const;
    }

    
export const getGetWatchRecentPromosInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getWatchRecentPromos>>, GetWatchRecentPromosParams['page']>, TError = AxiosError<void>>(params?: GetWatchRecentPromosParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWatchRecentPromos>>, TError, TData, Awaited<ReturnType<typeof getWatchRecentPromos>>, QueryKey, GetWatchRecentPromosParams['page']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWatchRecentPromosQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWatchRecentPromos>>, QueryKey, GetWatchRecentPromosParams['page']> = ({ signal, pageParam }) => getWatchRecentPromos({...params, page: pageParam || params?.['page']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWatchRecentPromos>>, TError, TData, Awaited<ReturnType<typeof getWatchRecentPromos>>, QueryKey, GetWatchRecentPromosParams['page']> & { queryKey: QueryKey }
}

export type GetWatchRecentPromosInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getWatchRecentPromos>>>
export type GetWatchRecentPromosInfiniteQueryError = AxiosError<void>

export const useGetWatchRecentPromosInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getWatchRecentPromos>>, GetWatchRecentPromosParams['page']>, TError = AxiosError<void>>(
 params?: GetWatchRecentPromosParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWatchRecentPromos>>, TError, TData, Awaited<ReturnType<typeof getWatchRecentPromos>>, QueryKey, GetWatchRecentPromosParams['page']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetWatchRecentPromosInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetWatchRecentPromosQueryOptions = <TData = Awaited<ReturnType<typeof getWatchRecentPromos>>, TError = AxiosError<void>>(params?: GetWatchRecentPromosParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWatchRecentPromos>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWatchRecentPromosQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWatchRecentPromos>>> = ({ signal }) => getWatchRecentPromos(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWatchRecentPromos>>, TError, TData> & { queryKey: QueryKey }
}

export type GetWatchRecentPromosQueryResult = NonNullable<Awaited<ReturnType<typeof getWatchRecentPromos>>>
export type GetWatchRecentPromosQueryError = AxiosError<void>

export const useGetWatchRecentPromos = <TData = Awaited<ReturnType<typeof getWatchRecentPromos>>, TError = AxiosError<void>>(
 params?: GetWatchRecentPromosParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWatchRecentPromos>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetWatchRecentPromosQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getWatchPopularPromos = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<WatchPromos>> => {
    
    return axios.get(
      `https://api.jikan.moe/v4/watch/promos/popular`,options
    );
  }


export const getGetWatchPopularPromosQueryKey = () => {
    return [`https://api.jikan.moe/v4/watch/promos/popular`] as const;
    }

    
export const getGetWatchPopularPromosInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getWatchPopularPromos>>>, TError = AxiosError<void>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWatchPopularPromos>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWatchPopularPromosQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWatchPopularPromos>>> = ({ signal }) => getWatchPopularPromos({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWatchPopularPromos>>, TError, TData> & { queryKey: QueryKey }
}

export type GetWatchPopularPromosInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getWatchPopularPromos>>>
export type GetWatchPopularPromosInfiniteQueryError = AxiosError<void>

export const useGetWatchPopularPromosInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getWatchPopularPromos>>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWatchPopularPromos>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetWatchPopularPromosInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetWatchPopularPromosQueryOptions = <TData = Awaited<ReturnType<typeof getWatchPopularPromos>>, TError = AxiosError<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWatchPopularPromos>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWatchPopularPromosQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWatchPopularPromos>>> = ({ signal }) => getWatchPopularPromos({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWatchPopularPromos>>, TError, TData> & { queryKey: QueryKey }
}

export type GetWatchPopularPromosQueryResult = NonNullable<Awaited<ReturnType<typeof getWatchPopularPromos>>>
export type GetWatchPopularPromosQueryError = AxiosError<void>

export const useGetWatchPopularPromos = <TData = Awaited<ReturnType<typeof getWatchPopularPromos>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWatchPopularPromos>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetWatchPopularPromosQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




